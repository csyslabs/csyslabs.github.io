<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dirac Sea</title>
  
  <subtitle>where the water tastes like wine</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="eetoa.github.io/"/>
  <updated>2021-03-17T15:00:09.278Z</updated>
  <id>eetoa.github.io/</id>
  
  <author>
    <name>etoa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【游戏逆向】常见内存操作</title>
    <link href="eetoa.github.io/2021/03/17/%E3%80%90%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E3%80%91%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/"/>
    <id>eetoa.github.io/2021/03/17/%E3%80%90%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E3%80%91%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/</id>
    <published>2021-03-17T11:53:12.000Z</published>
    <updated>2021-03-17T15:00:09.278Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>记录游戏逆向开发中的常见内存操作。</p><a id="more"></a><p><strong>本篇文章的方法皆经过验证，方法之间尽量保证低耦合，以方便单独使用。</strong></p><h3 id="内外部NOP"><a href="#内外部NOP" class="headerlink" title="内外部NOP"></a>内外部NOP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: GuidedHacking.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">namespace</span> mem </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Internal Nop</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mem::Nop</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DWORD oldprotect;</span><br><span class="line">        VirtualProtect(dst, <span class="built_in">size</span>, PAGE_EXECUTE_READWRITE, &amp;oldprotect);</span><br><span class="line">        <span class="built_in">memset</span>(dst, <span class="number">0x90</span>, <span class="built_in">size</span>);</span><br><span class="line">        VirtualProtect(dst, <span class="built_in">size</span>, oldprotect, &amp;oldprotect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//External</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mem::NopEx</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>, HANDLE hProcess)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>* nopArray = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">size</span>];</span><br><span class="line">        <span class="built_in">memset</span>(nopArray, <span class="number">0x90</span>, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">        DWORD oldprotect;</span><br><span class="line">        VirtualProtectEx(hProcess, dst, <span class="built_in">size</span>, PAGE_EXECUTE_READWRITE, &amp;oldprotect);</span><br><span class="line">        WriteProcessMemory(hProcess, dst, nopArray, <span class="built_in">size</span>, <span class="literal">NULL</span>);</span><br><span class="line">        VirtualProtectEx(hProcess, dst, <span class="built_in">size</span>, oldprotect, &amp;oldprotect);</span><br><span class="line">        <span class="keyword">delete</span>[] nopArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内外部Patch"><a href="#内外部Patch" class="headerlink" title="内外部Patch"></a>内外部Patch</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: GuidedHacking.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">namespace</span> mem </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// internal patch</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mem::Patch</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">char</span>* src, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DWORD oldprotect;</span><br><span class="line">        VirtualProtect(dst, <span class="built_in">size</span>, PAGE_EXECUTE_READWRITE, &amp;oldprotect);</span><br><span class="line">        <span class="built_in">memcpy</span>(dst, src, <span class="built_in">size</span>);</span><br><span class="line">        VirtualProtect(dst, <span class="built_in">size</span>, oldprotect, &amp;oldprotect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//external patch</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mem::PatchEx</span><span class="params">(HANDLE hProcess, <span class="keyword">char</span>* dst, <span class="keyword">char</span>* src, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DWORD oldprotect;</span><br><span class="line">        VirtualProtectEx(hProcess, dst, <span class="built_in">size</span>, PAGE_EXECUTE_READWRITE, &amp;oldprotect);</span><br><span class="line">        WriteProcessMemory(hProcess, dst, src, <span class="built_in">size</span>, <span class="literal">NULL</span>);</span><br><span class="line">        VirtualProtectEx(hProcess, dst, <span class="built_in">size</span>, oldprotect, &amp;oldprotect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内外部读多级指针指向的动态地址"><a href="#内外部读多级指针指向的动态地址" class="headerlink" title="内外部读多级指针指向的动态地址"></a>内外部读多级指针指向的动态地址</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: GuidedHacking.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// externally read address multi-level ptr points to</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">FindDMAAddy</span><span class="params">(HANDLE hProc, <span class="keyword">uintptr_t</span> ptr, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; offsets)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> addr = ptr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; offsets.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ReadProcessMemory(hProc, (BYTE*)addr, &amp;addr, <span class="keyword">sizeof</span>(addr), <span class="number">0</span>);</span><br><span class="line">        addr += offsets[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// internally read address multi-level ptr points to</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">FindDMAAddy</span><span class="params">(<span class="keyword">uintptr_t</span> ptr, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; offsets)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> addr = ptr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; offsets.<span class="built_in">size</span>() ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        addr = *(<span class="keyword">uintptr_t</span>*)addr;</span><br><span class="line">        addr += offsets[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内外部读地址的值"><a href="#内外部读地址的值" class="headerlink" title="内外部读地址的值"></a>内外部读地址的值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: accepted.org.cn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// reads memory externally and return a value as result</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ReadEx</span><span class="params">(<span class="keyword">uintptr_t</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T VALUE;</span><br><span class="line">    ReadProcessMemory(Game::procHandle, (LPCVOID)(address), &amp;VALUE, <span class="keyword">sizeof</span>(VALUE), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reads memory internally and return a value as result</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">Read</span><span class="params">(<span class="keyword">uintptr_t</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T VALUE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> preProtection;</span><br><span class="line">    VirtualProtect(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(address), <span class="keyword">sizeof</span>(address), PAGE_EXECUTE_READWRITE, &amp;preProtection);</span><br><span class="line"></span><br><span class="line">    VALUE = *(T*)address;</span><br><span class="line"></span><br><span class="line">    VirtualProtect(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(address), <span class="keyword">sizeof</span>(address), preProtection, &amp;preProtection);</span><br><span class="line">    <span class="keyword">return</span> VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内外部读多级指针对应的值"><a href="#内外部读多级指针对应的值" class="headerlink" title="内外部读多级指针对应的值"></a>内外部读多级指针对应的值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: accepted.org.cn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// externally read value multi-level ptr points to</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ReadPtrChainEx</span><span class="params">(<span class="keyword">uintptr_t</span> basePtr, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uintptr_t</span>&gt; offsetList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T VALUE;</span><br><span class="line">    <span class="comment">// don't reads last offset</span></span><br><span class="line">    <span class="keyword">int</span> len = offsetList.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// updates base pointer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ReadProcessMemory(Game::procHandle, (LPCVOID)(basePtr + offsetList[i]), &amp;basePtr, <span class="keyword">sizeof</span>(basePtr), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// read value with last offset</span></span><br><span class="line">    ReadProcessMemory(Game::procHandle, (LPCVOID)(basePtr + offsetList[len]), &amp;VALUE, <span class="keyword">sizeof</span>(VALUE), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// internally read value multi-level ptr points to</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ReadPtrChain</span><span class="params">(<span class="keyword">uintptr_t</span> basePtr, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uintptr_t</span>&gt; offsetList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T VALUE;</span><br><span class="line">    <span class="comment">// don't reads last offset</span></span><br><span class="line">    <span class="keyword">int</span> len = offsetList.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// updates base pointer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> address = basePtr + offsetList[i];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> preProtection;</span><br><span class="line">        VirtualProtect(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(address), <span class="keyword">sizeof</span>(address), PAGE_EXECUTE_READWRITE, &amp;preProtection);</span><br><span class="line"></span><br><span class="line">        basePtr = *(<span class="keyword">uintptr_t</span>*)address;</span><br><span class="line"></span><br><span class="line">        VirtualProtect(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(address), <span class="keyword">sizeof</span>(address), preProtection, &amp;preProtection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uintptr_t</span> address = basePtr + offsetList[len];</span><br><span class="line">    <span class="comment">// read value with last offset</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> preProtection;</span><br><span class="line">    VirtualProtect(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(address), <span class="keyword">sizeof</span>(address), PAGE_EXECUTE_READWRITE, &amp;preProtection);</span><br><span class="line"></span><br><span class="line">    VALUE = *(T*)address;</span><br><span class="line"></span><br><span class="line">    VirtualProtect(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(address), <span class="keyword">sizeof</span>(address), preProtection, &amp;preProtection);</span><br><span class="line">    <span class="keyword">return</span> VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;记录游戏逆向开发中的常见内存操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="不亦乐乎" scheme="eetoa.github.io/categories/%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/"/>
    
    
      <category term="游戏逆向" scheme="eetoa.github.io/tags/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>关于人际关系的一点点思考</title>
    <link href="eetoa.github.io/2021/03/10/%E5%85%B3%E4%BA%8E%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E6%80%9D%E8%80%83/"/>
    <id>eetoa.github.io/2021/03/10/%E5%85%B3%E4%BA%8E%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E6%80%9D%E8%80%83/</id>
    <published>2021-03-10T14:51:05.000Z</published>
    <updated>2021-03-10T15:01:26.094Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>生活感悟。</p><a id="more"></a><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>通过很长时间的观察和实践，我总结出了一个道理，人与人之间关系要想处的好，无非三个词：</p><p><strong>真诚</strong>，<strong>亲切</strong>，<strong>友善</strong>。</p><p>看似是没啥营养的大道理，实则为人情练达。</p><p>想TA之所想，感TA之所受，对TA多加关怀，让TA觉得自己是被重视的。</p><p>记住，要用心经营。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;生活感悟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="eetoa.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="人际关系" scheme="eetoa.github.io/tags/%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB/"/>
    
      <category term="生活" scheme="eetoa.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Win10 MySQL服务端完全卸载+安装</title>
    <link href="eetoa.github.io/2021/03/05/Win10-MySQL%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BD-%E5%AE%89%E8%A3%85/"/>
    <id>eetoa.github.io/2021/03/05/Win10-MySQL%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BD-%E5%AE%89%E8%A3%85/</id>
    <published>2021-03-05T10:15:51.000Z</published>
    <updated>2021-03-05T10:44:36.222Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>记录一下步骤。</p><a id="more"></a><h3 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h3><ul><li><p>定位到MySQL安装目录下的bin目录</p></li><li><p>打开cmd，假设需要备份到T盘根目录，那么键入：（其中，<code>root</code> 为用户名）<br><code>mysqldump --all-database &gt; T:\all_database.sql -u root -p</code></p></li><li><p>输入用户密码</p></li></ul><h3 id="彻底卸载MySQL"><a href="#彻底卸载MySQL" class="headerlink" title="彻底卸载MySQL"></a>彻底卸载MySQL</h3><ul><li><p>停止mysql服务<br>win+R→输入services.msc→服务→找到mysql并停止。</p></li><li><p>卸载mysql程序，mysql免安装版的删除安装目录即可<br>win+R→输入control→控制面板→卸载程序→找到mysql并卸载。</p></li><li><p>删除MySQL环境变量</p></li><li><p>彻底删除mysql配置文件和数据目录<br>确保安装目录已删除干净，我的安装目录是C:\Program Files\MySQL\MySQL Server 5.5\；<br>找到隐藏的数据目录并删除，默认安装位置在C:\ProgramData\MySQL\目录下，删除其中对应旧版本的mysql的目录，我的数据目录是C:\ProgramData\MySQL\MySQL Server 5.5/。<br><strong>注意：数据目录是隐藏的。</strong> </p></li><li><p>清理注册表<br>win+R→输入regedit→注册表编辑器<br>删除如下内容：<br><img src="0.png" alt="0"></p></li><li><p>重启电脑</p></li></ul><h3 id="安装MySQL服务端"><a href="#安装MySQL服务端" class="headerlink" title="安装MySQL服务端"></a>安装MySQL服务端</h3><ul><li><p>打开链接：<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">MySQL Community</a></p></li><li><p>下载压缩包</p></li><li><p>解压后在根目录下添加配置文件 <strong>my.ini</strong> ，内容为：（其中 <strong>basedir</strong> 为根目录）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="attr">basedir</span>=T:\\MySQL\\Server\\mysql-<span class="number">8.0</span>.<span class="number">23</span>-winx64</span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">20</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br></pre></td></tr></table></figure></li><li><p>将根目录下的 <strong>bin</strong> 目录添加到系统环境变量</p></li><li><p>cmd下打开 <strong>bin</strong> 目录，执行安装指令：</p><blockquote><ol><li><code>mysqld --initialize --console</code></li><li>将 <code>root@localhost:</code>后跟的密码记录保存下来。</li><li><code>mysqld install</code></li><li><code>net start mysql</code></li></ol></blockquote></li></ul><div class="note primary">            <p><strong>参考链接：</strong> <a href="https://blog.csdn.net/hui1setouxiang/article/details/89816176" target="_blank" rel="noopener">level0_older25_cz@CSDN</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;记录一下步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
    
      <category term="MySQL" scheme="eetoa.github.io/tags/MySQL/"/>
    
      <category term="数据库" scheme="eetoa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>快速幂专题</title>
    <link href="eetoa.github.io/2021/03/05/%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%93%E9%A2%98/"/>
    <id>eetoa.github.io/2021/03/05/%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%93%E9%A2%98/</id>
    <published>2021-03-05T03:11:09.000Z</published>
    <updated>2021-03-08T17:19:55.803Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>深入快速幂。</p><a id="more"></a><h3 id="朴素快速幂"><a href="#朴素快速幂" class="headerlink" title="朴素快速幂"></a>朴素快速幂</h3><p>快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在$O(logn)$的时间内计算$a^n$的小技巧，而暴力的计算需要$O(n)$的时间。</p><p><strong>二进制取幂</strong> 的想法是，我们将取幂的任务按照指数的 <strong>二进制表示</strong> 来分割成更小的任务。</p><p>举例：计算 $3^{13}$.</p><p>将$3^{13}$拆成：<br>$3^{13} = 3^{(1101)_2} = 3^8 \cdot 3^4 \cdot 3^1$ </p><p>我们可以预处理出来$3^1, 3^4, 3^8$，一共只需计算3次得到答案。<br>3是怎么来的呢？<br>因为$3^{2^3} &lt; 3^{13} &lt; 3^{2^4}$，所以$3 = \lfloor \log_2(13) \rfloor$。</p><p>那么，对于$a^n$，因为$n$有$\lfloor \log_2(n) \rfloor + 1$个二进制位，那么当我们预处理出:<br>$a^1, a^2, a^4, a^8,…,a^{2^{\log_2(n)}}$ 后，就只需计算$O(logn)$次乘法即可计算出$a^n$。</p><p>而这个预处理的每一个项，都可以由前面的项计算得到。<br>从二进制最低位到最高位，假设全为1，那么每一项都等于前一项的平方；<br>假设从低到高位依次为$101$，那么第一项显然为底数本身，第二项为$1$，第三项并非由第二项得出，而是第一项的平方的平方。</p><p>根据这个思想，写代码的时候，我们动态地让指数右移，让$a$与最低位$1$相乘，然而每右移一次，相当于指数$b$除2，等价于$a$对应地更新成$a^2$。当最低位不为$1$时，则$a$继续更新，且不与最低位相乘。</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res *= a;</span><br><span class="line">        a = a * a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><div class="note primary">            <p><strong>原题链接：</strong> <a href=""></a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;深入快速幂。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="eetoa.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="矩阵快速幂" scheme="eetoa.github.io/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
      <category term="快速幂" scheme="eetoa.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
      <category term="高精度快速幂" scheme="eetoa.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 191.位1的个数</title>
    <link href="eetoa.github.io/2021/03/03/LeetCode-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>eetoa.github.io/2021/03/03/LeetCode-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2021-03-03T14:53:37.000Z</published>
    <updated>2021-03-04T04:19:23.998Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>位运算判断最低位1。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <strong>汉明重量</strong>）。</p><p><strong>提示：</strong></p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><p><strong>进阶：</strong></p><p>如果多次调用这个函数，你将如何优化你的算法？</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> 00000000000000000000000000001011<br><strong>输出：</strong> 3<br><strong>解释：</strong> 输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> 00000000000000000000000010000000<br><strong>输出：</strong> 1<br><strong>解释：</strong> 输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> 11111111111111111111111111111101<br><strong>输出：</strong> 31<br><strong>解释：</strong> 输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p></blockquote><p><strong>提示：</strong></p><ul><li>输入必须是长度为 <code>32</code> 的 二进制串 。</li></ul><hr><h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>使用lowbit找到 <code>x</code> 最低位1以及其更低位所有0所表示的数，更新 <code>x</code>.</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.9 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">uint32_t</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; n; n -= lowbit(n)) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.3 MB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; n != <span class="number">0</span>; n -= lowbit(n)) res++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>注意c++和java的传入参数 <code>n</code> 一个是无符号整型（unsigned int）一个是有符号整型（int），因为java中没有无符号整型，所以理解的时候需要注意区别。但是代码没有区别，因为不管有无符号，数字在计算机底层都是以补码形式表示的， <code>lowbit</code> 返回的值一定是补码最低位1以及其更低位所有0表示的数。</p><p>举个例子说明它们的区别，对于示例3：<br><code>11111111111111111111111111111101</code><br>这个二进制数字在这道题的c++中表示为一个补码正数 <code>4294967293</code>，<br>而在java中，因为是有符号的，表示一个补码负数 <code>-3</code>.<br>也就是说，这道题在LeetCode后端评测器参数设定中，是用的不同数字分别表示c++和java语言中的这个二进制数的。</p><p>c++中对这个数进行一次 <code>lowbit</code> 操作得到的数为：<br><code>1</code> ，对应二进制补码为 <code>00000000000000000000000000000001</code><br>java中对这个数进行一次 <code>lowbit</code> 操作得到的数为：<br><code>1</code> ，对应二进制补码为 <code>00000000000000000000000000000001</code><br>是完全相同的。<br><code>lowbit</code> 赛高~！</p><h3 id="位运算小技巧"><a href="#位运算小技巧" class="headerlink" title="位运算小技巧"></a>位运算小技巧</h3><p>在二进制表示中，数字 <code>n</code> 的 <strong>最低位</strong> 1总是对应 n - 1 中的0。<br>利用这一性质，利用 <code>n &amp; n - 1</code> 可以巧妙找到最低位1.<br>在这里, <code>n &amp; n - 1</code> 等价于 <code>n - lowbit(n)</code>.</p><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">c++</a></li><li class="tab"><a href="#g_tab1-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; n; n &amp;= n - <span class="number">1</span>) res++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.2 MB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; n != <span class="number">0</span>; n &amp;= n - <span class="number">1</span>) res++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="循环，用掩码判断"><a href="#循环，用掩码判断" class="headerlink" title="循环，用掩码判断"></a>循环，用掩码判断</h3><p>从最低位开始，设置一个掩码，初始化为 <code>00000000000000000000000000000001</code>.<br>让其对原数字进行 <code>&amp;</code> 运算，判断最低位是否为 <code>1</code>。<br>然后掩码左移一位，更新掩码，依次逐位判断当前位是否为 <code>1</code>.<br>注意在c++中，需要用无符号整型来表示掩码。</p><div class="tabs" id="g_tab2"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab2-1">c++</a></li><li class="tab"><a href="#g_tab2-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab2-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.7 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; mask) res++;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab2-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 36.2 MB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) res++;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="循环，用原数字判断"><a href="#循环，用原数字判断" class="headerlink" title="循环，用原数字判断"></a>循环，用原数字判断</h3><p>可以固定掩码 <code>1</code>， 不断右移原数字，始终判断最低位。<br>因为c++中，原数字为无符号整型，所以原数字可以直接右移；<br>而java中，原数字有符号，所以需要使用无符号右移运算符 <code>&gt;&gt;&gt;</code>.</p><div class="tabs" id="g_tab3"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab3-1">c++</a></li><li class="tab"><a href="#g_tab3-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab3-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.9 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; mask) res++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab3-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.4 MB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) res++;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="轮子"><a href="#轮子" class="headerlink" title="轮子"></a>轮子</h3><p>使用c++和java的内置轮子。</p><div class="tabs" id="g_tab4"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab4-1">c++</a></li><li class="tab"><a href="#g_tab4-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab4-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __builtin_popcount(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab4-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.2 MB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">LeetCode 191.位1的个数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;位运算判断最低位1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="eetoa.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="eetoa.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="lowbit" scheme="eetoa.github.io/tags/lowbit/"/>
    
      <category term="剑指Offer" scheme="eetoa.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="汉明重量" scheme="eetoa.github.io/tags/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 15.二进制中1的个数</title>
    <link href="eetoa.github.io/2021/03/03/%E5%89%91%E6%8C%87Offer-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>eetoa.github.io/2021/03/03/%E5%89%91%E6%8C%87Offer-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2021-03-03T14:48:46.000Z</published>
    <updated>2021-03-04T04:21:13.183Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>位运算判断最低位1。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> 00000000000000000000000000001011<br><strong>输出：</strong> 3<br><strong>解释：</strong> 输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> 00000000000000000000000010000000<br><strong>输出：</strong> 1<br><strong>解释：</strong> 输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> 11111111111111111111111111111101<br><strong>输出：</strong> 31<br><strong>解释：</strong> 输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p></blockquote><p><strong>提示：</strong></p><ul><li>输入必须是长度为 32 的 二进制串 。</li></ul><hr><p>与 <a href="https://esp0xa.github.io/2021/03/03/LeetCode-191-位1的个数/" target="_blank" rel="noopener">LeetCode 191.位1的个数</a> 重复。</p><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">剑指Offer 15.二进制中1的个数</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;位运算判断最低位1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="eetoa.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="eetoa.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="lowbit" scheme="eetoa.github.io/tags/lowbit/"/>
    
      <category term="剑指Offer" scheme="eetoa.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="汉明重量" scheme="eetoa.github.io/tags/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring注解 @Component @Repository @service @Controller之间的区别</title>
    <link href="eetoa.github.io/2021/03/01/Spring%E6%B3%A8%E8%A7%A3-Component-Repository-service-Controller%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>eetoa.github.io/2021/03/01/Spring%E6%B3%A8%E8%A7%A3-Component-Repository-service-Controller%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-03-01T09:58:07.000Z</published>
    <updated>2021-03-02T03:35:25.148Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>[待完善] 这四个注解主要作用。</p><a id="more"></a><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p><code>@Component</code> 、 <code>@Repository</code> 、 <code>@Service</code> 、 <code>@Controller</code> 都是用来自动注册bean的。<br>在 <code>SpringApplication.run()</code> 启动的时候，spring会自动创建一个IOC容器，并且为IOC容器自动扫描配置类所在包以及子包下的所有被以上四个注解标注的类。<br>区别在于：<br><code>@Service</code> 用于标注业务层组件<br><code>@Controller</code> 用于标注控制层组件（如struts中的action），处理请求。<br><code>@Repository</code> 用于标注数据访问组件，即DAO组件<br><code>@Component</code> 泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注，在以上三种任意地方使用。</p><div class="note primary">            <p><strong>转载链接：</strong> <a href="https://zhuanlan.zhihu.com/p/28346387" target="_blank" rel="noopener">呵呵一笑很倾城 | 知乎</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;[待完善] 这四个注解主要作用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="Project" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/Project/"/>
    
    
      <category term="Java" scheme="eetoa.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="eetoa.github.io/tags/Spring/"/>
    
      <category term="注解" scheme="eetoa.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>快速优雅裸连github</title>
    <link href="eetoa.github.io/2021/02/28/%E5%BF%AB%E9%80%9F%E4%BC%98%E9%9B%85%E8%A3%B8%E8%BF%9Egithub/"/>
    <id>eetoa.github.io/2021/02/28/%E5%BF%AB%E9%80%9F%E4%BC%98%E9%9B%85%E8%A3%B8%E8%BF%9Egithub/</id>
    <published>2021-02-28T06:56:49.000Z</published>
    <updated>2021-03-04T05:37:47.138Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>真的好丝滑。</p><a id="more"></a><h3 id="改Hosts大法"><a href="#改Hosts大法" class="headerlink" title="改Hosts大法"></a>改Hosts大法</h3><p>一共6个ip地址及网址，每行一个，中间注意空格。</p><ul><li>打开../Windows/System32/drivers/etc/hosts</li><li><ol><li>打开链接 <strong><a href="https://github.com.ipaddress.com/" target="_blank" rel="noopener">https://github.com.ipaddress.com/</a></strong><br>将 <strong>IP Address</strong> 拷贝到hosts文件新的一行，后面加上 <code>github.com</code></li></ol></li><li><ol start="2"><li>打开链接 <strong><a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo" target="_blank" rel="noopener">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo</a></strong><br>将 <strong>IP Address</strong> 拷贝到hosts文件新的一行，后面加上 <code>github.global.ssl.fastly.net</code></li></ol></li><li><ol start="3"><li>打开链接 <strong><a href="https://github.com.ipaddress.com/assets-cdn.github.com" target="_blank" rel="noopener">https://github.com.ipaddress.com/assets-cdn.github.com</a></strong> 将Frequently Asked Question (FAQ) 下的四行ip地址拷贝到hosts文件新的四行，后面分别加上 <code>assets-cdn.github.com</code></li></ol></li><li>管理员模式保存hosts文件</li><li>刷新DNS缓存 cmd: <code>ipconfig /flushdns</code></li></ul><h3 id="改好如下所示"><a href="#改好如下所示" class="headerlink" title="改好如下所示"></a>改好如下所示</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">140.82.114.3        github.com </span><br><span class="line">199.232.69.194      github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153     assets-cdn.github.com</span><br><span class="line">185.199.109.153     assets-cdn.github.com</span><br><span class="line">185.199.110.153     assets-cdn.github.com</span><br><span class="line">185.199.111.153     assets-cdn.github.com</span><br></pre></td></tr></table></figure><div class="note primary">            <p><strong>转载链接：</strong> <a href="https://juejin.cn/post/6844904193170341896" target="_blank" rel="noopener">GitHub无法访问、443 Operation timed out的解决办法</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;真的好丝滑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="不亦乐乎" scheme="eetoa.github.io/categories/%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/"/>
    
    
      <category term="GitHub" scheme="eetoa.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 13.机器人的运动范围</title>
    <link href="eetoa.github.io/2021/02/27/%E5%89%91%E6%8C%87Offer-13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>eetoa.github.io/2021/02/27/%E5%89%91%E6%8C%87Offer-13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</id>
    <published>2021-02-27T11:29:20.000Z</published>
    <updated>2021-02-27T12:28:48.202Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>DFS BFS模板题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> m = 2, n = 3, k = 1<br><strong>输出：</strong> 3</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> m = 3, n = 1, k = 0<br><strong>输出：</strong> 1</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= n,m &lt;= 100$</li><li>$0 &lt;= k &lt;= 20$</li></ul><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>本题是从左上向右下搜索，所以可以只用两个方向。以下代码可以进一步优化。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 6.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTwoSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(x) + getSum(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x /= <span class="number">10</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int64_t</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> g_m, g_n, g_k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        g_m = m, g_n = n, g_k = k;</span><br><span class="line">        st = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        res++;</span><br><span class="line">        st[r][c] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; g_m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; g_n &amp;&amp; getTwoSum(ner, nec) &lt;= g_k &amp;&amp; !st[ner][nec]) &#123;</span><br><span class="line">                dfs(ner, nec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 36 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x &gt; <span class="number">0</span>; x /= <span class="number">10</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getTwoSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(x) + getSum(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> g_m, g_n, g_k;</span><br><span class="line">    <span class="keyword">int</span>[] dr, dc;</span><br><span class="line">    <span class="keyword">boolean</span>[][] st;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        g_m = m;</span><br><span class="line">        g_n = n;</span><br><span class="line">        g_k = k;</span><br><span class="line">        dr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        dc = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        st = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ ) &#123;</span><br><span class="line">            Arrays.fill(st[i], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        res++;</span><br><span class="line">        st[r][c] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; g_m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; g_n &amp;&amp; !st[ner][nec] &amp;&amp; getTwoSum(ner, nec) &lt;= g_k) &#123;</span><br><span class="line">                dfs(ner, nec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>注意响铃节点的竞争问题，要在下一个节点入队时将节点更新成已占据，以避免此问题。</p><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">c++</a></li><li class="tab"><a href="#g_tab1-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 4 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 6.4 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x /= <span class="number">10</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTwoSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(x) + getSum(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> g_m, g_n, g_k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        g_m = m, g_n = n, g_k = k;</span><br><span class="line">        st = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        bfs(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        st[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; q.<span class="built_in">size</span>();) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = q.front().first, c = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">2</span>; d++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">                <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; g_m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; g_n &amp;&amp; !st[ner][nec] &amp;&amp; getTwoSum(ner, nec) &lt;= g_k) &#123;</span><br><span class="line">                    q.push(&#123;ner, nec&#125;);</span><br><span class="line">                    st[ner][nec] = <span class="literal">true</span>;    <span class="comment">// 避免相邻节点竞争</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 5 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x &gt; <span class="number">0</span>; x /= <span class="number">10</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTwoSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(x) + getSum(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n, k;</span><br><span class="line">    <span class="keyword">int</span>[] dr, dc;</span><br><span class="line">    <span class="keyword">boolean</span>[][] st;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        dr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        dc = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        st = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            Arrays.fill(st[i], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bfs(<span class="number">0</span> * n + <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.add(hash);</span><br><span class="line">        st[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; q.size() &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="keyword">int</span> _hash = q.remove();</span><br><span class="line">            <span class="keyword">int</span> r = _hash / n, c = _hash % n;</span><br><span class="line">            res++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[i], nec = c + dc[i];</span><br><span class="line">                <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; !st[ner][nec] &amp;&amp; getTwoSum(ner, nec) &lt;= k) &#123;</span><br><span class="line">                    q.add(ner * n + nec);</span><br><span class="line">                    st[ner][nec] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">剑指Offer 13.机器人的运动范围</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;DFS BFS模板题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="eetoa.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="eetoa.github.io/tags/BFS/"/>
    
      <category term="剑指Offer" scheme="eetoa.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 12.矩阵中的路径</title>
    <link href="eetoa.github.io/2021/02/27/%E5%89%91%E6%8C%87Offer-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>eetoa.github.io/2021/02/27/%E5%89%91%E6%8C%87Offer-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2021-02-27T10:58:11.000Z</published>
    <updated>2021-02-27T11:04:47.725Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>回溯算法经典题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,” <strong>b</strong> “,”c”,”e”],<br>[“s”,” <strong>f</strong> “,” <strong>c</strong> “,”s”],<br>[“a”,”d”,” <strong>e</strong> “,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br><strong>输出：</strong> true</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> board = [[“a”,”b”],[“c”,”d”]], word = “abcd”<br><strong>输出：</strong> false</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= board.length &lt;= 200$</li><li>$1 &lt;= board[i].length &lt;= 200$</li></ul><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>本题与 <a href="https://accepted.org.cn/2021/02/27/LeetCode-79-单词搜索/" target="_blank" rel="noopener">LeetCode 79.单词搜索</a> 完全相同。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 44 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 11.1 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">string</span> w;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        b = board, w = <span class="keyword">word</span>;</span><br><span class="line">        m = b.<span class="built_in">size</span>(), n = b[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        len = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        st = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; (m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b[i][j] == w[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b[r][c] != w[u]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正确的节点</span></span><br><span class="line">        st[r][c] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; !st[ner][nec]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(ner, nec, u + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        st[r][c] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 7 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 40.1 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[][] b;</span><br><span class="line">    String w;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span>[] dr, dc;</span><br><span class="line">    <span class="keyword">boolean</span>[][] st;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        b = board;</span><br><span class="line">        w = word;</span><br><span class="line">        m = b.length;</span><br><span class="line">        n = b[<span class="number">0</span>].length;</span><br><span class="line">        len = w.length();</span><br><span class="line">        dr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        dc = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        st = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(st[i], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b[i][j] == w.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b[r][c] != w.charAt(u)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == len - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// else keep checking</span></span><br><span class="line">        st[r][c] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; !st[ner][nec]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(ner, nec, u + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st[r][c] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指Offer 12.矩阵中的路径</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;回溯算法经典题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="eetoa.github.io/tags/DFS/"/>
    
      <category term="剑指Offer" scheme="eetoa.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="回溯" scheme="eetoa.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 79.单词搜索</title>
    <link href="eetoa.github.io/2021/02/27/LeetCode-79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <id>eetoa.github.io/2021/02/27/LeetCode-79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</id>
    <published>2021-02-27T08:39:10.000Z</published>
    <updated>2021-02-27T10:28:50.036Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>回溯算法经典问题，暴力深搜。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例:</strong></p><blockquote><p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p><p>给定 word = “ABCCED”, 返回 true<br>给定 word = “SEE”, 返回 true<br>给定 word = “ABCB”, 返回 false</p></blockquote><p><strong>提示：</strong></p><ul><li><code>board</code> 和 <code>word</code> 中只包含大写和小写英文字母。</li><li>$1 &lt;= board.length &lt;= 200$</li><li>$1 &lt;= board[i].length &lt;= 200$</li><li>$1 &lt;= word.length &lt;= 10^3$</li></ul><hr><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>搜索方式有点类似 <strong>洪水灌溉算法</strong>。遍历数组找出起点，对于每一个起点启动深搜，每一个字符搜索三个方向，直到匹配或者字符不相同为止。<br>可以借助辅助数组标记正确的节点位置防止字符重复使用（路径重叠），也可以原地更改节点字符为一个非字母字符。<br>回溯的时候记得恢复现场，标记数组或者更改的字符要恢复成递归之前的值。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 44 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 11.1 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">string</span> w;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        b = board, w = <span class="keyword">word</span>;</span><br><span class="line">        m = b.<span class="built_in">size</span>(), n = b[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        len = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        st = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; (m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b[i][j] == w[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b[r][c] != w[u]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正确的节点</span></span><br><span class="line">        st[r][c] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; !st[ner][nec]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(ner, nec, u + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        st[r][c] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 7 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 40.1 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[][] b;</span><br><span class="line">    String w;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span>[] dr, dc;</span><br><span class="line">    <span class="keyword">boolean</span>[][] st;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        b = board;</span><br><span class="line">        w = word;</span><br><span class="line">        m = b.length;</span><br><span class="line">        n = b[<span class="number">0</span>].length;</span><br><span class="line">        len = w.length();</span><br><span class="line">        dr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        dc = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        st = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(st[i], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b[i][j] == w.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b[r][c] != w.charAt(u)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == len - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// else keep checking</span></span><br><span class="line">        st[r][c] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; !st[ner][nec]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(ner, nec, u + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st[r][c] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">LeetCode 79.单词搜索</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;回溯算法经典问题，暴力深搜。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="eetoa.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="eetoa.github.io/tags/DFS/"/>
    
      <category term="回溯" scheme="eetoa.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 11.旋转数组的最小数字</title>
    <link href="eetoa.github.io/2021/02/26/%E5%89%91%E6%8C%87Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>eetoa.github.io/2021/02/26/%E5%89%91%E6%8C%87Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2021-02-26T11:26:56.000Z</published>
    <updated>2021-02-26T11:53:48.945Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>二分查找经典应用。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。  </p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> [3,4,5,1,2]<br><strong>输出：</strong> 1</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> [2,2,2,0,1]<br><strong>输出：</strong> 0</p></blockquote><hr><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>本题与 <a href="https://accepted.org.cn/2021/02/26/LeetCode-154-寻找旋转排序数组中的最小值-II/" target="_blank" rel="noopener">LeetCode 154.寻找旋转排序数组中的最小值 II</a> 完全一致。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 4 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 11.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判非递减情况（折叠点不在原数组下标范围内）</span></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判折叠点在重复数字中的情况（折叠后数组首尾相同）</span></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi &amp;&amp; nums[hi] == nums[<span class="number">0</span>]; hi--); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时存在两种情况，一是右半边还有数字，二是右半边无数字</span></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[<span class="number">0</span>]) <span class="keyword">return</span> nums[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常规情况，和153题解法一致</span></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 38.3 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = len - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi &amp;&amp; nums[lo] == nums[hi]; hi--);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="暴搜"><a href="#暴搜" class="headerlink" title="暴搜"></a>暴搜</h3><p>暴力Loop一把梭，复杂度为 $O(N)$.</p><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">c++</a></li><li class="tab"><a href="#g_tab1-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 4 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 11.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        len = numbers.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &lt; numbers[i - <span class="number">1</span>]) <span class="keyword">return</span> numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 38.3 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        len = numbers.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &lt; numbers[i - <span class="number">1</span>]) <span class="keyword">return</span> numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">剑指Offer 11. 旋转数组的最小数字</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;二分查找经典应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="eetoa.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="剑指Offer" scheme="eetoa.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 154.寻找旋转排序数组中的最小值 II</title>
    <link href="eetoa.github.io/2021/02/26/LeetCode-154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-II/"/>
    <id>eetoa.github.io/2021/02/26/LeetCode-154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-II/</id>
    <published>2021-02-26T10:31:53.000Z</published>
    <updated>2021-02-26T11:50:27.904Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>二分查找经典应用。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入:</strong> [1,3,5]<br><strong>输出:</strong> 1</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入:</strong> [2,2,2,0,1]<br><strong>输出:</strong> 0</p></blockquote><p><strong>说明：</strong></p><ul><li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a> 的延伸题目。</li><li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li></ul><hr><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>这道题和 <a href="https://accepted.org.cn/2021/02/26/LeetCode-153-寻找旋转排序数组中的最小值/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a> 的区别就在于折叠数组中可能存在重复。</p><p>什么时候会产生影响呢？那就是当折叠点在原数组中某一数字相同段内时，折叠之后，数组首尾相同。那么，如果 <code>mid</code> 更新到与数组首尾相同的数字时，我们无法利用二分查找所依赖的 <strong>性质</strong> 确定 <code>mid</code> 是在左半边还是右半边。</p><p>那么，解题思路就是：</p><ul><li>先特判非单调递减情况，排除原数组折叠点在数组下标范围外的情况。</li><li>再特判折叠数组首尾相同的情况，方法是移动右指针向左直到和左端点不同为止。那么此时又有两种情况：</li></ul><ol><li>右半边全为与左端点相同的数字，那么此时右指针移到了左半边， <code>nums[hi] &gt; nums[0]</code></li><li>右半边不全是与左端点相同的数字，那么此时右指针依然在右半边， <code>nums[hi] &lt; nums[0]</code></li></ol><ul><li>对于以上情况1，直接返回数组首即可；而对于情况2，需要按照传统二分查找，找到右半边的左边界。详情请参考： <strong><a href="https://accepted.org.cn/2021/02/26/LeetCode-153-寻找旋转排序数组中的最小值/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a></strong></li></ul><p>另外可以想一下，如果折叠数组数组完全相同，也就是最坏的情况，会怎么样。<br>那必然是最终右指针左移时与左指针相遇，进行一次常规二分直接得出答案。当然也可以在进入常规二分之前特判一下，都无所谓。<br>最坏的情况下，复杂度为 $O(N)$，平均的情况下，复杂度为 $O(logn)$.</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 4 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 11.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判非递减情况（折叠点不在原数组下标范围内）</span></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判折叠点在重复数字中的情况（折叠后数组首尾相同）</span></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi &amp;&amp; nums[hi] == nums[<span class="number">0</span>]; hi--); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时存在两种情况，一是右半边还有数字，二是右半边无数字</span></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[<span class="number">0</span>]) <span class="keyword">return</span> nums[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常规情况，和153题解法一致</span></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 38.3 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = len - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi &amp;&amp; nums[lo] == nums[hi]; hi--);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">LeetCode 154.寻找旋转排序数组中的最小值 II</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;二分查找经典应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="eetoa.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="eetoa.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 153.寻找旋转排序数组中的最小值</title>
    <link href="eetoa.github.io/2021/02/26/LeetCode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>eetoa.github.io/2021/02/26/LeetCode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</id>
    <published>2021-02-26T08:38:43.000Z</published>
    <updated>2021-02-26T11:27:44.628Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>二分查找经典题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>请找出其中最小的元素。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> nums = [3,4,5,1,2]<br><strong>输出：</strong> 1</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> nums = [4,5,6,7,0,1,2]<br><strong>输出：</strong> 0</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> nums = [1]<br><strong>输出：</strong> 1</p></blockquote><p><strong>提示：</strong></p><ul><li>$1 &lt;= nums.length &lt;= 5000$</li><li>$-5000 &lt;= nums[i] &lt;= 5000$</li><li><code>nums</code> 中的所有整数都是 唯一 的</li><li><code>nums</code> 原来是一个升序排序的数组，但在预先未知的某个点上进行了旋转</li></ul><hr><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>题目要求找到折叠后的递增数组的第二段递增序列的左端点。<br>可以利用二分的思想，如果 <code>mid</code> 落在左半边，那么左边界最低取到 <code>mid+1</code>；<br>如果 <code>mid</code> 落在右半边，那么右边界最高取到 <code>mid</code>。<br>问题是，如何判断 <code>mid</code> 落在哪一边。</p><p>因为折叠数组是从一个未知点折叠的，所以折叠数组左半边的所有数都大于等于第一个数，右半边都小于等于第一个数。依此可判断 <code>mid</code> 落在哪一边。</p><p>注意这一题有个很坑的地方，测试用例存在折叠数组完全递增的情况，也就是默认折叠点在数组下标范围之外。需要进行特判。</p><p>这一题的二分法找数字，利用目标值左半边和右半边的性质不同来缩小范围。<br>但是和该性质相关的点却是折叠数组的第一个数，而非目标值本身。<br>这一点尤为需要注意。一句话，想找目标值，在考虑性质的时候，不一定从目标值入手。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 8 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 9.7 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[lo];       <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">int</span> cmp = <span class="number">0</span>;                                    <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[cmp]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 38 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">LeetCode 153.寻找旋转排序数组中的最小值</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;二分查找经典题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="eetoa.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="eetoa.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 10-II.青蛙跳台阶问题</title>
    <link href="eetoa.github.io/2021/02/26/%E5%89%91%E6%8C%87Offer-10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <id>eetoa.github.io/2021/02/26/%E5%89%91%E6%8C%87Offer-10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</id>
    <published>2021-02-26T03:34:15.000Z</published>
    <updated>2021-02-26T06:32:14.709Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>动态规划入门题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br>__<br><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> n = 2<br><strong>输出：</strong> 2</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> n = 7<br><strong>输出：</strong> 21</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> n = 0<br><strong>输出：</strong> 1</p></blockquote><p><strong>提示：</strong></p><ul><li>$ 0 &lt;= n &lt;= 100 $</li></ul><hr><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>注意数值溢出，可以每一步计算取模。正确性证明参见：<br><a href="https://accepted.org.cn/2021/02/25/剑指Offer-10-I-斐波那契数列/" target="_blank" rel="noopener">剑指Offer 10-I.斐波那契数列</a><br>还有一点就是注意特判 <code>n == 0</code> 的情况。<br>本题起始位置为0层。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.9 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> _mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int64_t</span> dp[n + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">            dp[i] %= _mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.2 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">110</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">            dp[i] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="空间复杂度优化的动态规划"><a href="#空间复杂度优化的动态规划" class="headerlink" title="空间复杂度优化的动态规划"></a>空间复杂度优化的动态规划</h3><p>可以用三个变量滚动更新，代替数组。<br>核心是一共计算$n - 1$次，每次计算 <code>c</code> 的值，动态更新 <code>a</code> , <code>b</code>。</p><div class="tabs" id="g_tab1-0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-0-1">C++</a></li><li class="tab"><a href="#g_tab1-0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int64_t</span> a, b, c;</span><br><span class="line">        c = b = a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            c %= mod;</span><br><span class="line">            a = b, b = c;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.2 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            c %= mod;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">剑指Offer 10- II. 青蛙跳台阶问题</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;动态规划入门题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="eetoa.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="剑指Offer" scheme="eetoa.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 10-I.斐波那契数列</title>
    <link href="eetoa.github.io/2021/02/25/%E5%89%91%E6%8C%87Offer-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>eetoa.github.io/2021/02/25/%E5%89%91%E6%8C%87Offer-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2021-02-25T14:27:18.000Z</published>
    <updated>2021-02-26T06:30:56.599Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>动态规划入门题。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><blockquote><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p></blockquote><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> n = 2<br><strong>输出：</strong> 1</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> n = 5<br><strong>输出：</strong> 5</p></blockquote><p><strong>提示：</strong></p><ul><li>$ 0 &lt;= n &lt;= 100 $</li></ul><hr><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>考虑数字越界问题，需要在每一步求解时都进行求余运算。<br>循环求余证明：<br>设正整数 $ x, y, p$，求余符号为$⊙$，则有<br>$ (x + y) ⊙ p = (x ⊙ p + y ⊙ p) ⊙ p $<br>那么，在本题中：<br>$ f(n) ⊙ p = [f(n−1) ⊙ p + f(n−2) ⊙ p] ⊙ p $<br>求f(n - 2)时，将其更新为f(n - 2)模以 <code>_mod</code>;<br>求f(n - 1)时，将其更新为f(n - 1)模以 <code>_mod</code>;<br>那么，根据上式，在求f(n)时，将其更新为f(n - 2) + f(n - 1)模以<br><code>_mod</code> 显然正确。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.9 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int64_t</span> _mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int64_t</span> dp[<span class="number">110</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">            dp[i] %= _mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.2 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">110</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">            dp[i] %= _mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">剑指Offer 10- I. 斐波那契数列</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;动态规划入门题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="eetoa.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="剑指Offer" scheme="eetoa.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="矩阵快速幂" scheme="eetoa.github.io/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 09.用两个栈实现队列</title>
    <link href="eetoa.github.io/2021/02/25/%E5%89%91%E6%8C%87Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>eetoa.github.io/2021/02/25/%E5%89%91%E6%8C%87Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2021-02-25T08:55:32.000Z</published>
    <updated>2021-02-25T14:13:12.201Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>用两个栈模拟队列。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong><br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br><strong>输出：</strong> [null,null,3,-1]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong><br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br><strong>输出：</strong> [null,-1,null,null,5,2]</p></blockquote><p><strong>提示：</strong></p><blockquote><ul><li>1 &lt;= values &lt;= 10000</li><li>最多会对 appendTail、deleteHead 进行 10000 次调用</li></ul></blockquote><hr><p>用两个栈模拟队列，一个放的是正序序列，一个是倒序序列。分别用作队列的插入队尾和删除队首操作。</p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 364 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 101.2 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stkTail;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stkHead;</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stkTail.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stkHead.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stkTail.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; !stkTail.empty(); stkTail.pop()) stkHead.push(stkTail.top());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = stkHead.top();</span><br><span class="line">        stkHead.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 53 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 47.3 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; stk1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; stk2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stk2.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stk1.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk2.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; stk2.size() != <span class="number">0</span>; ) stk1.addLast(stk2.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk1.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指Offer 09. 用两个栈实现队列</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;用两个栈模拟队列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="eetoa.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="eetoa.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="剑指Offer" scheme="eetoa.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot和SSM在开发中的区别</title>
    <link href="eetoa.github.io/2021/02/24/Spring-Boot%E5%92%8CSSM%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>eetoa.github.io/2021/02/24/Spring-Boot%E5%92%8CSSM%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-02-24T06:25:11.000Z</published>
    <updated>2021-02-25T00:16:05.770Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>详细阐述Spring Boot和SSM的区别。</p><a id="more"></a><p><strong>写在前面：</strong><br>Spring Boot没有颠覆Java EE开发，但是我的回答会颠覆你对Spring Boot的认知。本篇为转载，出处链接在文章末。</p><h3 id="我们先说说Spring-Boot和SSM本质上的区别"><a href="#我们先说说Spring-Boot和SSM本质上的区别" class="headerlink" title="我们先说说Spring Boot和SSM本质上的区别"></a>我们先说说Spring Boot和SSM本质上的区别</h3><p>SSM是什么？是三个臭皮匠(裨将)，Spring IoC、Spring MVC、Mybatis的组合。SSM限定死了你只能开发Java Web应用，而且MVC框架必须用Spring MVC，持久层必须用Mybatis，无他！我说的是SSM包含这些啊，没说你不能在这三个基础上自己加其他框架和库上去。</p><p>Spring Boot呢？诸葛亮。有了诸葛亮，你用兵的可选方案更多，不管用哪几员将军，出师更顺利。Spring Boot没有和任何MVC框架绑定！没有和任何持久层框架绑定！没有和任何其他业务领域的框架绑定！</p><p>你开发Web应用可以用Spring Boot。用spring-boot-starter-web就帮你配置好了Spring MVC。你不想用Spring MVC了，换成Spring WebFLux(用spring-boot-starter-webflux)写响应式Web应用可以吗？当然可以，而且这个是Spring 5主推的新Web框架。</p><p>你不开发Web应用，只实现纯粹的数据层业务，开发Spring Cloud Stream和Task也可以。</p><p>数据持久层，你可以用Spring Data项目下的任何子项目(JPA\JDBC\MongoDB\Redis\LDAP\Cassandra\Couchbase\Noe4J\Hadoop\Elasticsearch….)，当然用非Spring官方支持的Mybatis也可以。只要用上对应技术或框架的spring-boot-starter-xxx就可以了。</p><p><strong>但是必须要知道，Spring Boot提供的只是这些starters，这些Starter依赖了(maven dependence)对应的框架或技术，但不包含对应的技术或框架本身！</strong></p><p>这就是很多人用“全家桶”这个词来比喻Spring Boot的错误之处。肯德基麦当劳的全家桶里面包含了鸡腿、鸡翅、鸡块，这些东西都是包含在里面的，而且是不可选择的。你吃的完是这些，吃不完也是这些。你喜欢吃其中几样，也可能不喜欢吃其中几样。但是Spring Boot不是啊，Spring Boot没有包含Spring MVC，没有包含Mybatis，只有他们对应的starters。</p><p>一个更恰当的比喻是，Spring MVC、Spring Data、Websocket这东西对应电脑硬件的显卡、声卡、硬盘、网卡。Spring Boot提供的Starters对应这些硬件的驱动。只要你在主板上插上了这些硬件，Spring Boot提供的对应驱动就能让能让你享受到即插即用(Plug &amp; Play)的体验。Spring Boot提供的是驱动，没有包含显卡、声卡这些硬件本身，这些驱动能够让你DIY的电脑顺畅的引导(boot)并运行起来。</p><p>很多Java服务器端的常见第三方框架，Spring Boot都能用Convention over Configuration的方式帮你默认配置好。</p><p>具体支持什么看这里：<br><a href="https://link.zhihu.com/?target=https%3A//docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/%23using-boot-starter">Spring Boot Reference Guide</a></p><p>上面官方文档的列表只给出了Spring Boot官方提供的starters，其他第三方自己提供(例如Mybatis的starter)的没有包含在这个列表里。</p><p>前几天<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 改版了，也可以去看看：</p><p><img src="0x0.jpg" alt="0x0"></p><p>红框里的Dependency是空的，没有限制你必须用哪一个，Web都是可选的。而且你输入Web，会有Spring MVC和Spring WebFlux让你选。</p><p><img src="0x1.jpg" alt="0x1"></p><p>上图下拉列表中，第一个Web就是Spring MVC，第二个Reactive Web就是Spring WebFLux。本文后面我们还会讲到。</p><p>关于<a href="http://start.spring.io，" target="_blank" rel="noopener">http://start.spring.io，</a> 也就是Spring Initializr，看我回答的另外一个问题，非常简单：<br><a href="https://www.zhihu.com/question/49941226/answer/619799264" target="_blank" rel="noopener">spring mvc+hibernate+spring开发框架搭建？</a></p><p>其他答案提到的：配置方便(也就是我上面说的Convention over Configuration)只是表象，其实CoC一直都是Spring贯彻的理念，只是Spring Boot又把它提高到了一个新的高度。</p><p>Spring Boot的最核心理念就体现在名字上，Spring就不说啦，那Boot是啥意思啊？<br>Boot是引导启动的意思，Windows安装启动的过程不就需要引导盘(boot disk或bootable usb)吗？</p><p>类似的，前端有一个Bootstrap，也是这个意思，让你快速搭建前端UI。上面提到的那个Spring Initializr，打开页面，看左上角，写的什么？Spring Initializr <strong>Bootstrap</strong> your application。</p><p><img src="0x2.jpg" alt="0x2"></p><p>如果一家公司一直用SSH/SSM，用了若干年了，经历了大大小小几个项目，基本上配置都已经好了，早就形成了自己的一套默认配置。国内大多数中小公司，新项目的启动就是把上一个项目Copy过来改！还需要用啥Spring Boot？在这种情况下，三个臭皮匠就顶上诸葛亮了！</p><p>但是如果你的新项目需要用到以前没整合过的技术呢？比如数据库要用MongoDB了，也许还用到Redis，可能还需要用Spring Security，估计还要上Kafka消息队列，还可能要用Websockets。你的项目怎么才能平稳、顺利、快速启动？手动配置这些东西可能就要花不少时间，而且还不一定配置的好。</p><p>明白我上面说的那些，很多问题都没必要问了。例如我回答过的这些问题：<br><a href="https://www.zhihu.com/question/303235503/answer/537538561" target="_blank" rel="noopener">可以不学spring其他，直接学spring boot吗？</a><br><a href="https://www.zhihu.com/question/64671972/answer/568318031" target="_blank" rel="noopener">spring boot与spring mvc的区别是什么？</a><br><a href="https://www.zhihu.com/question/314112286/answer/613357345" target="_blank" rel="noopener">熟悉使用Springboot，还有必要学习SpringMVC么？</a></p><p>这个问题下原来赞数最多回答推荐的那本书我没看过，但是之前就知道这本书。我看到副标题–<strong>Java EE开发的颠覆者</strong>，就误导了入门读者，传递了错误观念，仅仅是为了自己的销量。</p><p>这个问题下有人不是比喻Spring Boot和SSM之间是自动挡和手动挡的关系吗？有点像。但我还是更喜欢我在这个回答里的比喻：<br><a href="https://www.zhihu.com/question/49649311/answer/364216794" target="_blank" rel="noopener">哪些企业或项目在用Spring boot,或者它会在多大程度上替代Spring?</a></p><p>从马车到汽车是交通出行的颠覆，从燃油车到纯电动车是能源利用的颠覆，从人工驾驶到AI智是驾驶方式的颠覆。但，只是给传统汽车改成自动挡、加装一键启停、无钥匙进入、自动跟车、车道偏离预警，我觉得不算颠覆。</p><p><strong>这个”颠覆“给人的感觉就是：Spring MVC不用学了，Spring其他都不用学了，Spring Boot颠覆了他们的，取代他们的，包含了他们以前所有的功能。</strong> 然后就误导出了上面那些问题。</p><h3 id="我们再看看这个问题下其他答案"><a href="#我们再看看这个问题下其他答案" class="headerlink" title="我们再看看这个问题下其他答案"></a>我们再看看这个问题下其他答案</h3><p><strong>回答1：两个一样的，只不过是springboot省去了很多配置</strong><br>怎么可能一样呢？如果一样，大部分公司都没必要迁移到Spring Boot。因为上面说了，只要做了几个项目，基本也就把SSM配置的差不多了。每个项目都Copy套用就可以了。</p><p><strong>回答2：Spring Boot 就像一个脚手架一样 能让你快速的搭建项目 他不是替代SSM的 至于返回什么 完全看前端需求和文档规定吧</strong><br>Spring Boot就像一个脚手架，但绝对不是一个脚手架。什么是脚手架？我们都见过，就是建筑工地盖楼房的时候外面那一层钢管搭建的架子，还有一层绿网，就是方便构建楼房。但是楼房竣工以后，脚手架是要被拆掉的，不会作为物业的一部分交给业主。软件开发中的脚手架也是类似的，帮助快速搭建项目，而脚手架不会作为最终交付成果的一部分。你用了Spring Boot，那么Spring Boot以及其他starter的jar都会最终进入你打包编译的jar里，作为你成果的一部分。</p><p>那么Spring体系当中，有没有真正的脚手架呢？有的，就是答案上面截图的<a href="http://start.spring.io，它叫做Spring" target="_blank" rel="noopener">http://start.spring.io，它叫做Spring</a> Initializr Bootstrap your application，<strong>就是通过页面上的操作，很快帮你生成搭建好一个初始化好的Spring Boot应用。但是Spring Initializr自己不会进入你最后打包的jar，Spring Initializr是Spring Boot应用的一个简单脚手架工具。</strong></p><p>怎么又是一个“简单”的脚手架工具了？因为还有Spring Boot Cli啊。Cli是Command Line Interface的缩写，就是命令行工具。Spring Boot Cli通过命令行交互的方式提供了脚手架功能，你可以用它初始化一个Spring Boot项目，也可以用它完成打包jar的工作。</p><blockquote><p>The <code>init</code> command lets you create a new project by using<br><a href="start.spring.io">start.spring.io</a> without leaving the shell<br>–Spring Boot 文档</p></blockquote><p>例如运行spring init：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ spring init --dependencies=web,data-jpa my-project</span><br><span class="line">Using service at https://start.spring.io</span><br><span class="line">Project extracted to <span class="string">'/Users/developer/example/my-project'</span></span><br></pre></td></tr></table></figure><p>就完成了在<a href="http://start.spring.io" target="_blank" rel="noopener">start.spring.io</a>中创建项目的工作。</p><p>Spring Boot不是替代SSM的，这个是对的。因为答案上面解释过了，Spring Boot没有和任何Web MVC绑定，没有和任何数据持久化绑定。Spring Boot自己根本无法完成SSM能完成的工作，需要其他starter作为桥梁，自动帮你配置好对应的框架才行。</p><p><strong>回答3：springboot采用约定大于配置的方式，简化了大量的xml配置，真正做到了开箱即用。减少了web开发的难度</strong><br>Spring Boot是采用约定大于配置(就是Convention over Configuration)，简化了大量的XML配置。难道在Spring Boot出来以前Spring Framework或者其他Spring体系下的框架就没有采用CoC吗？就没有提倡用Java Annotation来简化配置吗？ CoC一直就是Spring所倡导的，只是Spring Boot更进一步发扬光大了！</p><p>真正做到开箱即用？没有吧，那还需要Spring Initializr干嘛？或者还需要手动配置POM干嘛？还是要做一定定制化的。如果论开箱即用(Out of Box)，我答案里说的传统公司的流程才是开箱即用。新项目Copy老项目就算开箱了，直接上去改就算开始用了。</p><p><strong>回答4：SSM：面相XML编程。SpringBoot：面相注解编程</strong><br>Spring Boot出现以前，Spring Framework已经在推荐Java Annotation的配置方式了，在所有的文档里都会同时介绍注解和XML两种配置方式，并且优先介绍注解的方式。</p><p><strong>回答5：ssm是自己买家具装修。spring boot是全屋定制</strong><br>SSM不是自己买家具，而是住酒店，酒店房间里的东西就这些，没得换。你只能自己带一些小件日用品。SSM这家酒店你不喜欢，那就换SSH那家去。Spring Boot是全屋定制，这个形容不错。而且家具种类齐全，品种多样。你只要下单就可以，包送货、包安装调试。</p><p><strong>回答6：没有区别，springboot 只是提供了一套默认配置，用于原型的快速开发。</strong><br>怎么可能没区别，就不多说了。用于原型快速开发这句话存在严重片面理解。快速开发没问题，但绝对不是只限于开发原型。</p><p>Spring Boot文档开章明义就讲了：</p><blockquote><p>Spring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run.</p></blockquote><p>怎么是Production-grade(产品级)呢？</p><p>Spring Boot文档第V章，专门讲了这些，指的是Actuator，用来监控和控制Spring Boot应用。包括Loggers，Metrics，Auditing，HTTP Tracing，Process Monitoring等等产品环境下需要的一套机制。</p><p><strong>回答7：区别就是配置方式不一样，对于实现业务逻辑来说没有任何区别。</strong><br>区别不仅仅是配置方式不一样，实现业务逻辑更是大有不同！用SSM开发应用，大多数公司的技术栈还在使用JSP，很少采用前后端分离的。而Spring Boot倡导前后端分离的开发，Spring Boot的应用只向前端提供RESTful API。下面一节会重点说这个。</p><p>不再逐一分析了。为什么要批判这些回答？因为这些回答代表的观念不仅仅出现在这个问题下的回答里，其他Spring Boot相关的问题下面都能见到这些观点层出不穷。</p><h3 id="我们再说说题主在问题描述中表达的困惑"><a href="#我们再说说题主在问题描述中表达的困惑" class="headerlink" title="我们再说说题主在问题描述中表达的困惑"></a>我们再说说题主在问题描述中表达的困惑</h3><blockquote><p>原来使用ssm开发，后来公司用springboot，虽然一直在用但除了springboot简化构建项目以外，还有个别的几个不一样的注解，<strong>其他的都感觉差不多</strong>，有人看到一个框架说:<strong>他虽然使用spring boot构建了项目，但是里面开发还是用的ssm</strong>，因为他使用了ModelAndView，那么问题来了，那spring boot中又是返回什么呢？</p></blockquote><p>问题描述中的这段话充分体现了软件开发上的一些根本性的问题。</p><p>软件开发，首先是思想行为，其次才是编码。想明白想通了，处处顺风顺水。想不通，觉得别扭，开发也束手束脚。</p><p>当了解学习一个新技术新框架新工具的时候，首先要了解其思想。它新在哪里？它提倡了什么理念？它想引导开发者向哪里发展？难道以前的同类技术不行了吗？</p><p>这个问题是关于Spring的，也就是关于Java 服务器端技术的，那咱们就举个Java的例子。大家学Java，都知道一本书叫《Thinking In Java》吧？中文叫《Java编程思想》好像是。</p><p>Java新手，特别是以前熟悉过程语言的人，首先要理解面向对象的思想，才能用好面向对象的语言。否则你就是用面向过程的语言写着面向过程的程序。你用来用去，就会问自己，和我以前用的那个语言到底有啥区别呢？</p><p>不仅仅是编程语言和框架，学习说话语言也是一样。任何人学外语都不会像用自己母语那么自然，关键就是没有用对方语言的思维去组织语言！背再多单词，记再多语法，没有转变到那门语言的思维方式上，就很难说出地道的外语。</p><p>生活中也是一样的。这个问题下有用手动挡车和自动挡车来类比Spring Boot和SSM。假如一个人以前开了十几年手动挡汽车，然后换了一部手自一体的，他一开始也不习惯。用自动挡模式驾驶，他的手也会不自觉的去摸档把。最后他把车切换成手动模式才觉得稍微习惯一点。</p><p>在日常开发中，经常会见到一种人，他们学习新框架总是要把自己对以前旧框架的认识和经验往上套。<strong>套不上就会骂这个东西真难用，套上了就会问到底有啥区别为什么要折腾，这就是底层程序员的通病。</strong></p><p>那么Spring Boot和SSM相比，除了之前说过的那些区别，在Web开发上引入了什么新思想？打算把开发者引导到什么方向上去呢？其中重要的一点就是：<strong>抛弃服务器端模板，用REST API和前端配合，做到前后端分离的开发。</strong></p><p>看我回答过的两个问题：<br><a href="https://www.zhihu.com/question/306193181/answer/556626638" target="_blank" rel="noopener">Java Web 开发使用 jsp 页面是否已经落后了？是的话现在流行用什么？</a><br><a href="https://www.zhihu.com/question/309604430/answer/579400528" target="_blank" rel="noopener">spring cloud怎么传递参数到同个项目的jsp？</a></p><p>别人的问题和文章：<br><a href="https://www.zhihu.com/question/61385975" target="_blank" rel="noopener">为什么spring boot不能很好的支持jsp？</a><br><a href="https://zhuanlan.zhihu.com/p/33155755" target="_blank" rel="noopener">启蛰：12.Spring Boot之开启JSP支持</a></p><p>总之，Spring Boot开发JSP有一些限制！如果要开发JSP，还要做额外的配置，这不就和Spring Boot减少配置让项目快速启动开发的理念背道而离了吗？不仅仅是限制JSP，而是现在前后端分离的开发就是大势所趋。因为前端越来越专业越来越复杂了，从语言到框架到开发工具已经完全和服务器端不同了，服务器端包含JSP在内的模板语言越来越没有用了。</p><p>上面并没有说明确。如果对Spring Framework有最新了解的话，就会知道所谓的“Spring Boot对JSP有一些限制”指的是Spring Boot 结合 Spring MVC的情况下，也就是用spring-boot-starter-web这个Starter的时候。</p><p>Spring Boot开发Web应用难道可以不用Spring MVC，还能用其他框架？当然啊，我在回答的第一部分，讲Spring Boot和SSM本质区别的时候就提到了。我们还可以让Spring Boot用spring-boot-starter-webflux这个Starter，用上Spring 5最新提供的Spring WebFlux！关于WebFlux，可以看我另外一个回答：<br><a href="https://www.zhihu.com/question/294282002/answer/521229241" target="_blank" rel="noopener">Spring MVC 过时了吗？</a></p><p>我们再次看一下Spring官网<a href="http://spring.io" target="_blank" rel="noopener">spring.io</a>的一副大图(我上面这个回答也用了这幅图)：</p><p><img src="0x3.jpg" alt="0x3"></p><p>右侧是传统的Spring MVC，是基于Servlet API的，也就是说至少还支持JSP，只是有一些限制。而左侧是Spring 5最新推出的Spring WebFlux，完全不支持JSP！</p><p>看一下Spring Boot文档里分别是怎么说的：</p><p>Spring Boot结合Spring MVC部分：<br><img src="0x4.jpg" alt="0x4"><br>正式支持的列表里没有JSP，至少提了一下JSP有限制。</p><blockquote><p>If possible, JSPs should be avoided.<br>如果可能的话，最好别用JSP。</p></blockquote><p>Spring Boot结合Spring WebFlux部分：<br><img src="0x5.jpg" alt="0x5"><br>根本不支持JSP</p><p>压根没提到JSP。</p><h3 id="再多谈一些"><a href="#再多谈一些" class="headerlink" title="再多谈一些"></a>再多谈一些</h3><p>我们再看看Spring官网<a href="http://Spring.io" target="_blank" rel="noopener">Spring.io</a>首页最大最醒目的一幅图。<br><img src="0x6.jpg" alt="0x6"></p><p><strong>Your App</strong><br>你的App？难道不是用Spring Boot开发的吗？对。指的是Desktop App、Web App、Mobile App，当然Mobile App也可能是Hybrid或H5开发的。灰色的Your App不是Spring Boot开发的，右侧绿色那三个块块才是。</p><p>总之他们都是独立运行在客户端的，他们不是用Spring Boot开发出来的！他们都会向服务器端Spring Boot发送API请求。其中Web App就是我们现在用前端框架写的SPA(Single Page Application)，不是JSP，也不是其他任何服务器端模板语言(FreeMarker、Thymeleaf)！ JSP是服务器端生成HTML，不是客户端技术，而是Java Server Page，是 <strong>Page</strong> ，写不出 <strong>APP</strong>。</p><p><strong>第一个方块</strong><br>Spring Boot，Build Anything。为啥是Build Anything？按照绝大多数人的理解，Build Web不就完了吗？就好像我现在正在回答的这个问题大多数其他答主片面肤浅理解的那样，Spring Boot和SSM好像没啥区别啊，都是开发Java Web的，只是配置更方便。</p><p>Anything，在我回答的第一部分就已经解释过了。Spring Boot没有必须用Spring MVC，可以不用，也可以换成Spring WebFlux。也可以结合其他专用框架开发应用，都不一定要用Web。</p><p><strong>第二个方块</strong><br>Spring Cloud，就是基于Spring Boot的。<br>我们看Spring官网<a href="http://spring.io" target="_blank" rel="noopener">spring.io</a>首页的另一副大图：</p><p><img src="0x7.jpg" alt="0x7"></p><p>注意最左侧灰色的IoT、Mobile、Browser，同样是之前我们引用的三个方块图里最左侧的“Your App”，右侧绿色的才是Spring Cloud架构里的组成部分。IoT是Internet of Things，物联网。</p><p>Spring Cloud架构里面包含的的Service Registry、Service Configuration Center、API Gateway、每一个MicroService，都是基于Spring Boot的应用。</p><p>特别是每一个MicroService，不会再用模板引擎，当然也不会用JSP。因为所有前端的API请求都发给API Gateway，Gateway再转发给某个微服务。</p><p>我们看看Spring Cloud文档里怎么说的：</p><blockquote><p>Many of those features are covered by <a href="https://link.zhihu.com/?target=https%3A//projects.spring.io/spring-boot">Spring Boot</a>, on which Spring Cloud builds.Spring Boot has an opinionated view of how to build an application with Spring. For instance, it has conventional locations for common configuration files and has endpoints for common management and monitoring tasks. Spring Cloud builds on top of that and adds a few features that probably all components in a system would use or occasionally need.</p></blockquote><p>比如我们写一个Spring Cloud Config Server：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们写一个Spring Cloud Eureka Service Registry:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们写一个Spring Cloud Zuul Proxy(Gateway):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(GatewayApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们写一个微服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHelloApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(SayHelloApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/greeting"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Access /greeting"</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; greetings = Arrays.asList(<span class="string">"Hi there"</span>, <span class="string">"Greetings"</span>, <span class="string">"Salutations"</span>);</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> randomNum = rand.nextInt(greetings.size());</span><br><span class="line">    <span class="keyword">return</span> greetings.get(randomNum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Access /"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(SayHelloApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些都要用到 <strong>@SpringBootApplication</strong></p><p>如果MicroService也包含JSP，就产生了这个问题：<br><a href="https://www.zhihu.com/question/309604430/answer/579400528" target="_blank" rel="noopener">spring cloud怎么传递参数到同个项目的jsp？</a></p><p>这个问题的提出，就是我上文说过的：在日常开发中，经常会见到一种人，他们学习新框架总是要把自己对以前旧框架的认识和经验往上套。套不上就会骂这个东西真难用，<strong>套上了就会问到底有啥区别为什么要折腾，这就是底层程序员的通病。</strong></p><p><strong>第三个方块</strong><br>Spring Cloud DataFlow。我们可以写Stream和Task，做数据的抽取、分析、转换等等，他们同样是Spring Boot的应用！这也是Anything包含的，而SSM没这些！</p><p>比如我们写一个Task:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTask</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(MyTask<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是一个 <strong>@SpringBootApplication</strong></p><h3 id="谈一些更深入的问题"><a href="#谈一些更深入的问题" class="headerlink" title="谈一些更深入的问题"></a>谈一些更深入的问题</h3><p>这个问题，我之所以花了将近两天时间去写答案，然后不断补充和修订，不仅仅是因为问题本身。而是这个问题以及问题下的答案充分反映了国内程序员的一些通病，一些根源性的问题。</p><p>这些问题及我的观点，也是我从去年开始在知乎回答问题到现在，一年时间里不断纠正、提倡、引导的。</p><h3 id="思想要跟上变化"><a href="#思想要跟上变化" class="headerlink" title="思想要跟上变化"></a>思想要跟上变化</h3><p><strong>软件开发，首先是思想活动，其次才是敲代码。</strong> 这句话不知道在我的知乎回答里出现了多少遍了，上面的回答内容中也有所体现。</p><p>做软件开发不可避免的遇到新语言、新技术、新框架、新工具的出现。当遇到新东西的时候，必须要问自己：为什么会出现这个东西，以前我开发的好好地，为啥冒出这么个东西来。</p><p>我以前用Struts，现在出来个Spring MVC，Spring这帮人是傻吗？<br>我现在用Java，Java太强大了，怎么又出来个Kotlin，JetBrains这帮人是活腻了吗？他们想取代Java？<br>我一直在用JSP，怎么最近几年前端那么火爆？不就是写个页面吗？jQuery不是很好用？那些React、VUE出来干嘛？<br>我以前用SSM，现在出来个Spring Boot，怎么又搞一个新”框架”啊？这个“框架”感觉就是比SSM配置起来方便点，怎么就这么火呢，做Java服务器端的无人不吹Spring Boot？</p><p>整个IT产业到目前还属于朝阳产业。软件开发和编程到现在还处于起步阶段，尤其是国内的程序员都是软件开发行业的第一代人，几乎没有自己的父母就是程序员的。软件开发技术就像婴儿，每天一个变化，千万不要用一成不变的眼光看待它。</p><p>所以，新产业就会有新需求，就会有新思想不断涌现去满足那些新需求。当原有技术无法支撑新的思想，就必定涌现出新的东西。</p><p>如果有人觉得Struts1还能满足需要，只是需要稍加优化，那就出现Struts2。有另外一拨人觉得Struts根本不能支撑自己的新想法，那就出现Spring MVC了，现在又出现Spring WebFlux了。</p><p>如果有人觉得jQuery能够满足自己的需要，那就继续维护增加新功能进去。有人觉得满足不了需求，那就Angularjs、Backbone、Ember出来了，后来又有人觉得这些框架无法支撑自己的想法了，搞出第二代前端框架Angular、React、Vue。</p><p>所以，学习新技术，千万不要用自己以前建立起来的老经验往上生拉硬套！要分清楚哪部分是传承，哪部分是创新。套不上就骂这个框架难用，套上了就问和以前有什么区别。</p><p>以前用SSM，只知道框架。有了Spring Boot就认为它必然就是个新框架而已。然后得出结论：和SSM一样，就是配置简单点。SSM能写的它都能写。殊不知，Spring Boot可能是Java服务器端从来没有出现过的概念，它代表了新理念，不能用任何已经固化的概念去套。</p><p>宝宝长出牙，父母就无所适从了，这是又长出一层嘴唇？还是舌头变硬了？反正必须用以前见过的东西网上套。有这样的父母吗？如果没有，那就别用这样的方式去看待软件开发。</p><h3 id="为什么不去读文档"><a href="#为什么不去读文档" class="headerlink" title="为什么不去读文档"></a>为什么不去读文档</h3><p>这个问题的回答，我引用了多少Spring的文档？而且<a href="http://Spring.io" target="_blank" rel="noopener">Spring.io</a> 首页的三幅图就说明了很多问题。可惜的是，我见到的大多数开发人员没有阅读过官网文档。从来没有访问过<a href="http://spring.io" target="_blank" rel="noopener">Spring.io</a> 首页的都大有人在，更别提去认真读一遍Spring Boot/Sprint Framework/Spring Cloud/Spring Data这些具体项目的文档。</p><p>面试过太多人。</p><p>问他们：你们用到Spring了吗？<br>回答：用到了。<br>问：Spring什么版本？<br>回答：不知到。<br>问：看过Spring的文档吗?<br>回答：看过。<br>问：Spring官网地址是什么?<br>回答：不知道。<br>问：那你在哪里看的文档？<br>回答：CSDN、论坛、视频…</p><p>但是这个面试者的简历里很可能写着：精通Spring源代码…</p><p>曾经在知乎里回答过一个问题：<br><a href="https://www.zhihu.com/question/21346206/answer/349792663" target="_blank" rel="noopener">怎么阅读Spring源码？</a></p><p>我和其他所有该问题下的回答都不同，我不支持初学者一头扎入源代码，具体观点可以去这个回答里看。</p><p>就拿我们当前的这个问题来说。你要看多少Spring的源代码才能了解我在回答里里阐述的这些事实，才能对Spring Boot从宏观上有一个全面、清晰的理解？</p><p>知乎里有很多类似这样的问题：程序员如何避免走弯路？</p><p>我觉得对于国内很多程序员来说，最大的弯路、冤枉路就是迷信源代码，跳过熟读文档这一步而一头扎进源代码。</p><p>我个人认为的任何成熟软件技术的最佳入门路径都是：</p><ol><li>先看官方文档。好的技术和框架，官方文档一定全面丰富详实，<a href="http://Spring.io" target="_blank" rel="noopener">Spring.io</a> 就是好文档的典范。所以先把官方文档过一遍，理解的就理解，不理解的要记住在文档的哪一节。</li><li>开始实践。有些知识只有实践的过程中才能理解，并且加深认识。遇到问题，知道这个问题对应文档的哪一部分，然后去查文档。</li><li>做完一两个实际项目之后，返回去再读一遍文档，这时你会发现自己站在一个新高度上。</li><li>1/2/3部分循环…</li></ol><p>越成熟越优秀的开源框架，文档就越丰富越详实。Java这边的Spring 就是最典型的例子，前端的Angular、React都是例子。</p><p>如果一个框架文档不齐全，不丰富，说明这个框架本身也不成熟，这个框架的开发团队主要精力还放在功能上，而没有更多地投入到文档上。</p><h3 id="别丢掉英语"><a href="#别丢掉英语" class="headerlink" title="别丢掉英语"></a>别丢掉英语</h3><p>英语是工具，是你程序员职业生涯上的一对翅膀。大部分一手资料都是英文的。如何慢慢习惯英文阅读，看我曾经回答过一个问题：<br><a href="https://www.zhihu.com/question/288329542/answer/526126787" target="_blank" rel="noopener">软件开发圈的人，一开始是怎么学会使用纯英文描述的 API和各种软件（比如Tomcat）的使用方法的？</a></p><p>看到原来最高赞答案推荐了《Java EE开发的颠覆者：Spring Boot 实战》，我去京东上搜了一下，发现两个问题。</p><p>发现Spring Boot最早的中文(原创或翻译)书都是从16年开始陆续上市的。而我14年就开始用Spring Boot，15年初开始用JHipster 2.0了。</p><p>我没有看过那些书，所以对书的内容不做评价。但是发现另一个问题，就是这些书都叫Spring Boot实战、Spring Boot揭秘、深入浅出Spring Boot，中文编程的书好像就想不起什么好名字了。尤其是这个”揭秘“。我只在小时候看UFO、玛雅文明、亚特兰蒂斯、克格勃这些书才能看到这个词。Spring Boot有什么秘密可言吗？代码都是开源的！文档随便读！</p><p>Spring团队生怕大家不会用，生怕大家不理解，编写了完备的文档，给出了丰富的例子。结果两年后中文书好像还能挖出Spring官方自己都不知道的什么秘密，并且能写厚厚一本。</p><p>官方团队在这里给出了八十多个例子：<br><a href="https://link.zhihu.com/?target=https%3A//github.com/spring-projects/spring-boot/tree/master/spring-boot-samples">spring-projects/spring-boot</a></p><p>长图预警八十多个例子：</p><p><img src="0x8.jpg" alt="0x8"></p><p>这些例子涵盖了Spring Boot的方方面面，各种用法各种特性应有尽有。网上第三方的例子还有很多很多。</p><p>可悲的是，国内Java服务器端开发人员对如此丰富免费的文档和例子视而不见，却要多等两年，还要花几十几百块钱去买xxx揭秘xxx实战。</p><h3 id="更多内容推荐"><a href="#更多内容推荐" class="headerlink" title="更多内容推荐"></a>更多内容推荐</h3><p>最后推荐我专栏里的两篇文章：<br><a href="https://zhuanlan.zhihu.com/p/55173112" target="_blank" rel="noopener">陈龙：跟着官方文档学Spring Boot (0) Overview</a><br><a href="https://zhuanlan.zhihu.com/p/55249159" target="_blank" rel="noopener">陈龙：跟着官方文档学Spring Boot (2) Getting Started</a></p><p>这个系列文章的后续章节会持续更新。</p><p>哦，对了，学习Spring Boot并且想充分把握和发扬Spring Boot的优势，可以学一下JHipster。JHipster本身以及它包含的所有最佳实践(Best Practice)，都是我们使用Spring Boot时候应该学习和应用的。</p><p>如果说Spring Boot能够让你的快速搭建Java服务器端应用，那么JHipster则把这种理念发展到了全栈。服务器端继续使用Spring Boot，前端使用Angular/React/VUE，让你快速搭建一个全栈应用！</p><p>所以，又要介绍我的另一个专栏了：<br><a href="https://zhuanlan.zhihu.com/c_1008296180270391296" target="_blank" rel="noopener">JHipster</a></p><div class="note primary">            <p><strong>转载链接：</strong> <a href="https://www.zhihu.com/question/284488830/answer/618290880" target="_blank" rel="noopener">spring boot和SSM开发中有什么区别？ - 陈龙的回答 - 知乎</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;详细阐述Spring Boot和SSM的区别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="Project" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/Project/"/>
    
    
      <category term="Spring" scheme="eetoa.github.io/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="eetoa.github.io/tags/Spring-Boot/"/>
    
      <category term="SSM" scheme="eetoa.github.io/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 07.重建二叉树</title>
    <link href="eetoa.github.io/2021/02/23/%E5%89%91%E6%8C%87Offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>eetoa.github.io/2021/02/23/%E5%89%91%E6%8C%87Offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-02-23T09:47:55.000Z</published>
    <updated>2021-02-25T02:45:03.580Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>根据二叉树的前序遍历结果和中序遍历结果重建二叉树。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><blockquote><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p></blockquote><p>返回如下的二叉树：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>限制：</strong><br>$ 0 &lt;= 节点个数 &lt;= 5000 $</p><p><strong>树的定义：</strong></p><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></div></div><hr><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>构建二叉树的一般作法是：先构建根节点，再递归构建根节点的左右孩子节点。<br>前序遍历数组的第一个数一定是二叉树的根节点值，从第二个数开始到第$n$个数结束，为结点数为$n$的左子树的所有节点值；从第$n+1$个数开始，到第$n+m$个数结束，为结点数为$m$的右子树所有节点值。<br>中序遍历数组的第$0$个数开始，到第$n-1$个数结束，为结点数为$n$的左子树的所有节点值；第$n$个数为整个二叉树的根节点值；从第$n+1$个数开始，到$n+m$个数结束，为结点数为$m$的右子树所有节点值。<br>根据前序遍历数组，我们必然得知根节点值，由于二叉树的每个节点值不同，可以根据根节点值在中序数组中找到其位置，将中序数组一分为二。那么左半边全是左子树节点值，右半边为右子树节点值。根据这一信息计算出左右子树长度。<br>回到前序数组中，可以注意到第一个节点值为根节点，第二个结点为左子树根节点。我们发现左子树的根节点永远在根节点右边偏移一位的位置。同时可以根据根节点加上左子树长度的偏移找到右子树根节点。<br>至此，我们完成了一个：构建根节点，构建根节点左孩子节点，构建根节点右孩子节点的过程。<br>此后，可以递归地完成整个二叉树的构建。<br>在构建过程中，可以维护两个指针 <code>l</code> <code>r</code> 分别在两个遍历序列中指向树的节点范围起始边界和结束边界。在递归构建过程中，分别缩小这两个指针指向的范围以达到构建子树的目的。</p><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li><li class="tab"><a href="#g_tab1-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 20 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 24.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        len = inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            hash[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(preorder, inorder, <span class="number">0</span>, len - <span class="number">1</span>, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> lp, <span class="keyword">int</span> rp, <span class="keyword">int</span> li, <span class="keyword">int</span> ri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lp &gt; rp) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// build root</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[lp]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> inIndexRoot = hash[preorder[lp]];</span><br><span class="line">        <span class="comment">// length of left/right sub-tree</span></span><br><span class="line">        <span class="keyword">int</span> llen = inIndexRoot - li;</span><br><span class="line">        <span class="keyword">int</span> rlen = ri - inIndexRoot;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build left/right sub-tree</span></span><br><span class="line">        root-&gt;left = helper(preorder, inorder, lp + <span class="number">1</span>, lp + <span class="number">1</span> + llen - <span class="number">1</span>, li, inIndexRoot - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = helper(preorder, inorder, lp + llen + <span class="number">1</span>, lp + llen + <span class="number">1</span> + rlen - <span class="number">1</span>, inIndexRoot + <span class="number">1</span>, ri); </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 2 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 38.6 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        len = preorder.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            hash.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, inorder, <span class="number">0</span>, len - <span class="number">1</span>, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> lp, <span class="keyword">int</span> rp, <span class="keyword">int</span> lin, <span class="keyword">int</span> rin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lp &gt; rp) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[lp];</span><br><span class="line">        <span class="keyword">int</span> rootIndexIn = hash.get(rootVal);</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> llen = rootIndexIn - lin;</span><br><span class="line">        <span class="keyword">int</span> rlen = rin - rootIndexIn;</span><br><span class="line"></span><br><span class="line">        root.left = helper(preorder, inorder, lp + <span class="number">1</span>, lp + <span class="number">1</span> + llen - <span class="number">1</span>, lin, rootIndexIn - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(preorder, inorder, lp + <span class="number">1</span> + llen, rp, rootIndexIn + <span class="number">1</span>, rin);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href=""></a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;根据二叉树的前序遍历结果和中序遍历结果重建二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针" scheme="eetoa.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="DFS" scheme="eetoa.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="eetoa.github.io/tags/BFS/"/>
    
      <category term="二叉树" scheme="eetoa.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="eetoa.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="迭代" scheme="eetoa.github.io/tags/%E8%BF%AD%E4%BB%A3/"/>
    
      <category term="树" scheme="eetoa.github.io/tags/%E6%A0%91/"/>
    
      <category term="剑指Offer" scheme="eetoa.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 06.从尾到头打印链表</title>
    <link href="eetoa.github.io/2021/02/23/%E5%89%91%E6%8C%87Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>eetoa.github.io/2021/02/23/%E5%89%91%E6%8C%87Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2021-02-23T08:23:53.000Z</published>
    <updated>2021-02-23T09:46:39.227Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong><br>考察链表遍历。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> head = [1,3,2]<br><strong>输出：</strong> [2,3,1]</p></blockquote><p><strong>限制：</strong></p><p>$ 0 &lt;= 链表长度 &lt;= 10000 $</p><p><strong>链表定义：</strong></p><div class="tabs" id="g_tab0-0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-0-1">C++</a></li><li class="tab"><a href="#g_tab0-0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></div></div><hr><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归遍历链表，“归（回溯）”的时候输出节点值。</p><div class="tabs" id="g_tab1-0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-0-1">C++</a></li><li class="tab"><a href="#g_tab1-0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 8 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 9 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        dfs(head);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span>;</span><br><span class="line">        dfs(head-&gt;next);</span><br><span class="line">        res.push_back(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 39.4 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(head);</span><br><span class="line"></span><br><span class="line">        len = list.size();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(head.next);</span><br><span class="line">        list.add(head.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>利用栈的特性。注意Java语言中的栈结构一般用LinkedList.<br><code>LinkedList&lt;Integer&gt; stk = new LinkedList&lt;&gt;();</code><br>涉及到的方法有：<br><code>addLast()</code>对应push, <code>removeLast()</code>对应pop, <code>size()</code>.</p><div class="tabs" id="g_tab2-0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab2-0-1">C++</a></li><li class="tab"><a href="#g_tab2-0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab2-0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 4 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 8.7 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (; head; head = head-&gt;next) &#123;</span><br><span class="line">            stk.push(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; !stk.empty(); stk.pop()) &#123;</span><br><span class="line">            res.push_back(stk.top());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab2-0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 39.3 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; stk = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; head != <span class="keyword">null</span>; head = head.next) &#123;</span><br><span class="line">            stk.addLast(head.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = stk.size();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res[i] = stk.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><h3 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h3><p>当你忘了STL或者java的sdk api中的栈怎么用的时候，就模拟栈吧。</p><div class="tabs" id="g_tab3-0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab3-0-1">C++</a></li><li class="tab"><a href="#g_tab3-0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab3-0-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 8 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 8.5 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> stk[<span class="number">10010</span>], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; head; head = head-&gt;next) &#123;</span><br><span class="line">            stk[++tt] = head-&gt;val;      <span class="comment">// push</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; tt;) &#123;</span><br><span class="line">            res.push_back(stk[tt--]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab3-0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 38.4 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] stk = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10010</span>];</span><br><span class="line">        <span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; head != <span class="keyword">null</span>; head = head.next) &#123;</span><br><span class="line">            stk[++tt] = head.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[tt];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; tt &gt; <span class="number">0</span>; i++, tt--) &#123;</span><br><span class="line">            res[i] = stk[tt];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><div class="note primary">            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">剑指Offer 06. 从尾到头打印链表</a></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;br&gt;考察链表遍历。&lt;/p&gt;
    
    </summary>
    
    
      <category term="指尖飞舞" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/"/>
    
      <category term="算法" scheme="eetoa.github.io/categories/%E6%8C%87%E5%B0%96%E9%A3%9E%E8%88%9E/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="eetoa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="eetoa.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="栈" scheme="eetoa.github.io/tags/%E6%A0%88/"/>
    
      <category term="剑指Offer" scheme="eetoa.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
</feed>
