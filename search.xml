<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Test</title>
    <url>/2020/03/12/Test-0/</url>
    <content><![CDATA[<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><h2 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h2><h3 id="emmm-this-is-a-test-too"><a href="#emmm-this-is-a-test-too" class="headerlink" title="emmm this is a test , too."></a>emmm this is a test , too.</h3>]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/03/12/test/</url>
    <content><![CDATA[<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><h2 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h2><h3 id="this-is-a-test"><a href="#this-is-a-test" class="headerlink" title="this is a test."></a>this is a test.</h3>]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1. 两数之和</title>
    <url>/2020/03/19/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code> ，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。而且，你不能重复利用这个数组中同样的元素。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p>
</blockquote>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>key: <code>target - nums[v]</code><br>value: <code>v</code><br>每次迭代，判断 <code>nums[v]</code> 在不在hashmap中。<br>如果在，则 <code>nums[v]</code> 一定是之前 <code>target - nums[index_before]</code> 的值。此时返回 <code>{index_before, v}</code> ；<br>如果不在，则把key: <code>target - nums[v]</code> 和value: <code>v</code> 放到hashmap中。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; heap;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (heap.count(nums[i])) <span class="keyword">return</span> &#123;heap[nums[i]], i&#125;;</span><br><span class="line">            heap[w] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *Java HashMap method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; nums.length; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashMap.get(nums[v]) != <span class="keyword">null</span>) &#123; <span class="comment">//found value what is index v</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashMap.get(nums[v]), v&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(target - nums[v], v); <span class="comment">//found nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">LeetCode 1. 两数之和</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈java的static关键字</title>
    <url>/2020/03/14/%E6%B5%85%E8%B0%88java%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><h3 id="Why-we-have-to-use-a-static-key-word"><a href="#Why-we-have-to-use-a-static-key-word" class="headerlink" title="Why we have to use a static key word?"></a>Why we have to use a <code>static</code> key word?</h3><p>一般来说，要想引用类成员变量、使用类方法或者分配存储空间，需要创建一个对象。<br>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用类变量，注意到st1.i和st2.i指向同一存储空间，具有相同值47</span></span><br><span class="line">Class StaticTest &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line">StaticTest st1 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">StaticTest st2 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">st1.i</span><br><span class="line">st2.i</span><br><span class="line"><span class="comment">//使用类方法</span></span><br><span class="line">Class Incrementable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;StaticTest.i++; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Incrementable sf = <span class="keyword">new</span> INcrementable();</span><br><span class="line">sf.increment;</span><br></pre></td></tr></table></figure>
<p>那么，如果我们遇到特殊需求。比如我们希望为特定域（field）分配单一存储空间，而不去考虑究竟需要创建多少对象，甚至不用创建对象；再比如我们希望某个方法不与包含它的类的对象相关联，就是说，可以不用创建对象而使用方法。</p>
<p>此时，我们可以使用<code>static</code>关键字。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><h3 id="How-do-we-use-static"><a href="#How-do-we-use-static" class="headerlink" title="How do we use static"></a>How do we use <code>static</code></h3><p>当声明一个事物是static时，就意味着这个域或方法不会与包含它的类的任何对象实例关联在一起。</p>
<p>回顾上述两个类，我们可以声明类变量<code>i</code>和类方法<code>increment()</code>是<code>static</code>，再直接使用类名引用它们:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class StaticTest &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不必创建对象而使用i</span></span><br><span class="line">StaticTest.i++</span><br><span class="line"><span class="comment">//不必创建对象而使用方法</span></span><br><span class="line">Class Incrementable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;StaticTest.i++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Incrementable <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//另一个广为人知的例子  wow, that was epic.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// write your code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><blockquote>
<ul>
<li>类中<code>static</code>方法不能访问非<code>static</code>变量。</li>
<li>类中<code>static</code>方法不能使用<code>this</code>关键字。<br>原因就是<code>Static</code>方法是类方法，先于任何的实例（对象）存在。即<code>Static</code>方法在类加载时就已经存在了，但是对象是在创建时才在内存中生成。</li>
</ul>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<ul>
<li>声明为<code>static</code>的事物也可以用前文所述常规方法引用。</li>
<li>通过类名直接引用是引用<code>static</code>事物的首选方式，这不仅是因为它强调了事物的<code>static</code>结构，而且在某些情况下它还为编译器进行优化提供了更好的机会。</li>
</ul>
</blockquote>
<p><em>总结自《Thinking in Java 4th edition》P29 - P30</em></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title>Trump address sparks chaos as coronavirus crisis deepens[CNN]</title>
    <url>/2020/03/12/Trump-address-sparks-chaos-as-coronavirus-crisis-deepens%5BCNN%5D/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>CNN news</p>
<a id="more"></a>
<hr>
<p>(CNN)President Donald Trump set out to steady a rattled nation and a diving economy in a solemn Oval Office address, but instead sowed more confusion and doubts that he is up to handling the fast-worsening coronavirus crisis.</p>
<ul>
<li>set out to着手；steady稳定；rattled nation摇摇欲坠的；solemn庄严的；sowed引起了；fast-worsening快速恶化的</li>
</ul>
<p>Trump spoke to the nation at a fearful moment, when the rhythms of everyday American life are starting to shut down – with schools closing, the NBA suspended, hospitals on high alert and movie icon Tom Hanks saying he and his wife have the disease.</p>
<ul>
<li>rhythms节奏</li>
</ul>
<p>“The virus will not have a chance against us. No nation is more prepared or more resilient than the United States,” the President said, before painting a rosy picture of an economy that is already taking a beating from the virus fallout. </p>
<ul>
<li>resilient弹性的；before painting a rosy picture of an economy在描绘经济乐观的面纱之前；beating打击；fallout辐射，影响</li>
</ul>
<p>The New York Stock Exchange halted trading for 15 minutes after the S&amp;P 500 fell 7% on Thursday morning.</p>
<ul>
<li>stock证券，股票；halt停止</li>
</ul>
<p>The President unveiled several measures to help on that score, to help workers who lack sick pay but have to self-isolate and are hard-hit by shutdowns, though his call for a payroll tax cut is not popular in Congress.</p>
<ul>
<li>unveil公布，揭幕；measure措施；on that score实现那目标；sick pay病假工资；self-isolate自我隔离；shutdown停工；payroll工资单；congress国会</li>
</ul>
<p>Trump’s big announcement for keeping the virus at bay – what he said was a 30-day ban on travel to the US by Europeans and restrictions on cargo – was immediately engulfed in confusion.</p>
<ul>
<li>bay绝路；engulf吞噬</li>
</ul>
<p>The President later rushed to clarify on Twitter that he was stopping travel and not trans-Atlantic trade in goods, and officials said his plan did not apply to Americans or US permanent residents – though such travelers would face mandatory quarantines.</p>
<ul>
<li>apply to适用于；mandatory强制性的；quarantine隔离检疫</li>
</ul>
<p>“The restriction stops people not goods,” Trump tweeted after his speech.</p>
<p>Trump also caused a muddle when he said he had convinced health insurance providers to waive all copayments for coronavirus treatments.</p>
<ul>
<li>muddle混乱；convince说服；waive放弃；copayment自付费用</li>
</ul>
<p>A White House official later said the President had meant to say that the copayments would be waived for coronavirus tests – but would still apply to treatments for the disease.</p>
<p>On Thursday morning, Vice President Mike Pence defended Trump’s presentation.</p>
<ul>
<li>Vice President副总统；defend辩护</li>
</ul>
<p>“I don’t think there’s confusion,” Pence said on CNN’s “New Day,” praising the President for taking another historic step to suspend all travel from Europe … for the next 30 days.</p>
<ul>
<li>praise称赞</li>
</ul>
<p>Pence then announced that “Americans coming home will be funneled through 13 different airports,” and would be screened at those airports.</p>
<ul>
<li>funnel [v]漏进 [n]漏斗；screen[v]遮掩</li>
</ul>
<p>“Then we’re going to ask every American and legal resident returning to the United States to self-quarantine for 14 days,” he said.</p>
<p>European Union leaders said Thursday they disapprove of Trump’s decision.</p>
<ul>
<li>disapprove不赞同</li>
</ul>
<p>In a statement, the Presidents of the European Council and the European Commission, Charles Michel and Ursula von der Leyen, respectively, said that the outbreak is a “global crisis, not limited to any continent and it requires cooperation rather than unilateral action.”</p>
<ul>
<li>respectively分别地；outbreak[n]发病；continent大陆；’u[ju]nilateral单方面的</li>
</ul>
<p>“The European Union disapproves of the fact that the US decision to impose a travel ban was taken unilaterally and without consultation,” the statement read.</p>
<ul>
<li>impose强加；consultation协商</li>
</ul>
<h4 id="Sowing-confusion"><a href="#Sowing-confusion" class="headerlink" title="Sowing confusion"></a>Sowing confusion</h4><p>The confusion was symptomatic of an administration that has often struggled to frame detailed policies and present them coherently. Trump’s top assignment on Wednesday was to show that he was in charge and that he appreciated, finally, the grave nature of the weeks that lie ahead. But the confusion over the travel ban turned his speech into something of a debacle and may up exacerbating uncertainty over his leadership.</p>
<ul>
<li>symptonatic征兆；administration行政部门；struggle努力；frame[v]制定；co’he[i]rently连贯地；assignment任务，分配；grave严重；nature性质；weeks lie ahead未来几周；de[i]’ba[a]cle崩溃；e’xacerbate加剧，恶化；</li>
</ul>
<p><u>And his travel ban announcement was made apparently without consultation with the travel industry or US allies and seems set to cause massive disruption that will deepen already cascading economic damage unleashed by the crisis.</u></p>
<ul>
<li>disruption破坏；deepen加深；cascading一系列的，级联；unleash发动</li>
</ul>
<p>The move could cause mass cancellation of trans-Atlantic flights, which could throw the aviation industry into a moment of existential challenge. Trump acted after Italy, which has now recorded over 12,000 cases, experienced <u>a record jump in confirmed infections with 2,313 on Wednesday.</u></p>
<ul>
<li>aviation航空；infection感染；a record jump in confirmed infection with 2,313 on Wednsday周三确认感染病例达到创纪录的2313例</li>
</ul>
<p>US Travel Association President and CEO Roger Dow called on Trump to <u>match his aggressive action with equally bold moves</u> to shore up the travel industry.</p>
<ul>
<li>call on呼吁；aggressive积极的；bold大胆的；shore up支撑</li>
</ul>
<p>“Temporarily shutting off travel from Europe is going to exacerbate the already-heavy impact of coronavirus on the travel industry and the 15.7 million Americans whose jobs depend on travel,” Dow said in a statement. The Association said that 850,000 international visitors flew to the US from parts of Europe other than the UK in March 2019 and spent around $3.4 billion in this country.</p>
<ul>
<li>other than以外</li>
</ul>
<p>Such figures will do nothing to quell investor panic after Wall Street on Wednesday dipped into a bear market. For example, Dow Futures plunged more than 1,000 points after Trump’s speech, despite the President’s arguments the strong US economy will emerge from the crisis unscathed.</p>
<ul>
<li>figures数字；quell平息；dip into浸入；bear market熊市; plung[dʒ]e暴跌；despite尽管；argument观点；emerge摆脱困境，出现；unscathed毫发无损地</li>
</ul>
<p>“This is not a financial crisis. This is just a temporary moment of time that we will overcome together as a nation and as a world,” Trump said in his address.</p>
<ul>
<li>address讲话</li>
</ul>
<p>US stocks sold off sharply for the second straight day on Thursday, after Trump’s announcement. Wall Street investors are worried about the scale of the coronavirus pandemic and its economic consequences.</p>
<ul>
<li>sold off跌价；second straight day连续第二天；pan’demic（全球性的）流行病；concequence后果</li>
</ul>
<p>On a more fundamental level, the travel ban plan raised basic questions about the President’s understanding of a crisis he has minimized, blamed on Democrats and predicted will just go away soon.</p>
<ul>
<li>fundamental根本的；raise提出；blamed on归咎于；’Demo[ə]crats民主党人；predict预计</li>
</ul>
<p>Department of Homeland Security guidance suggested the restrictions exempted US nationals and permanent residents, who would face quarantine when they came home. And the President did not explain why his ban did not include citizens of the UK – where the virus has also taken root.</p>
<ul>
<li>guidance指导；restriction限制；exempt豁免；</li>
</ul>
<p><u>But the biggest problem facing the US is not more cases of coronavirus coming from Europe</u> – it is that the disease has taken root on US soil itself by community spread.</p>
<p>Pressing issues now revolve around how Americans should respond to the situation and to what extent they should change their daily patterns. Trump did advise halting nonessential visits to care homes for the elderly – the highest risk group from the virus.</p>
<ul>
<li>pressing issue紧迫的问题；revolve围绕；respond to应对；extent程度；pattern模式；daily pattern生活习惯；nonessential不必要的；</li>
</ul>
<p><u>But he didn’t explain how he would alleviate what health officials fear will be a crowding of hospitals</u>, the continuing lack of proper testing or the coming strain on resources such as breathing machines needed to keep the sickest patients alive.</p>
<ul>
<li>alleviate缓解；the continuing lack持续缺乏；proper合适的；strain紧张，压力</li>
</ul>
<p>He argued that the threat was still “very low” for all but the old and infirm, on a day when one of his top public health officials, Dr. Anthony Fauci, predicted the current scenario – with more than 1,200 people sick in the US and 38 dead, is “going to get worse.”</p>
<ul>
<li>infirm体弱的；predict预测；sce[ə]’na[æ]rio情景；</li>
</ul>
<p>Local officials in some hard-hit areas are meanwhile warning that failures in the federal response are making the situation worse.</p>
<ul>
<li>hard-hit area重灾区；federal联邦政府；response应对措施；</li>
</ul>
<p><u>The mayor of Seattle, Jenny Durkan, said that a lack of testing kits earlier in the pandemic that continues to this day was preventing patients getting the treatment they needed and officials from understanding the community spread of the disease.</u> She told CNN’s Don Lemon that stringent measures to restrict public gatherings and close schools were therefore vital to saving lives.</p>
<ul>
<li>mayor市长；prevent阻止；stringent严格的；measure措施；vital重要的</li>
</ul>
<p>“By doing some modeling and looking at the tests, (scientists) calculate that if we didn’t take the kind of actions that the governor and I and the executives announced today, that by April 7th, we would have over 25,000 cases in the city of Seattle in this region. And 400 deaths,” Durkan said.</p>
<ul>
<li>executive高管</li>
</ul>
<h4 id="Trump-speech-likely-to-split-the-nation"><a href="#Trump-speech-likely-to-split-the-nation" class="headerlink" title="Trump speech likely to split the nation"></a>Trump speech likely to split the nation</h4><p>To Trump’s supporters, his address likely came across as a decisive and bold move to face up to a national challenge.</p>
<ul>
<li>come across给人以印象；de’ci[aɪ]sive果断的；bold大胆的；</li>
</ul>
<p>But to critics it followed a familiar playbook – as he blamed others for the crisis, basked in self-congratulation and xenophobia, and misled the country about his actions so far.</p>
<ul>
<li>critic批评者；playbook剧本；bask沐浴阳光；xe[ze]no’phobia排外主义；mis’led误导</li>
</ul>
<p>“This is the most aggressive and comprehensive effort to confront a foreign virus in modern history,” Trump said, misrepresenting his own and his administration’s catalog of missteps.</p>
<ul>
<li>comprehensive全面的；confront对抗；misrepresent歪曲；catalog of missteps让自己处于尴尬境地的list</li>
</ul>
<p>The President did not mention, for example, the shortage of testing kits, which means officials cannot even get a strong read on how far the disease has spread across the nation.</p>
<ul>
<li>get a strong read好好理解一下</li>
</ul>
<p>Presidents use Oval Office addresses in moments of extremis, to bind Americans together to confront a challenge that threatens their collective security.</p>
<ul>
<li>in extremis | in an extremely difficult situation；bind捆绑；collective集体的</li>
</ul>
<p>But Trump’s toneless, almost resentful address as he faces a challenge from outside that could threaten his reelection hopes is unlikely to fulfill the soaring mission of the presidency.</p>
<ul>
<li>toneless无言；resentful不满的；reelection连任；full’fill完成；soaring高涨的；presidency任期</li>
</ul>
<p>His central remedy – blaming China, where the crisis was spawned, and Europe for becoming afflicted with it – was consistent with his political mantra of demonizing foreigners.</p>
<ul>
<li>re[e]me[ə]dy补救方法；afflict折磨；consistent一致的；mantra口头禅；’de[i]monize妖魔化</li>
</ul>
<p><u>The idea that a virus that affects all humans and is a naturally occurring force was some kind of foreign-brewed threat sent to attack Americans is in itself staggering in its conception.</u></p>
<ul>
<li>brew酿造；in itself本身，本质上；staggering相当震惊；</li>
</ul>
<p>The President did announce a raft of measures to support businesses and individuals with tax relief and low interest rates as the virus tightens its grip on the US.</p>
<ul>
<li>raft一系列的；measure措施；individual个体；relief救济；tighten束紧；grip | [n]a tight hold on something or someone</li>
</ul>
<p>But Trump’s plan to self-isolate the US from Europe appears to be a case of closing the stable door after the horse has bolted – the virus is already here and infecting more Americans by the day.</p>
<ul>
<li>bolt闩上</li>
</ul>
<div class="note primary">
            <p><strong>OriginalLink:</strong> <a href="https://www.cnn.com/2020/03/12/politics/donald-trump-coronavirus-europe-travel/index.html" target="_blank" rel="noopener">Trump address sparks chaos as coronavirus crisis deepens</a></p>
          </div>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #3 水壶问题（Water and Jug Problem）</title>
    <url>/2020/03/21/LeetCode-3-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98%EF%BC%88Water-and-Jug-Problem%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
</blockquote>
<h3 id="示例-1-From-the-famous-“Die-Hard”-example"><a href="#示例-1-From-the-famous-“Die-Hard”-example" class="headerlink" title="示例 1: (From the famous “Die Hard” example)"></a>示例 1: (From the famous “Die Hard” example)</h3><blockquote>
<p>输入: x = 3, y = 5, z = 4<br>输出: True</p>
</blockquote>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><blockquote>
<p>输入: x = 2, y = 6, z = 5<br>输出: False</p>
</blockquote>
<hr>
<h3 id="贝祖定理方法"><a href="#贝祖定理方法" class="headerlink" title="贝祖定理方法"></a>贝祖定理方法</h3><p>关键在于划分成功条件。<br>题干默认z &gt;= 0，首先当z = 0 时，x和y取任意值，一定成功。<br>当z &gt; 0时：</p>
<ul>
<li>当x + y &lt; z时，即使两盏杯子装满水，依然不可能成功。</li>
<li>当x + y = z时，x, y, z取任意值，一定成功。</li>
<li>当x + y &gt; z时，不一定。问题的核心在此，用贝祖定理判定成功条件。<br>由贝祖定理可知，对任何整数x、y和它们的最大公约数gcd(x, y)，对于它们的的任意整数倍数a,b,c，都有<br>ax + by = c·gcd(x, y)恒成立。<br>由题干给出的几种操作，要完成目标，一定有ax + by = z。<br>和贝祖定理完美锲合，那么，只要z % (gcd(x, y)) = 0为真，则一定成功。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//贝祖定理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认z &gt;= 0</span></span><br><span class="line">        <span class="keyword">if</span> (z == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//z&gt;0</span></span><br><span class="line">        <span class="keyword">if</span> (x +y &lt;z)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x + y == z)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//only x!=0,y!=0; x!=0,y==0; x==0,y!=0</span></span><br><span class="line">            <span class="keyword">return</span> z % gcd(x, y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123; <span class="comment">//辗转相除法</span></span><br><span class="line">            <span class="keyword">int</span> temp = y;</span><br><span class="line">            y = x % y;</span><br><span class="line">            x = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3></li>
</ul>
<h5 id="题目链接https-leetcode-cn-com-problems-water-and-jug-problem"><a href="#题目链接https-leetcode-cn-com-problems-water-and-jug-problem" class="headerlink" title="题目链接https://leetcode-cn.com/problems/water-and-jug-problem/"></a>题目链接<a href="https://leetcode-cn.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/water-and-jug-problem/</a></h5>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>贝祖定理</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 40. 最小的k个数</title>
    <url>/2020/03/20/%E5%89%91%E6%8C%87Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p><strong>示例1：</strong></p>
<blockquote>
<p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p>
</blockquote>
<p><strong>限制：</strong></p>
<blockquote>
<p>$0 &lt;= k &lt;= arr.length &lt;= 10000$<br>$0 &lt;= arr[i] &lt;= 10000$</p>
</blockquote>
<hr>
<h3 id="快速查找方法-分治法，快速排序思想"><a href="#快速查找方法-分治法，快速排序思想" class="headerlink" title="快速查找方法(分治法，快速排序思想)"></a>快速查找方法(分治法，快速排序思想)</h3><p><img src="1.png" alt="0x0"></p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopK</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getTopK(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt;= arr.length)</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length -<span class="number">1</span>;</span><br><span class="line">        partitionArray(arr, low, high, k);</span><br><span class="line">        <span class="comment">//copy array</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> copy = <span class="number">0</span>; copy &lt; k; copy++)&#123;</span><br><span class="line">            result[copy] = arr[copy];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partitionArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = partition(arr, low, high);</span><br><span class="line">        <span class="keyword">if</span> (k == m) <span class="comment">//as we expect，反复递归，k会在m左右两侧摇摆，直到恰好等于m</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; m)</span><br><span class="line">            partitionArray(arr, low, m -<span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            partitionArray(arr, m + <span class="number">1</span>, high, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = high + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v = arr[low];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[++i] &lt; v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == high) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (arr[--j] &gt; v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == low) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123; <span class="comment">//碰头了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, low, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="堆方法"><a href="#堆方法" class="headerlink" title="堆方法"></a>堆方法</h3><p>维护一个大顶堆，堆中始终保持当前状态最小k个数。</p>
<p><img src="2.gif" alt="0x1"></p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li><li class="tab"><a href="#g_tab1-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; mxheap;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            mxheap.push(arr[i]);</span><br><span class="line">            <span class="keyword">for</span> (; mxheap.<span class="built_in">size</span>() &gt; k; mxheap.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (; !mxheap.empty(); mxheap.pop())</span><br><span class="line">            res.push_back(mxheap.top());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用一个最大堆（大顶堆）</span></span><br><span class="line">        <span class="comment">// Java 的 PriorityQueue 默认是小顶堆，添加 comparator 参数使其变成最大堆,or we can do it like this:</span></span><br><span class="line">        <span class="comment">// Collections.reverseOrder()</span></span><br><span class="line">        <span class="comment">//PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (i1, i2) -&gt; Integer.compare(i2, i1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : arr) &#123;</span><br><span class="line">            <span class="comment">// 当前数字小于堆顶元素才会入堆</span></span><br><span class="line">            <span class="keyword">if</span> (heap.isEmpty() || heap.size() &lt; k || e &lt; heap.peek()) &#123; <span class="comment">//Queue.peek()返回堆顶最大元素（不删除），空堆返回null</span></span><br><span class="line">                heap.offer(e); <span class="comment">//Queue.offer()插入元素e，返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">                heap.poll(); <span class="comment">// Queue.poll()推出堆顶最大元素作为返回值，空堆返回null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将堆中的元素存入数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : heap) &#123; <span class="comment">//遍历堆</span></span><br><span class="line">            res[j++] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>待更新。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指Offer 40. 最小的k个数</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>TopK</tag>
        <tag>排序</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #6 按摩师（The Masseuse LCCI）</title>
    <url>/2020/03/24/LeetCode-6-%E6%8C%89%E6%91%A9%E5%B8%88%EF%BC%88The-Masseuse-LCCI%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或&gt; 不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。&gt; 给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p><strong>注意</strong>：本题相对原题稍作改动</p>
</blockquote>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><blockquote>
<p>输入： [1,2,3,1]<br>输出： 4<br>解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。</p>
</blockquote>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><blockquote>
<p>输入： [2,7,9,3,1]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 &gt; = 12。</p>
</blockquote>
<h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><blockquote>
<p>输入： [2,1,4,5,3,1,1,3]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = &gt; 2 + 4 + 3 + 3 = 12。</p>
</blockquote>
<hr>
<h3 id="一维状态数组"><a href="#一维状态数组" class="headerlink" title="一维状态数组"></a>一维状态数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>];<span class="comment">//or i-1 because i++ in last step</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(N)O(N)，NN 是数组的长度；</li>
<li>空间复杂度：O(N)O(N)，状态数组的大小为 N</li>
</ul>
<h3 id="一维状态数组-「滚动数组」"><a href="#一维状态数组-「滚动数组」" class="headerlink" title="一维状态数组+「滚动数组」"></a>一维状态数组+「滚动数组」</h3><p>使用 3 个变量滚动完成计算，将空间优化到常数级别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionSO1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre = <span class="number">0</span>, cur = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            cur = Math.max(pre, pre2 + num);</span><br><span class="line">            pre2 = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(N)，N是数组的长度；</li>
<li>空间复杂度：O(1)，状态数组的大小为 3，常数空间。</li>
</ul>
<h5 id="题目链接https-leetcode-cn-com-problems-the-masseuse-lcci"><a href="#题目链接https-leetcode-cn-com-problems-the-masseuse-lcci" class="headerlink" title="题目链接https://leetcode-cn.com/problems/the-masseuse-lcci/"></a>题目链接<a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-masseuse-lcci/</a></h5><h5 id="参考题解"><a href="#参考题解" class="headerlink" title="参考题解"></a>参考题解</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/solution/dong-tai-gui-hua-by-liweiwei1419-8/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-masseuse-lcci/solution/dong-tai-gui-hua-by-liweiwei1419-8/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #5 链表的中间结点（Middle of the Linked List）</title>
    <url>/2020/03/23/LeetCode-5-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9%EF%BC%88Middle-of-the-Linked-List%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。</p>
</blockquote>
<p><strong>示例1：</strong></p>
<blockquote>
<p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>给定链表的结点数介于 1 和 100 之间。</li>
</ul>
<hr>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>定义一个快指针，定义一个慢指针。其中快指针每个循环走两部，慢指针走一步。这样，当快指针走慢整个链表，由于其速度是慢指针的二倍，故慢指针停留的位置即为链表的中间结点。</p>
<p>注意到，当链表结点个数为偶时，即链表有两个中间结点。此时，题干要求返回第二个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x0</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next.next == <span class="keyword">null</span>) fast = fast.next;</span><br><span class="line">            <span class="keyword">else</span> fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若题干要求返回第一个结点，应该这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return secondary node while we got a even node linkedList</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next.next == <span class="keyword">null</span>) fast = fast.next;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表类数组"><a href="#链表类数组" class="headerlink" title="链表类数组"></a>链表类数组</h3><p>换个思路，当我们知道链表结点个数，个数/2即为中间结点位置。我们可以创建一个链表类数组（记得曾经用过的计数数组吗？数组是个好东西，我们要把它玩坏！）循环链表每个结点，把它放在数组里。</p>
<p>注意到，由于题干给出当有两个中间结点取其第二个，我们正好可以利用整形变量特征————int a = 5 / 2，则a被强制转换向下取整为2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode[] arr = <span class="keyword">new</span> ListNode[<span class="number">100</span>]; <span class="comment">//we have restriction about length of linkedList</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            arr[i++] = head;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[count / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者用ArratList可以稍微稍微节省点空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        List&lt;ListNode&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            arr.add(head);</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr.get(arr.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode # 7 三维形体的表面积（Surface Area of 3D Shapes）</title>
    <url>/2020/03/25/LeetCode-7-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF%EF%BC%88Surface-Area-of-3D-Shapes%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。</p>
<p>每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。</p>
<p>请你返回最终形体的表面积。</p>
</blockquote>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><blockquote>
<p>输入：[[2]]<br>输出：10</p>
</blockquote>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><blockquote>
<p>输入：[[1,2],[3,4]]<br>输出：34</p>
</blockquote>
<h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><blockquote>
<p>输入：[[1,0],[0,2]]<br>输出：16</p>
</blockquote>
<h3 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h3><blockquote>
<p>输入：[[1,1,1],[1,0,1],[1,1,1]]<br>输出：32</p>
</blockquote>
<h3 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h3><blockquote>
<p>输入：[[2,2,2],[2,1,2],[2,2,2]]<br>输出：46</p>
</blockquote>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><blockquote>
<ul>
<li>1 &lt;= N &lt;= 50</li>
<li>0 &lt;= grid[i][j] &lt;= 50</li>
</ul>
</blockquote>
<hr>
<p>用示例5举例，二维数组<code>[[2,2,2],[2,1,2],[2,2,2]]</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] grid = &#123;</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>表明一个3*3网格，每个格子分别放置对应数字的方块。<br>那么，表面积 = 总数 * 6 - 2(x + y + z)，其中x, y, z分别表示x, y, z方向重叠面数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this surface means hidden surface</span></span><br><span class="line">        <span class="keyword">int</span> surfaceZ = <span class="number">0</span>, surfaceY = <span class="number">0</span>, surfaceX = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// value count</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> raw = <span class="number">0</span>; raw &lt; grid.length; raw++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; grid[raw].length; column++) &#123;</span><br><span class="line">                <span class="comment">// count value</span></span><br><span class="line">                value += grid[raw][column];</span><br><span class="line">                <span class="comment">// for each X, Y ,Z count hidden surface</span></span><br><span class="line">                <span class="keyword">if</span> (raw &lt; grid.length - <span class="number">1</span>)</span><br><span class="line">                    surfaceX += Math.min(grid[raw][column], grid[raw+<span class="number">1</span>][column]);</span><br><span class="line">                <span class="keyword">if</span> (column &lt; grid[raw].length - <span class="number">1</span>)</span><br><span class="line">                    surfaceY += Math.min(grid[raw][column], grid[raw][column+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (grid[raw][column] &gt; <span class="number">0</span>)</span><br><span class="line">                    surfaceZ += (grid[raw][column] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// this surface is real "surface"</span></span><br><span class="line">        <span class="keyword">int</span> surface = <span class="number">0</span>;</span><br><span class="line">        surface = value * <span class="number">6</span> - surfaceX * <span class="number">2</span> - surfaceY * <span class="number">2</span> - surfaceZ * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> surface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(N^2)，其中 NN 是 grid 中的行和列的数目</li>
<li>空间复杂度：O(1)</li>
</ul>
<h5 id="题目链接https-leetcode-cn-com-problems-surface-area-of-3d-shapes"><a href="#题目链接https-leetcode-cn-com-problems-surface-area-of-3d-shapes" class="headerlink" title="题目链接https://leetcode-cn.com/problems/surface-area-of-3d-shapes/"></a>题目链接<a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/surface-area-of-3d-shapes/</a></h5>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title>求最大公约数（gcd）的一点心得</title>
    <url>/2020/03/27/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%EF%BC%88gcd%EF%BC%89%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h3 id="求两个数的最大公约数"><a href="#求两个数的最大公约数" class="headerlink" title="求两个数的最大公约数"></a>求两个数的最大公约数</h3><p>在《算法 第4版》中，给出迭代求最大公约数的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="number">0</span>) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">int</span> r = p % q;</span><br><span class="line">    <span class="keyword">return</span> gcd(q, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以注意到，这里用到了迭代的思想。两数相除，再拿被除数除余数，如此辗转，直到余数为零，返回此时的被除数 。<br>上述代码可简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q == <span class="number">0</span> ? p : gcd(q, p % q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个非迭代版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (y != <span class="number">0</span>) &#123; </span><br><span class="line">         <span class="keyword">int</span> temp = y;</span><br><span class="line">         y = x % y; <span class="comment">// 余数变被除数</span></span><br><span class="line">         x = temp; <span class="comment">//被除数变除数</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="n个数求最大公约数"><a href="#n个数求最大公约数" class="headerlink" title="n个数求最大公约数"></a>n个数求最大公约数</h3><p>一个常见的求法就是设置一个初始的gcd，求它和第一个数的gcd。再将该gcd和第二个数求它们的gcd，如此辗转，直到求第n个数和前n-1个数的gcd。复杂度是O(N)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GcdN</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcdN</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gcd = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> each : arr) </span><br><span class="line">            gcd = gcd(gcd, each);</span><br><span class="line">        <span class="keyword">return</span> gcd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q == <span class="number">0</span> ? p : gcd(q, p % q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>方便调试的链表类实现</title>
    <url>/2020/03/26/%E6%96%B9%E4%BE%BF%E8%B0%83%E8%AF%95%E7%9A%84%E9%93%BE%E8%A1%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>链表是一种特殊的数据结构：<br><img src="2020-03-26-%E6%96%B9%E4%BE%BF%E8%B0%83%E8%AF%95%E7%9A%84%E9%93%BE%E8%A1%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0/%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="pic0x0"><br>它包含了两部分：<br>$$ListNodePtr<br>\begin{cases}{value} \\<br>{next}\begin{cases}{value} \\<br>                    {next}\begin{cases}{value} \\<br>                                       {next…}<br>                                       \end{cases}<br>                    \end{cases}<br>\end{cases}<br>$$<br>在《算法 第4版》中是这样描述的：</p>
<blockquote>
<p>链表是一种递归的数据结构，它或者为空(null)，或者是指向一个结点(node)的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。</p>
</blockquote>
<p>在我看来，因为链表是一种递归的数据结构，故不要把“结点”看成一个“点”。而应该看成是一个<code>value</code> + 该<code>value</code>后的全部链表———它是全部链表的一部分。<br>关于这个<code>value</code>，它可能是任意数据类型。</p>
<p>一般来说链表类可以写成如下结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>为了在调试代码的时候直观地看到链表形如<code>7 -&gt; 0 -&gt; 8 -&gt; null</code>，链表类可以写成如下结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"arr can not be empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        val = nums[<span class="number">0</span>];</span><br><span class="line">        ListNode curr = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(nums[i]); <span class="comment">//创建ListNode实例，调用前面的构造方法</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        ListNode cur = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.append(cur.val);</span><br><span class="line">            s.append(<span class="string">" -&gt; "</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">"null"</span>);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调试的时候，比如向<code>SolutionMe0x0</code>类的<code>testListNode</code>方法中传递链表<code>ListNode lx, ListNode ly</code>，我们可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">int</span>[] test1 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] test2 = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="comment">//int[] test1 = &#123;6, 7, 8, 3, 2, 7&#125;;</span></span><br><span class="line">        <span class="comment">//int[] test2 = &#123;9, 7, 6, 6&#125;;</span></span><br><span class="line">        <span class="comment">//int[] test1 = &#123;2&#125;;</span></span><br><span class="line">        <span class="comment">//int[] test2 = &#123;5&#125;;</span></span><br><span class="line">        ListNode lx = <span class="keyword">new</span> ListNode(test1);</span><br><span class="line">        ListNode ly = <span class="keyword">new</span> ListNode(test2);</span><br><span class="line">        System.out.println(SolutionMe0x0.testListNode(lx));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #4 使数组唯一的最小增量（Minimum Increment to Make Array Unique）</title>
    <url>/2020/03/22/LeetCode-4-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F%EF%BC%88Minimum%20Increment%20to%20Make%20Array%20Unique%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><blockquote>
<p>给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。</p>
<p>返回使 A 中的每个值都是唯一的最少操作次数。</p>
</blockquote>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><blockquote>
<p>输入：[1,2,2]<br>输出：1<br>解释：经过一次 move 操作，数组将变为 [1, 2, 3]。</p>
</blockquote>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><blockquote>
<p>输入：[3,2,1,2,1,7]<br>输出：6<br>解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。<br>可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。</p>
</blockquote>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><blockquote>
<ul>
<li>0 &lt;= A.length &lt;= 40000</li>
<li>0 &lt;= A[i] &lt; 40000</li>
</ul>
</blockquote>
<hr>
<h3 id="先排序再遍历"><a href="#先排序再遍历" class="headerlink" title="先排序再遍历"></a>先排序再遍历</h3><p>首先将数组进行排序，然后从左到右遍历数组：</p>
<ul>
<li>如果当前元素大于上一个元素，保持不变；</li>
<li>如果当前元素小于等于上一个元素，就需要增加当前元素，直到大于上一个元素。<br>例如输入 <code>[3, 2, 1, 2, 1, 7]</code>，排序后为<code>[1, 1, 2, 2, 3, 7]</code>。遍历数组的过程如下图所示：<br>![pic0x0](2020-03-22-LeetCode-4-使数组唯一的最小增量（Minimum Increment to Make Array Unique）/使数组唯一的最小增量 先排序再遍历.gif)<br>写成代码，只需要用一个变量保存当前的最大值即可。题解代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//排序再遍历计数，最基础的计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.length &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="comment">//下个数不比当前数大，则计算下个数需要加的次数res，同时</span></span><br><span class="line">        <span class="comment">//由于每次move操作+1，故下个数+res刚好大于当前数</span></span><br><span class="line">        <span class="comment">//注意此时数组排序会被打乱，不能认为判断条件仅是相等情况.</span></span><br><span class="line">        <span class="comment">//另外，注意边界，最多判定到lengh - 2位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i+<span class="number">1</span>] &lt;= A[i])&#123;</span><br><span class="line">                res += (A[i] - A[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                A[i+<span class="number">1</span>] += (A[i] - A[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="构建计数数组"><a href="#构建计数数组" class="headerlink" title="构建计数数组"></a>构建计数数组</h3><p>上面方法中，排序需要 O(n \log n)O(nlogn) 的时间，比较昂贵。我们尝试不进行排序的方法。</p>
<p>例如输入 <code>[3, 2, 1, 2, 1, 7]</code>，计数之后有两个 1 和两个 2。我们先看最小的数，两个 1 重复了，需要有一个增加到 2，这样 2 的数量变成了三个。在三个 2 中，又有两个需要增加到 3，然后又出现了两个 3…… 以此类推，可以计算出需要增加的次数。</p>
<p>我们可以用 map（如 C++ 的 <code>unordered_map</code>，Java 的 <code>HashMap</code>）来做计数。不过既然题目中说明了整数的范围在 0 到 40000 之间，我们不妨直接用一个大小为 40000 的数组做计数。</p>
<p>需要注意的是，虽然整数的范围是 0 到 40000，但是由于整数还会因为增加而变大，超出 40000 的范围。例如极端的情况：所有数都是 39999。所以需要对整数中最大的数单独处理。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计数数组（有序）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A.length &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//核心思想，是record数组的构建</span></span><br><span class="line">        <span class="comment">//record数组是有序数组，index表示A数组中的值，value表示A数组中数值出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40000</span>];</span><br><span class="line">        <span class="keyword">int</span> max= A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            record[a]++;</span><br><span class="line">            max = Math.max(max, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A数组中最大数max一定在record数组最后面，等下要加以特殊处理</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res += (record[i] -<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//record是动态的</span></span><br><span class="line">                <span class="comment">//如果当前位置数值&gt;1，说明下个位置数值会增加当前位置数值-1</span></span><br><span class="line">                record[i+<span class="number">1</span>] += (record[i] -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A数组最大值max在record数组中特殊处理</span></span><br><span class="line">        <span class="comment">//max位于record右边界的情况</span></span><br><span class="line">        <span class="keyword">if</span> (record[max] &gt; <span class="number">1</span>) &#123; <span class="comment">//否则不用担心越界</span></span><br><span class="line">            <span class="keyword">int</span> plus = record[max] - <span class="number">1</span>; <span class="comment">//首项（尾项1）</span></span><br><span class="line">            res += (plus + <span class="number">1</span>) * plus / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性探测法O-N-（含路径压缩）"><a href="#线性探测法O-N-（含路径压缩）" class="headerlink" title="线性探测法O(N) （含路径压缩）"></a>线性探测法O(N) （含路径压缩）</h3><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h5 id="题目链接https-leetcode-cn-com-problems-minimum-increment-to-make-array-unique"><a href="#题目链接https-leetcode-cn-com-problems-minimum-increment-to-make-array-unique" class="headerlink" title="题目链接https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/"></a>题目链接<a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/</a></h5><h5 id="参考题解"><a href="#参考题解" class="headerlink" title="参考题解"></a>参考题解</h5><blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/shi-shu-zu-wei-yi-de-zui-xiao-zeng-liang-by-leet-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/shi-shu-zu-wei-yi-de-zui-xiao-zeng-liang-by-leet-2/</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/ji-shu-onxian-xing-tan-ce-fa-onpai-xu-onlogn-yi-ya/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/ji-shu-onxian-xing-tan-ce-fa-onpai-xu-onlogn-yi-ya/</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/tan-xin-suan-fa-bing-cha-ji-java-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/tan-xin-suan-fa-bing-cha-ji-java-by-liweiwei1419/</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>排序</tag>
        <tag>计数数组</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>About me</title>
    <url>/2020/03/27/About-me/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">"zhangxy"</span>; <span class="comment">// Well, good name.</span></span><br><span class="line">    <span class="keyword">char</span> sex = <span class="string">'male'</span>; <span class="comment">// A tough man.</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">25</span>; <span class="comment">// Grasping the little tail of youth.</span></span><br><span class="line">    <span class="keyword">int</span> hight = <span class="number">170</span>; <span class="comment">// Enough to me.</span></span><br><span class="line">    <span class="keyword">float</span> weight = <span class="number">73.7f</span>; <span class="comment">// Emm, a little bit overweight, but everyday going to gym. Gym is second home. </span></span><br><span class="line">    String edu = <span class="string">"UESTC"</span>; <span class="comment">// Where the water tastes like wine. </span></span><br><span class="line">    String pro = <span class="string">"SE"</span>; <span class="comment">// Making cool stuff.</span></span><br><span class="line">    String marriage = <span class="string">"Single"</span>; <span class="comment">// I'm trying...emm...how to be more attractive ?</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wish</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"春日宴，浊酒一杯歌一遍。再拜陈三愿：</span></span><br><span class="line"><span class="string">                    一愿父母身体常健，</span></span><br><span class="line"><span class="string">                    二愿自己珍惜时间，</span></span><br><span class="line"><span class="string">                    三愿如同梁上燕，</span></span><br><span class="line"><span class="string">                    岁岁年年，快乐无边！"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moreInfo</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"Stay tuned:)"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>生活</category>
        <category>me</category>
        <category>About me</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode # 10 卡牌分组（X of a Kind in a Deck of Cards）</title>
    <url>/2020/03/29/LeetCode-10-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84%EF%BC%88X-of-a-Kind-in-a-Deck-of-Cards%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>最大公约数</tag>
        <tag>计数数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #9 两数相加（Add Two Numbers）</title>
    <url>/2020/03/29/LeetCode-9-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88Add%20Two%20Numbers%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</blockquote>
<p><strong>示例：</strong></p>
<blockquote>
<p><strong>输入：</strong>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><strong>输出：</strong> 7 -&gt; 0 -&gt; 8<br><strong>原因：</strong> 342 + 465 = 807</p>
</blockquote>
<hr>
<h3 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h3><p>我们需要创建一个新的链表作为相加后的返回对象，而且在新的链表构造过程中，其头结点需要不断移动，从而导致无法返回整个链表。</p>
<p>我们可以定义独立于新链表的一个 <strong>超级头结点</strong> ，让其指向新的链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//超级头结点</span></span><br><span class="line">        ListNode cur = pre; <span class="comment">//超级头结点指向新的链表</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> value1 = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> value2 = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="keyword">int</span> sum = value1 + value2 + carry;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) carry = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) cur.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.next; <span class="comment">//返回超级头结点的后面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>超级头结点</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转ffmpeg</title>
    <url>/2020/03/30/%E7%8E%A9%E8%BD%ACffmpeg/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>FFmpeg的使用技巧。</p>
<a id="more"></a>
<h3 id="合并分段视频"><a href="#合并分段视频" class="headerlink" title="合并分段视频"></a>合并分段视频</h3><p><strong>方法1：txt文件保存视频文件名</strong></p>
<blockquote>
<p><code>ffmpeg -f concat -safe 0 -i files.txt -c copy &quot;merge.MP4&quot;</code></p>
</blockquote>
<p>其中files.txt中写入分段视频文件名</p>
<blockquote>
<p>file  name0x0.ts<br>file  name0x1.ts<br>file  name0x2.ts<br>file  name0x3.ts<br>file  name0x4.ts<br>file  name0x5.ts</p>
</blockquote>
<p><strong>方法2：直接写入各个视频文件名</strong></p>
<blockquote>
<p><code>ffmpeg -i &quot;concat:name0x0|name0x1|name0x2|name0x3&quot; -c copy &quot;merge.mp4&quot;</code></p>
</blockquote>
<h3 id="视频转换格式"><a href="#视频转换格式" class="headerlink" title="视频转换格式"></a>视频转换格式</h3><blockquote>
<p><code>ffmpeg -i &quot;video.ts&quot; -vcodec copy -acodec copy &quot;video.mp4&quot;</code></p>
</blockquote>
<h3 id="截取一段视频"><a href="#截取一段视频" class="headerlink" title="截取一段视频"></a>截取一段视频</h3><p>从第12秒截取到294秒：<br><code>ffmpeg  -i 0x0.mkv -ss 12 -c copy -to 294 0x1.mp4</code></p>
<h3 id="提取视频中的音频"><a href="#提取视频中的音频" class="headerlink" title="提取视频中的音频"></a>提取视频中的音频</h3><p><code>ffmpeg -i xxx.mp4 -f mp3 -ar 16000 xxx.mp3</code><br>其中：<br>xxx.mp4 视频文件<br>-f mp3 mp3编码<br>-ar 16000 音频采样率<br>xxx.mp3输出的音频文件</p>
<p><strong>未完待续</strong></p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #1111 有效括号的嵌套深度「Maximum Nesting Depth of Two Valid Parentheses Strings」</title>
    <url>/2020/04/02/LeetCode-1111-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6%E3%80%8CMaximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings%E3%80%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode 999. 可以被一步捕获的棋子数</title>
    <url>/2020/03/26/LeetCode-999-%E5%8F%AF%E4%BB%A5%E8%A2%AB%E4%B8%80%E6%AD%A5%E6%8D%95%E8%8E%B7%E7%9A%84%E6%A3%8B%E5%AD%90%E6%95%B0/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>简单的模拟过程题目。</p>
<a id="more"></a>

<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>在一个 8 x 8 的棋盘上，有一个白色的车（<code>Rook</code>），用字符 <code>&#39;R&#39;</code> 表示。棋盘上还可能存在空方块，白色的象（<code>Bishop</code>）以及黑色的卒（<code>pawn</code>），分别用字符 <code>&#39;.&#39;</code>，<code>&#39;B&#39;</code> 和 <code>&#39;p&#39;</code> 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。</p>
<p>车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：</p>
<ul>
<li>棋手选择主动停下来。</li>
<li>棋子因到达棋盘的边缘而停下。</li>
<li>棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。</li>
<li>车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。</li>
</ul>
<p>你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。</p>
<p><strong>示例1：</strong><br><img src="1.png" alt="0x0"></p>
<blockquote>
<p><strong>输入：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;p&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;R&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;p&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;p&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong> 3<br><strong>解释：</strong> 在本例中，车能够捕获所有的卒</p>
</blockquote>
<p><strong>示例2：</strong><br><img src="2.png" alt="0x1"></p>
<blockquote>
<p><strong>输入：</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;p&#39;,&#39;p&#39;,&#39;p&#39;,&#39;p&#39;,&#39;p&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;p&#39;,&#39;p&#39;,&#39;B&#39;,&#39;p&#39;,&#39;p&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;p&#39;,&#39;B&#39;,&#39;R&#39;,&#39;B&#39;,&#39;p&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;p&#39;,&#39;p&#39;,&#39;B&#39;,&#39;p&#39;,&#39;p&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;p&#39;,&#39;p&#39;,&#39;p&#39;,&#39;p&#39;,&#39;p&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong> 0<br><strong>解释：</strong> 象阻止了车捕获任何卒</p>
</blockquote>
<p><strong>示例3：</strong><br><img src="3.png" alt="0x2"></p>
<blockquote>
<p><strong>输入：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;p&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;p&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;p&#39;,&#39;p&#39;,&#39;.&#39;,&#39;R&#39;,&#39;.&#39;,&#39;p&#39;,&#39;B&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;B&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;p&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">    &#123;&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;,&#39;.&#39;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong> 3<br><strong>解释：</strong> 车可以捕获位置 b5，d6 和 f5 的卒</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<ol>
<li><code>board.length == board[i].length == 8</code></li>
<li><code>board[i][j]</code> 可以是 <code>&#39;R&#39;</code>，<code>&#39;.&#39;</code>，<code>&#39;B&#39;</code> 或 <code>&#39;p&#39;</code></li>
<li>只有一个格子上存在 <code>board[i][j] == &#39;R&#39;</code></li>
</ol>
</blockquote>
<hr>
<p>题目所求即白车 <code>rock(R)</code> 一次移动击杀小卒 <code>pawn(p)</code> 所有可能的情况。<br>读懂题意后，先找白车 <code>R</code> ，以 <code>R</code> 为起点，分别往四个方向寻找 <code>p</code>。<br>注意可能会遇到 <code>Bishop(B)</code> ，表示此路不通。另注意范围。</p>
<h3 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j= <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> y = i, x = j;</span><br><span class="line">                    <span class="comment">//纵上</span></span><br><span class="line">                    <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//纵下</span></span><br><span class="line">                    i = y; <span class="comment">//i归位</span></span><br><span class="line">                    <span class="keyword">while</span> (++i &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//横左</span></span><br><span class="line">                    i = y;<span class="comment">//i归位</span></span><br><span class="line">                    <span class="keyword">while</span> (--j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//横右</span></span><br><span class="line">                    j = x;<span class="comment">//j归位</span></span><br><span class="line">                    <span class="keyword">while</span> (++j &lt;=<span class="number">7</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="二维方向数组"><a href="#二维方向数组" class="headerlink" title="二维方向数组"></a>二维方向数组</h3><p>依然是先找到<code>R</code>，定义方向数组<code>[[-1, 0], [1, 0], [0, 1], [0, -1]]</code>，循环该方向数组可表示依次走一个方向。<br>走其中某个方向时，用<code>i, j</code>分别加方向数组即可完成行走动作，注意在行走时要判断棋盘范围。</p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li><li class="tab"><a href="#g_tab1-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; R - <span class="number">1</span> || j &lt; <span class="number">0</span> || j &gt; C - <span class="number">1</span> || board[i][j] == <span class="string">'B'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board, i + dr[k], j + dc[k], k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;R = board.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;C = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        dfs(board, i, j, k);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为题目已经明确给出 board.length == board[i].length == 8，所以不做输入检查</span></span><br><span class="line">        <span class="comment">// 定义方向数组，可以认为是四个方向向量，在棋盘问题上是常见的做法</span></span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (burnout(board, i, j, direction)) &#123;</span><br><span class="line">                            res++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代码不会走到这里，返回 0 或者抛出异常均可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * burnout 横冲直撞的意思（来自欧路词典）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board     输入棋盘</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x         当前白象位置的横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y         当前白象位置的纵坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> direction 方向向量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 消灭一个 p，就返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">burnout</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[] direction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = x;</span><br><span class="line">        <span class="keyword">int</span> j = y;</span><br><span class="line">        <span class="keyword">while</span> (inArea(i, j)) &#123;</span><br><span class="line">            <span class="comment">// 是友军，路被堵死，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是敌军，拿下一血（不知道一血这个词是不是这么用的）</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += direction[<span class="number">0</span>];</span><br><span class="line">            j += direction[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 当前位置横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 当前位置纵坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否在棋盘有效范围内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; <span class="number">8</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/available-captures-for-rook/" target="_blank" rel="noopener">LeetCode 999. 可以被一步捕获的棋子数</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #20 有效的括号「Valid Parentheses」</title>
    <url>/2020/04/02/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E3%80%8CValid-Parentheses%E3%80%8D/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</li>
</ol>
<p><strong>示例1：</strong></p>
<blockquote>
<p>输入: “()”<br>输出: true</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p>输入: “()[]{}”<br>输出: true</p>
</blockquote>
<p><strong>示例3：</strong></p>
<blockquote>
<p>输入: “(]”<br>输出: false</p>
</blockquote>
<p><strong>示例4：</strong></p>
<blockquote>
<p>输入: “([)]”<br>输出: false</p>
</blockquote>
<p><strong>示例5：</strong></p>
<blockquote>
<p>输入: “{[]}”<br>输出: true</p>
</blockquote>
<hr>
<h3 id="HashMap辅助的栈解法"><a href="#HashMap辅助的栈解法" class="headerlink" title="HashMap辅助的栈解法"></a>HashMap辅助的栈解法</h3><p>构建一个key为开括号<code>&#39;(&#39;,&#39;[&#39;,&#39;{&#39;</code>value为闭括号<code>&#39;)&#39;&#39;]&#39;&#39;}&#39;</code>的HashMap。<br>遍历String字符串，当遇到开括号，由于将来有机会遇到与之对应的闭括号，故将其入栈。<br>当遇到闭括号，一旦它和栈顶的括号不匹配，可断言整体不是有效括号。（栈为空时，遇到的第一个若为闭括号也可看成与栈顶不匹配，但需做特殊处理）<br>当遍历完String字符串，中途没出现闭括号和栈顶字符不匹配的情况，此时若栈为空，则可断言之前入栈的开括号全部被匹配移除；若栈非空，可断言之前入栈的开括号没有找到匹配的闭括号，整体不属于有效括号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x0</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">        map.put(<span class="string">']'</span>, <span class="string">'['</span>);</span><br><span class="line">        map.put(<span class="string">'&#125;'</span>, <span class="string">'&#123;'</span>);</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cha = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(cha)) &#123;</span><br><span class="line">                stack.push(cha); <span class="comment">//开括号入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 栈为空时，必然return false，但为了用相同的方法让cha能和栈顶元素比较，push一个随便啥的字符</span></span><br><span class="line">                <span class="keyword">char</span> top = stack.isEmpty() ? <span class="string">'!'</span> : stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (map.get(cha) != top) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束，判断栈的状态</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="纯栈解法"><a href="#纯栈解法" class="headerlink" title="纯栈解法"></a>纯栈解法</h3><p>基本思路与上述方法一致，只是在判断闭括号栈顶元素时用一个小技巧代替<code>HashMap</code>。<br>遍历字符串，当遇到开括号时，把相对应的闭括号入栈。比如遇到<code>(</code>，把<code>)</code>入栈。这样，当下一个若是闭括号我们要那它和栈顶元素比较的话，可以不查<code>HashMap</code>而是直接比较是否相等。若相等，则是一对。继续循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cha = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cha == <span class="string">'('</span>) stack.push(<span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cha == <span class="string">'['</span>) stack.push(<span class="string">']'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cha == <span class="string">'&#123;'</span>) stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || cha != stack.pop()) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//此时遇到闭括号且栈为空，则必然无效，或者闭括号与栈顶元素不匹配，必然无效</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/</a><br><strong>参考题解：</strong> <a href="https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>栈</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读代码的一点心得</title>
    <url>/2020/04/04/%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>阅读代码时，要先看整体架构，再看局部细节。<br>明确哪里没变，哪里会变，怎么变的。</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #面试题01.07 旋转矩阵「Rotate Matrix LCCI」</title>
    <url>/2020/04/07/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9801-07-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E3%80%8CRotate-Matrix-LCCI%E3%80%8D/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？<br><strong>示例1：</strong></p>
<blockquote>
<p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p>给定 matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
</blockquote>
<hr>
<h3 id="原地旋转方法"><a href="#原地旋转方法" class="headerlink" title="原地旋转方法"></a>原地旋转方法</h3><p>先将数组按对角线翻折：<br><img src="2020-04-07-LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9801-07-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E3%80%8CRotate-Matrix-LCCI%E3%80%8D/Rotate_Matrix_LCCI_0x0.png" alt="pic0x0"><br>此时得到的数组每行和目标数组相反，只需要再将每行数组按中轴线翻折。<br>注意两次翻折的起始和终止，切记不能重复翻折（会折回去）。<br>比如第一次翻折不能写成<code>for (int j = 0; j &lt; len; j++)</code>。如果这样，在<code>i</code>向下遍历过程中，会将之前折的折回去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x0</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 0ms</span></span><br><span class="line"><span class="comment">     * 39.7MB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123; <span class="comment">//切莫从0开始，否则当遍历j时又换回去了</span></span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++) &#123; <span class="comment">//到中线结束，否则过中线又换回去了</span></span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][len - <span class="number">1</span> - j];</span><br><span class="line">                matrix[i][len - <span class="number">1</span> - j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="借用临时N-N数组（需额外空间）"><a href="#借用临时N-N数组（需额外空间）" class="headerlink" title="借用临时N * N数组（需额外空间）"></a>借用临时N * N数组（需额外空间）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution0x1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 0ms</span></span><br><span class="line"><span class="comment">     * 40.2MB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = matrix.length;</span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                temp[j][len - <span class="number">1</span> - i] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            System.arraycopy(temp[i], <span class="number">0</span>, matrix[i], <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-matrix-lcci/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeecCode #面试题13 机器人的运动范围「」</title>
    <url>/2020/04/08/LeecCode-%E9%9D%A2%E8%AF%95%E9%A2%9813-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E3%80%8C%E3%80%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>玩转rclone</title>
    <url>/2020/04/09/%E7%8E%A9%E8%BD%ACrclone/</url>
    <content><![CDATA[<h3 id="名词详解"><a href="#名词详解" class="headerlink" title="名词详解"></a>名词详解</h3><p><strong><code>remote</code></strong></p>
<blockquote>
<p><code>remote</code>可以理解成rclone程序「可操作」的对象。通常，一个remote在配置的时候会被分配：<br>一个API接口<code>client_id</code>和<code>client_secret</code>，可以默认rclone官方接口，也可以自己指定接口；<br>一个rclone权限<code>scope</code>，一共5种权限，通常我会选第1个Full access；<br>一个根目录ID<code>root_folder_id</code>，它指定了rclone程序可操作的源在什么地方，通常我会设置成网盘根目录，即对整个网盘可操作；<br>一个服务账号文件<code>service_account_file</code>，它可指定rclone使用真实或服务账号。</p>
</blockquote>
<h3 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h3><p><strong><code>copy</code></strong></p>
<blockquote>
<p><code>rclone copy remoteA:srcDir remoteB:dstDir</code></p>
<p><code>copy</code> 适用于从一个地方「拷贝」到另一个地方，不管是从本地到网盘还是网盘到网盘。需要注意的是，Rclone绑定的账号至少需要对源有「读取」权限，对目标有「写入」权限。</p>
<p><strong>举例：</strong><br>假设我们配置4个remote：remoteA为网盘A；remogteB为网盘B；remoteC为团队盘C；remoteD为团队盘D；<br>从remoteA的目录”/GdTemp”到remoteA的目录”/Movies/2020”：<br><code>rclone copy remoteA:/GdTemp remoteA/Movies/2020</code><br>从remoteA的目录”/GDTemp” </p>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>Rclone</tag>
        <tag>GoogleDrive</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #22 括号生成「Generate Parentheses」</title>
    <url>/2020/04/10/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E3%80%8CGenerate-Parentheses%E3%80%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode 42. 接雨水</title>
    <url>/2020/04/04/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>很容易就联想到使用栈来解决。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="%E9%A2%98%E7%9B%AE.png" alt="pic0x0"></p>
<center><font size=1>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</font></center>

<p><strong>示例：</strong></p>
<blockquote>
<p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6 </p>
</blockquote>
<hr>
<h3 id="按列计算（动态规划计算最值）"><a href="#按列计算（动态规划计算最值）" class="headerlink" title="按列计算（动态规划计算最值）"></a>按列计算（动态规划计算最值）</h3><p>遍历每列，判断要不要计算列上的积水。<br>如何判断？计算出该列左侧最高列高度，计算右侧最高列高度。<br>若该列比二者都小，则该列需要计算;否则不需计算。<br>如何分别计算某列两侧最值？<br>可维护两个数组分别存储每列左右两侧最值。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * [列解法, 动态规划]</span></span><br><span class="line"><span class="comment">     * 1ms</span></span><br><span class="line"><span class="comment">     * 39.3MB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span>[] leftSideMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] rightSideMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">//第一列和最后一列不需要计算两侧最值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            leftSideMax[i] = Math.max(leftSideMax[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            rightSideMax[i] = Math.max(rightSideMax[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minimum = Math.min(leftSideMax[j], rightSideMax[j]);</span><br><span class="line">            <span class="keyword">if</span> (height[j] &lt; minimum) &#123;</span><br><span class="line">                res += (minimum - height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>核心思想是先降后增必有积水。<br>这个就有点像有效括号，一对儿。<br>维护一个单调递减的栈，栈中存入柱子下标。（为什么存入下标而不直接存入高度？因为我们可能会计算两个相隔若干柱子之间的距离。）<br>入栈：栈为空时；当前柱子低于栈顶柱子。<br>出栈：当前柱子高于栈顶柱子。</p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li><li class="tab"><a href="#g_tab1-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-23 23:13:08</span></span><br><span class="line"><span class="comment"> * @Author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []() &#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">30010</span>;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; stk[N];  <span class="comment">// idx - height</span></span><br><span class="line">    <span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tt || <span class="built_in">height</span>[i] &lt;= stk[tt].second) &#123;</span><br><span class="line">                stk[++tt] = &#123;i, <span class="built_in">height</span>[i]&#125;;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前高度高于栈顶，可能会蓄水</span></span><br><span class="line">            <span class="comment">// 要从栈顶向下找到一个大于栈顶的柱子，如果存在则一定会蓄水，不存在则一定不会蓄水</span></span><br><span class="line">            <span class="keyword">for</span> (; tt &amp;&amp; <span class="built_in">height</span>[i] &gt; stk[tt].second;) &#123;   <span class="comment">// 栈内可能有多个柱子和当前柱子构成蓄水条件</span></span><br><span class="line">                <span class="keyword">int</span> stk_top_height = stk[tt].second;</span><br><span class="line">                <span class="keyword">for</span> (; tt; --tt) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stk[tt].second &gt; stk_top_height) &#123;  <span class="comment">// 找到了</span></span><br><span class="line">                        <span class="keyword">int</span> l = stk[tt].first, r = i;</span><br><span class="line">                        <span class="keyword">int</span> lheight = stk[tt].second, rheight = <span class="built_in">height</span>[i];</span><br><span class="line">                        res += (r - l - <span class="number">1</span>) * (<span class="built_in">min</span>(lheight, rheight) - stk_top_height);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 栈顶自动更新</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈内已无柱子和当前柱子构成蓄水条件</span></span><br><span class="line">            stk[++tt] = &#123;i, <span class="built_in">height</span>[i]&#125;; <span class="comment">// 不管之前找没找到，都将当前柱子入栈; 此时栈可能为空（之前没找到），也可能非空，之前找到了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 单调栈 简化代码</span></span><br><span class="line"><span class="comment">     * 4ms - 29.81%</span></span><br><span class="line"><span class="comment">     * 39.5MB, 11.78%</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123; <span class="comment">//有可能可计算体积</span></span><br><span class="line">                <span class="keyword">int</span> heightInfoBeforePop = stack.peek();</span><br><span class="line">                stack.pop(); <span class="comment">// 当前柱子高于栈顶柱子时，出栈。记得出栈前先保存栈高数据。</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">break</span>; <span class="comment">//不可计算体积</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> stackTop = stack.peek();</span><br><span class="line">                    res += ((i - stackTop - <span class="number">1</span>) * (Math.min(height[i], height[stackTop]) - height[heightInfoBeforePop]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i); <span class="comment">// 栈空或当前柱子小于等于于栈顶柱子高度时，入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>待更新。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">LeetCode 42. 接雨水</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>单调栈</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #151 翻转字符串里的单词「Reverse Words in a String」</title>
    <url>/2020/04/11/LeetCode-151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D%E3%80%8CReverse-Words-in-a-String%E3%80%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Linux常用Screen命令</title>
    <url>/2020/04/13/Linux%E5%B8%B8%E7%94%A8Screen%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。在使用过程中可以退出screen，甚至可以关掉登录窗口，下次再进去重新挂上screen会话，所有工作全部都会恢复。</p>
<blockquote>
<ul>
<li><p><strong>安装</strong><br><code>sudo apt install screen</code></p>
</li>
<li><p><strong>创建新会话</strong><br><code>screen -S 0x0</code><br>创建一个名为「0x0」的会话，可以在其中执行任务。</p>
</li>
<li><p><strong>让会话独立（Detached）</strong><br>在当前会话中按住<code>Ctrl + A + D</code>，即可让其独立。此时我们可以在终端执行其他任务或退出终端。</p>
</li>
<li><p><strong>重新连接会话</strong><br><code>screen -r 0x0</code><br>回到名为「0x0」的会话中。</p>
</li>
<li><p><strong>查看会话列表</strong><br><code>screen -ls</code></p>
</li>
<li><p><strong>结束会话</strong><br><code>screen -X -S 0x0 quit</code>强制结束「0x0」会话。<br>在「0x0」会话中按住<code>Ctrl + D</code>结束当前会话。</p>
</li>
<li><p><strong>清除死亡会话</strong><br><code>screen -wipe</code></p>
</li>
</ul>
</blockquote>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/40133139" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40133139</a><br><a href="https://www.cnblogs.com/xinzaibing/archive/2012/04/08/2437431.html" target="_blank" rel="noopener">https://www.cnblogs.com/xinzaibing/archive/2012/04/08/2437431.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Screen</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux平台解压缩</title>
    <url>/2020/04/11/Linux%E5%B9%B3%E5%8F%B0%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h3 id="7z-zip格式"><a href="#7z-zip格式" class="headerlink" title="7z/zip格式"></a>7z/zip格式</h3><p><strong>安装</strong><br>安装p7zip<br>debian可以直接安装，其他系统可以使用相应命令。<br><code>sudo apt-get install p7zip-full</code></p>
<p><strong>保留完整目录结构解压7z/zip文件</strong><br><code>7z x name.7z</code></p>
<p><strong>解压带密码7z/zip文件</strong><br><code>7z x -p&quot;passwordGo&quot; name.7z</code><br>支持<code>utf-8</code>编码的中文密码，而在Windows平台压缩包其中文密码一般是<code>gbk</code>编码。</p>
<p><strong>解压<code>gbk</code>编码密码的7z/zip文件</strong><br>现有密码为<code>中文密码</code>的压缩包<code>name.7z</code>。<br>直接执行<code>7z x -p&quot;&quot; name.7z</code>报密码错，因为shell输入的<code>中文密码</code>是<code>utf-8</code>编码。<br>需要有一个编码转换的过程，可以执行命令行：<br><code>7z x -p&quot;$(echo -n 中文密码|iconv -f utf-8 -t gbk)&quot; name.7z</code><br>shell会首先执行<code>$()</code>中的命令，不换行打印中文密码<code>中文密码</code>，再将<code>uft-8</code>编码的密码转换成<code>gbk</code>编码。最后执行解压缩命令，即可成功解压。</p>
<p><strong>解压密码带有特殊字符的7z/zip文件</strong><br>现有密码为<code>letsgo!-pipixia#hahaha%wow$thatwasepic!</code>的压缩包。<br>直接执行<code>7z x -p&#39;letsgo!-pipixia#hahaha%wow$thatwasepic!&#39; name.7z</code><br>注意到<code>-p</code>后密码引号为<code>&#39;&#39;</code>。</p>
<p><strong>解压分卷7z/zip文件</strong><br>split files:    </p>
<ul>
<li>name.7z.001</li>
<li>name.7z.002</li>
<li>name.7z.003</li>
</ul>
<p>不用合并后再解压缩，任选一个解压即可。<br><code>7z x name.7z.001</code></p>
<p><strong>解压带密码分卷7z/zip文件</strong><br><code>7z x -p&quot;passwordGo!&quot; name.7z.001</code></p>
<p><strong>批量解压各自独立的7z/zip文件</strong><br><code>for i in *.7z; do 7z x -p&quot;passwordGo&quot; $i; done</code></p>
<p><strong>解压目录下所有7z/zip文件</strong><br>先使用<code>find</code>找出压缩文件，再执行解压。<br><code>find /home/AriaGo *.7z -exec 7z x -p&#39;passwordGo&#39; {} \;</code></p>
<p><strong>加密压缩</strong><br><code>7z a dstname.7z * -p&#39;password&#39;</code><br><code>*</code>是目录或文件，如<code>./image/homeland</code>,<code>./image/homeland/skyline.jpg</code></p>
<h5 id="更多详情，请参考："><a href="#更多详情，请参考：" class="headerlink" title="更多详情，请参考："></a>更多详情，请参考：</h5><blockquote>
<p><a href="https://www.cnblogs.com/itech/archive/2009/08/31/1555835.html" target="_blank" rel="noopener">https://www.cnblogs.com/itech/archive/2009/08/31/1555835.html</a><br><a href="https://blog.csdn.net/qq_28050861/article/details/103255120" target="_blank" rel="noopener">https://blog.csdn.net/qq_28050861/article/details/103255120</a></p>
</blockquote>
<h3 id="rar格式"><a href="#rar格式" class="headerlink" title="rar格式"></a>rar格式</h3><p><strong>安装</strong><br>安装unrar<br>debian可以直接安装，其他系统可以使用相应命令。<br><code>sudo apt-get install unrar</code></p>
<p><strong>按源目录结构解压</strong><br>保留源目录结构解压到工作目录。<br><code>unrar x name.rar</code></p>
<p><strong>不保留目录结构解压</strong><br>不保留源目录结构解压到工作目录。<br><code>unrar e name.rar</code></p>
<p><strong>不保留目录结构解压到指定目录</strong><br><code>unrar e name.rar /home/level1/level2</code> </p>
<p><strong>解压带密码rar文件</strong><br><code>unrar e -p&quot;passwordGo&quot; name.rar</code></p>
<p><strong>列出文件列表</strong><br><code>unrar l name.rar</code></p>
<h5 id="更多详情，请参考：-1"><a href="#更多详情，请参考：-1" class="headerlink" title="更多详情，请参考："></a>更多详情，请参考：</h5><blockquote>
<p><a href="https://www.tecmint.com/how-to-open-extract-and-create-rar-files-in-linux/" target="_blank" rel="noopener">https://www.tecmint.com/how-to-open-extract-and-create-rar-files-in-linux/</a></p>
</blockquote>
<h3 id="tar-gz格式"><a href="#tar-gz格式" class="headerlink" title="tar.gz格式"></a>tar.gz格式</h3><p><strong>压缩</strong><br><code>tar -czvf ./dstfilename.tar.gz ./srcfilname.format</code></p>
<hr>
<p><em>未完待续</em></p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>解压缩</tag>
        <tag>7z</tag>
        <tag>zip</tag>
        <tag>rar</tag>
        <tag>tar</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌云（GCP）给给未分配实例的外部IP地址分配实例</title>
    <url>/2020/04/13/%E8%B0%B7%E6%AD%8C%E4%BA%91%EF%BC%88GCP%EF%BC%89%E7%BB%99%E7%BB%99%E6%9C%AA%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%A4%96%E9%83%A8IP%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>为了给未分配实例的外部IP地址分配实例，必须要保证新的实例与该IP地址在同一地区。<br><img src="2020-04-13-%E8%B0%B7%E6%AD%8C%E4%BA%91%EF%BC%88GCP%EF%BC%89%E7%BB%99%E7%BB%99%E6%9C%AA%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%A4%96%E9%83%A8IP%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B/0x0.png" alt="pic0x0"></p>
<p>直接在新的实例中选择保留的IP地址。<br><img src="2020-04-13-%E8%B0%B7%E6%AD%8C%E4%BA%91%EF%BC%88GCP%EF%BC%89%E7%BB%99%E7%BB%99%E6%9C%AA%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%A4%96%E9%83%A8IP%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B/0x1.png" alt="pic0x1"></p>
<p>这样当我们删除一个实例，但希望把保留的IP地址应用到新的实例时，就可以很方便地操作。</p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>谷歌云</tag>
        <tag>GCP</tag>
        <tag>GCE</tag>
        <tag>VM</tag>
        <tag>外部IP地址</tag>
      </tags>
  </entry>
  <entry>
    <title>VPS测速</title>
    <url>/2020/04/13/VPS%E6%B5%8B%E9%80%9F/</url>
    <content><![CDATA[<blockquote>
<p> <strong>speedtest-cli</strong></p>
<blockquote>
<ul>
<li>下载speedtest-cli<br><code>wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py</code></li>
<li>添加可执行权限<br><code>chmod +x speedtest-cli</code></li>
<li>以默认的Mbps为单位测速<br><code>./speedtest-cli</code></li>
<li>以MB为单位测速<br><code>./speedtest-cli --byte</code></li>
<li>查看可用测速服务器<br><code>./speedtest-cli --list</code></li>
<li>选择指定服务器测速<br><code>./speedtest-cli --server NumberOfServer</code></li>
<li>获取帮助<br><code>./speedtest-cli --help</code></li>
</ul>
</blockquote>
<p> <strong>superspeed</strong></p>
<blockquote>
<ul>
<li>下载superspeed<br>. <code>wget https://raw.githubusercontent.com/oooldking/script/master/superspeed.sh</code></li>
<li>添加可执行权限<br><code>chmod +x superspeed.sh</code></li>
<li>测速<br><code>./superspeed.sh</code></li>
</ul>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
        <tag>测速</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Shell命令</title>
    <url>/2020/04/18/%E5%B8%B8%E7%94%A8Shell%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>查找当前目录及子目录特定文件（夹）并删除</strong><br><code>find . -name &quot;*.zip&quot; -type f -print -exec rm {} \;</code></p>
<ul>
<li><code>.</code>即从当前目录递归查找</li>
<li><code>-name &#39;*.zip&#39;</code>查找以<code>.zip</code>文件名结尾的对象</li>
<li><code>-type f</code>该对象为文件</li>
<li><code>-print</code>屏幕输出</li>
<li><code>-exec</code>查找之后执行</li>
<li><code>rm</code>删除<br>如果希望删除目录，可以<code>-type d</code>，其表示对象为目录。另外如果希望递归删除，可以<code>rm -r</code>。如果希望递归强制删除，可以<code>rm -rf</code>。</li>
</ul>
<p><strong>查找当前目录及子目录特定文件并移动到目标目录</strong><br><code>find . -name &quot;*.mp4&quot; -type f -print -exec mv -t /home/AriaGo/ {} +;</code></p>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows同一台计算机不同用户之间转移hexo运行环境</title>
    <url>/2020/04/15/Windows%E5%90%8C%E4%B8%80%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E4%B9%8B%E9%97%B4%E8%BD%AC%E7%A7%BBhexo%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p><strong>部署hexo的用户：A</strong><br><strong>新用户：B</strong></p>
<p>在Windows平台由A切换B之后，A配置的hexo没法直接使用。</p>
<p><strong>解决方法</strong></p>
<blockquote>
<ul>
<li>将<code>C:\Users\A\AppData\Roaming</code>下的<code>npm</code>目录拷贝到<code>C:\Users\B\AppData\Roaming</code>。<blockquote>
<p>这里是hexo的安装目录，在新用户下不用重新安装。</p>
</blockquote>
</li>
<li>将<code>C:\Users\A</code>下的<code>.ssh</code>目录拷贝到<code>C:\Users\B</code>。<blockquote>
<p>这里存放着用于连接Github的ssh公钥和私钥。</p>
</blockquote>
</li>
<li>将<code>C:\Users\A</code>下的<code>node_modules</code>目录拷贝到<code>C:\Users\B</code>。<blockquote>
<p>这里是安装node之后用来存放<code>npm</code>下载的各种包的地方，我们不用重新执行<code>npm install</code>，直接拷贝即可。</p>
</blockquote>
</li>
<li>将<code>C:\Users\B\AppData\Roaming\npm</code>添加到B的用户环境变量。<blockquote>
<p>这一步可以让我们在新用户B下直接执行<code>hexo</code>命令。</p>
</blockquote>
</li>
<li>将<code>T:\Git\root\Git\cmd</code>添加到B的用户环境变量。<blockquote>
<p>这样可以在B下执行<code>git</code>命令。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p>同一台计算机不同不同用户之间转移hexo运行环境要比不同计算机之间更加方便。</p>
<h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a><br><a href="https://zhuanlan.zhihu.com/p/35668237" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35668237</a><br><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762</a><br><a href="https://m.html.cn/qa/node-js/12146.html" target="_blank" rel="noopener">https://m.html.cn/qa/node-js/12146.html</a><br><a href="https://www.ruanyifeng.com/blog/2016/01/npm-install.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2016/01/npm-install.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #1431 拥有最多糖果的孩子（Kids With the Greatest Number of Candies）</title>
    <url>/2020/06/01/LeetCode-1431-%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90%EF%BC%88Kids-With-the-Greatest-Number-of-Candies%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组<code>candies</code>和一个整数<code>extraCandies</code>，其中<code>candies[i]</code> 代表第 <code>i</code>个孩子拥有的糖果数目。</p>
<p>对每一个孩子，检查是否存在一种方案，将额外的 <code>extraCandies</code> 个糖果分配给孩子们之后，此孩子有 <strong>最多</strong> 的糖果。注意，允许有多个孩子同时拥有 <strong>最多</strong> 的糖果数目。</p>
<p><strong>示例1：</strong></p>
<blockquote>
<p><strong>输入：</strong> candies = [2,3,5,1,3], extraCandies = 3<br><strong>输出：</strong> [true,true,true,false,true]<br><strong>解释：</strong><br>孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。<br>孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。<br>孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。<br>孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。<br>孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p><strong>输入：</strong> candies = [4,2,1,1,2], extraCandies = 1<br><strong>输出：</strong> [true,false,false,false,false]<br><strong>解释：</strong> 只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。</p>
</blockquote>
<p><strong>示例3：</strong></p>
<blockquote>
<p><strong>输入：</strong> candies = [12,1,12], extraCandies = 10<br><strong>输出：</strong> [true,false,true]</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>2 &lt;= candies.length &lt;= 100</li>
<li>1 &lt;= candies[i] &lt;= 100</li>
<li>1 &lt;= extraCandies &lt;= 50</li>
</ul>
<hr>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>没啥好说的，儿童节快乐！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = candies.length;</span><br><span class="line">        <span class="keyword">int</span> max = candies[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            max = Math.max(max, candies[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Boolean&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res.add(candies[i] + extraCandies &gt;= max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h5><blockquote>
<p><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 200. 岛屿数量</title>
    <url>/2020/04/21/LeetCode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>洪水灌溉算法经典题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。<br><strong>示例1：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>{<br>   {‘1’, ‘1’, ‘1’, ‘1’, ‘0’},<br>   {‘1’, ‘1’, ‘0’, ‘1’, ‘0’},<br>   {‘1’, ‘1’, ‘0’, ‘0’, ‘0’},<br>   {‘0’, ‘0’, ‘0’, ‘0’, ‘0’}<br>}<br><strong>输出：</strong> 1</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>{<br>  {‘1’, ‘1’, ‘0’, ‘0’, ‘0’},<br>  {‘1’, ‘1’, ‘0’, ‘0’, ‘0’},<br>  {‘0’, ‘0’, ‘1’, ‘0’, ‘0’},<br>  {‘0’, ‘0’, ‘0’, ‘1’, ‘1’}<br>}<br><strong>解释：</strong> 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li>$1 &lt;= m, n &lt;= 300$</li>
<li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li>
</ul>
<hr>
<p>遍历整个网格，从每个’1’处开始向四个方向搜索，因为’0’不需要搜索，所以’0’既可以是题目中的海水也可以记录已遍历的岛屿，这样可以省去开一个新数组。<br>每一次搜索完毕，岛屿数量加一。因为岛屿和岛屿之间必然被水淹没，不可连通。<br>可以使用DFS和BFS两种写法。<br>这是一个经典的 <strong>Flood Fill</strong> 又称 <strong>洪水灌溉</strong> 算法，在图像处理领域有很大用途，扫雷游戏也使用了这个算法。</p>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">c++</a></li><li class="tab"><a href="#g_tab0-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 16 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 9.4 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; g;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        g = grid;</span><br><span class="line">        m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    dfs(i, j);</span><br><span class="line">                    res ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        g[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[i], nec = c + dc[i];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; g[ner][nec] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                dfs(ner, nec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 2 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 40.9 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dr, dc;</span><br><span class="line">    <span class="keyword">char</span>[][] g;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        g = grid;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        dr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        dc = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    dfs(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        g[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; g[ner][nec] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                dfs(ner, nec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>在Java语言中，可以使用当前行与列 <code>i</code>, <code>j</code> 和总列数 <code>n</code> 进行hash运算，将结果入队，以代替pair.<br>encode:<br><code>int hash = i * n + j;</code><br>decode:<br><code>int i = hash / n, j = hash % n;</code></p>
<p>另外，还有个值得注意的地方就是，每次根据当前岛屿计算出四个方向的下一个岛屿时，要预先将其设置成 <code>0</code>，原因就是 <strong>防止队列中的其他和这个岛屿相邻的岛屿重复入队。</strong></p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">c++</a></li><li class="tab"><a href="#g_tab1-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 16 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 10.2 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; g;</span><br><span class="line">    <span class="keyword">int64_t</span> m, n;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        g = grid;</span><br><span class="line">        m = g.<span class="built_in">size</span>(), n = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    bfs(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;i, j&#125;);</span><br><span class="line">        g[i][j] = <span class="string">'0'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (; q.<span class="built_in">size</span>();) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = q.front().first, c = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d ++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">                <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; g[ner][nec] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    q.push(&#123;ner, nec&#125;);</span><br><span class="line">                    g[ner][nec] = <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 3 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 40.9 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dr, dc;</span><br><span class="line">    <span class="keyword">char</span>[][] g;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        g = grid;</span><br><span class="line">        dr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        dc = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        m = g.length;</span><br><span class="line">        n = g[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    bfs(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.add(i * n + j);</span><br><span class="line">        g[i][j] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; q.size() &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="keyword">int</span> hash = q.remove();</span><br><span class="line">            <span class="keyword">int</span> r = hash / n, c = hash % n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">                <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; g[ner][nec] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    g[ner][nec] = <span class="string">'0'</span>;</span><br><span class="line">                    q.add(ner * n + nec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">LeetCode 200. 岛屿数量</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>Flood Fill</tag>
        <tag>洪水灌溉算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #238 除自身以外数组的乘积（Product of Array Except Self）</title>
    <url>/2020/06/04/LeetCode-238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF%EF%BC%88Product-of-Array-Except-Self%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 n 的整数数组 <code>nums</code>，其中 n &gt; 1，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入: [1,2,3,4]<br>输出: [24,12,8,6]</p>
</blockquote>
<p><strong>提示：</strong> 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p>
<p><strong>说明:</strong> 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<p><strong>进阶：</strong> 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p>
<hr>
<h3 id="左右乘积数组"><a href="#左右乘积数组" class="headerlink" title="左右乘积数组"></a>左右乘积数组</h3><p>维护两个数组，分别存放<code>nums[i]</code>左右乘积。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                left[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; -<span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == len - <span class="number">1</span>) &#123;</span><br><span class="line">                right[j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right[j] = right[j + <span class="number">1</span>] * nums[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">            output[k] = left[k] * right[k];</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：<strong><em>O(N)</em></strong> 其中 <strong><em>O(N)</em></strong> 指的是数组 <code>nums</code> 的大小。预处理 <code>left</code> 和 <code>right</code> 数组以及最后的遍历计算都是 <strong><em>O(N)</em></strong> 的时间复杂度。</li>
<li>空间复杂度：<strong><em>O(N)</em></strong> 其中 <strong><em>O(N)</em></strong> 指的是数组 <code>nums</code> 的大小。使用了 <code>left</code> 和 <code>right</code> 数组去构造答案，<code>left</code> 和 <code>right</code> 数组的长度为数组 <code>nums</code> 的大小。</li>
</ul>
<h3 id="进一步优化-O-1-的空间复杂度"><a href="#进一步优化-O-1-的空间复杂度" class="headerlink" title="进一步优化 O(1) 的空间复杂度"></a>进一步优化 <strong><em>O(1)</em></strong> 的空间复杂度</h3><p>可以使用答案数组来替代 <code>left</code> 数组，从右向左遍历，动态更新 <code>nums[i]</code> 右侧乘积。<br>也可以使用答案数组来替代 <code>right</code> 数组，从左向右遍历，动态更新 <code>nums[i]</code> 左侧乘积。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] output = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        output[len -<span class="number">1</span> ] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            output[i] = output[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) left = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = left * nums[j - <span class="number">1</span>];</span><br><span class="line">            output[j] = left * output[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：<strong><em>O(N)</em></strong>，其中 <strong><em>O(N)</em></strong> 指的是数组 <code>nums</code> 的大小。分析与方法一相同。</li>
<li>空间复杂度：<strong><em>O(1)</em></strong>，输出数组不算进空间复杂度中，因此我们只需要常数的空间存放变量。</li>
</ul>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to Anaconda</title>
    <url>/2020/06/01/Welcome-to-Anaconda/</url>
    <content><![CDATA[<h3 id="为什么要用Anaconda"><a href="#为什么要用Anaconda" class="headerlink" title="为什么要用Anaconda"></a>为什么要用Anaconda</h3><p>Anaconda解决了官方Python的两大痛点。</p>
<ul>
<li>提供了包管理功能，Windows平台安装第三方包经常失败的场景得以解决。</li>
<li>提供环境管理的功能，功能类似Virtualenv，解决了多版本Python并存、切换的问题。</li>
</ul>
<h3 id="下载安装conda"><a href="#下载安装conda" class="headerlink" title="下载安装conda"></a>下载安装conda</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://repo.anaconda.com/archive/Anaconda3-2019.07-Linux-x86_64.sh</span><br><span class="line">bash  Anaconda3-2019.07-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<h3 id="把conda加入PATH"><a href="#把conda加入PATH" class="headerlink" title="把conda加入PATH"></a>把conda加入PATH</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> &gt;&gt;&gt; conda init &gt;&gt;&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> !! Contents within this block are managed by <span class="string">'conda init'</span> !!</span></span><br><span class="line">__conda_setup="$(CONDA_REPORT_ERRORS=false '/root/anaconda3/bin/conda' shell.bash hook 2&gt; /dev/null)"</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    \eval "$__conda_setup"</span><br><span class="line">else</span><br><span class="line">    if [ -f "/root/anaconda3/etc/profile.d/conda.sh" ]; then</span><br><span class="line">        . "/root/anaconda3/etc/profile.d/conda.sh"</span><br><span class="line">        CONDA_CHANGEPS1=false conda activate base</span><br><span class="line">    else</span><br><span class="line">        \export PATH="/root/anaconda3/bin:$PATH"</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line">unset __conda_setup</span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;&lt;&lt; conda init &lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure>

<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><blockquote>
<ul>
<li><a href="https://www.zhihu.com/question/58033789" target="_blank" rel="noopener">https://www.zhihu.com/question/58033789</a></li>
<li><a href="https://www.bobobk.com/32.html" target="_blank" rel="noopener">https://www.bobobk.com/32.html</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记</title>
    <url>/2020/06/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li><p>淫字论事不论心，论心千古无完人。孝字论心不论事，论事千古无孝子。</p>
</li>
<li><p>肉体才是人的神殿，不管里面供奉的是什么，都应该好好保持它的强韧、美丽和清洁。  ——《1Q84》村上春树</p>
</li>
<li><p>真诚感谢四步法：</p>
<blockquote>
<p>说明行为：就是说清楚对方具体帮你做了什么事；<br>说清影响：说明他帮你的这件事，为你解决了什么问题；<br>分享感受：表达受到帮助后的真实感受；<br>投桃报李：表明对方有需要的话，你也愿意尽力帮忙。</p>
</blockquote>
</li>
<li><p>彭林教授（清华大学人文学院历史系）反对父亲节、母亲节等西方节日。因为中国人是有孝道的，一年四季没有哪一天不孝，君子有终身之孝。而西方人它是没有孝道的，所以他们要找出一天来表示一下。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>圣经本土化翻译片段</title>
    <url>/2020/06/30/%E5%9C%A3%E7%BB%8F%E6%9C%AC%E5%9C%9F%E5%8C%96%E7%BF%BB%E8%AF%91%E7%89%87%E6%AE%B5/</url>
    <content><![CDATA[<p>裆里搁裆，裆里搁裆，裆里搁 裆里搁 裆里搁裆… </p>
<p>闲言碎语不要讲，表一表大卫家的小木匠。 </p>
<p>木匠名叫约瑟夫，手巧人帅脾气好，忠厚之名传家乡。</p>
<p>媒婆纷纷来拜访，许了个妹子做新娘。</p>
<p>姑娘叫做玛利亚，温柔美丽人人夸，种田做饭样样强。</p>
<p>两人恩爱深似海，订婚一年却未圆房。</p>
<p>这一天，两人约会去逛街，玛利亚却穿上了防辐射的孕妇装。</p>
<p>约瑟夫见了心不爽：莫非我娘子不贤良，暗自让我把王八当？</p>
<p>玛利亚见状忙解释：“昨晚天使托梦道端详，说我清纯美丽无人及，贞洁贤良远名扬，上帝见了心欢喜，选我做了圣子的娘 ，此儿本是上帝的种，长大必做世人的王”。</p>
<p>未出一力喜当爹，约瑟夫闻言心花放。</p>
<p>十月怀胎匆匆过，一朝分娩苦难当。</p>
<p>马槽呱呱一声啼，天使降临显圣光。</p>
<p>木匠抱起了小宝贝儿，喜上眉梢眼放光：“耶，媳妇卧槽生了个孩儿，萌的为父心酥痒，赐你小名【处生】好养活，大名【 耶稣】亮堂堂，今晚吃饱你娘的奶，明天带你拜谒祖坟烧高香~”</p>
<p>这便是：天父恩泽齐浩荡，处女生子世无双，便宜当爹约瑟夫，万古流芳绿帽王。</p>
<blockquote>
<p>作者：张寒生<br>链接：<a href="https://www.zhihu.com/question/403728436/answer/1307927525" target="_blank" rel="noopener">https://www.zhihu.com/question/403728436/answer/1307927525</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>圣经</tag>
        <tag>段子</tag>
      </tags>
  </entry>
  <entry>
    <title>曾仕强「圆通的人际关系」节目笔记</title>
    <url>/2020/06/30/%E6%9B%BE%E4%BB%95%E5%BC%BA%E3%80%8C%E5%9C%86%E9%80%9A%E7%9A%84%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB%E3%80%8D%E8%8A%82%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="第一集"><a href="#第一集" class="headerlink" title="第一集"></a>第一集</h3><ul>
<li><p>很多人用西方的标准去看中国的一切，所以在他看来中国人士乱七八糟的。更有趣的是，自五四运动以来，他们用中国的缺点和西方的优点去比，那当然中国人更糟糕。全世界它要比较的话，应该以一个较持平的标准。</p>
</li>
<li><p>西方和中国的人际关系是截然不同的。西方人与人是平等的，中国是不平等的。在中国，人人平等那就叫没大没小。</p>
</li>
<li><p>现在很多人看书，是越看越困惑越看越倒霉。是因为他们看的都是西方的书，西方的技术是可以学的，因为科学无国界。可是跟文化有关的书，你就要十分小心，一不注意就会掉到坑里去。</p>
</li>
<li><p>西方社会是「神本位」，而中国是「人本位」。西方人认为神是一切的主宰，解释一切都离不开神。而伏羲氏认为天底下最了不起的不是神，而是人。你为什么一定要把一个神弄在你上面当你的主宰呢？</p>
</li>
<li><p>中国是没有宗教的，你看所有宗教他都是外来的。中国人崇拜祖宗，叫做「祖宗崇拜」。很多人说不对呀，你看很多人在拜。你要小心了，那不是「拜神」，那是「理神」。</p>
</li>
<li><p>「神本位」必然走向个人主义（人都是上帝的子民，所以人是个人的、平等的）。西方人经常讲，这是我个人意见blabla。在中国我劝你不要这样讲，你一这样讲，人家就开始不听了。你算老几，你有什么意见？西方人说我个人意见表示我负责，在中国你说你负责你就更惨了，人家就怀疑，你能负什么责？——讲太多西方的话，吃亏的是你自己。</p>
</li>
<li><p>中国人认为人生而不平等。人生下来之前是平等的，人死了之后也是平等的，只要你活着你就不平等。中国人接受 <strong>合理的不平等</strong> ，不接受 <strong>过分的不平等</strong> ，<strong>完全的平等</strong> 我们是完全不相信的。 </p>
</li>
<li><p>中国人认为人与人之间相当地不平等，那才叫 <strong>伦理</strong> 。他是你爸爸，就永远是你爸爸，你永远讲不过他。他是你的领导就永远是你的领导，你就是讲不过他。然后你骗自己说我跟他是平等的，何必呢？</p>
</li>
<li><p>西方有人际关系，而中国有人伦关系，我们本没有人际关系，现在说人际关系其实是很勉强。中国人认为人际关系加上伦理就成了人伦关系。你看两个人在谈话，只要有第三个人插进来，我们马上就会调整，中国人的警觉性很高，还要装得没调整一样。全世界找不到像我们这样的人。</p>
</li>
<li><p>中国人都是双重标准。别人遇到什么事，他都会说，怕什么？不用怕！轮到自己，哎呀我要小心一点。</p>
<blockquote>
<p>郭德纲说：劝人大度遭雷劈。我的理解其中的一方面就是对这种双重标准的反击：哼，你自己遇到事儿怎么不大度了？</p>
</blockquote>
</li>
<li><p>中国的法律、规定都是有弹性的，没有弹性就没办法执行。所以中国人遇到事情就会讲一大堆道理，然后大事化小小事化了，小到不知道怎么办才好。</p>
</li>
<li><p>西方人与人之间，它是好奇，但他不会去关心你。在中国人与人之间，它不好奇，没有什么好好奇的，我们是 <strong>关怀</strong> 。你看西方男人和女人他们互相好奇，很快就同居，发生关系。人与人之间如果不能关怀，那产生什么关系又怎么样呢？西方人见面，Hi, Hello, GoodMorning，很有礼貌但一点也不关心你。你看中国人见面，—— 噫，你嘴巴怎么破了？ —— 上火。 二话不说把药给你吃。西方人之间的这种好奇而不关心产生了人与人之间的 <strong>距离感</strong> 。</p>
</li>
<li><p>西方才讲利害。大到国与国之间，小到人与人之间，完全讲利害关系，没有什么道义可言。真正了解中国人说我们很 <strong>势利</strong> ，我们不讲利害。这件事搞不好就让他走，这就是利害。而中国人，这件事搞不好是搞不好，但他后面有背景，我得罪他，上面会找我。我不是喜欢他，我是看到他不敢动他。上面一旦完了，我第一个动他。这就是 <strong>势利</strong> 。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>曾仕强</tag>
        <tag>哲学</tag>
        <tag>人际关系</tag>
        <tag>情商</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 101. 对称二叉树</title>
    <url>/2020/05/31/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>二叉树的对称性。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，检查它是否是镜像对称的。<br>例如，二叉树 $[1,2,2,3,4,4,3]$ 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 $[1,2,2,null,3,null,3]$ 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong><br>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<p>二叉树定义：</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></div></div>

<hr>
<p>注意判断二叉树的对称性无法使用中序遍历结果的对称性来判断。<br>比如给定一颗二叉树：$[5,4,1,null,1,null,4,2,null,2,null]$<br><img src="1.jpg" alt="0x1"><br>中序遍历结果是：<br>$[4, 2, 1, 5, 1, 2, 4]$</p>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>我们可以将对整个二叉树是否对称的判断拆分成对若干节点对是否对称的判断。这是递归思想。<br>具体地，从root节点的左右孩子节点开始，进行一次判断。条件满足的话，再深入到node1的left与node2的right、node1的right与node2的left。依次递归下去。<br>注意回溯的情况，当node1和node2都为空时，即该节点对为对称的且为末端节点，<code>return true</code>。<br>不满足上面条件时，当node1和node2有一个为空或者<code>node1.val != node2.val</code>时，必然非对称，<code>return false</code>。</p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li><li class="tab"><a href="#g_tab1-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-26 10:34:17</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        dfs(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node1, TreeNode* node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node1 &amp;&amp; !node2) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> ((!node1 &amp;&amp; node2) || (node1 &amp;&amp; !node2)) &#123;</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1-&gt;val != node2-&gt;val) &#123;</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node1-&gt;left, node2-&gt;right);</span><br><span class="line">        dfs(node1-&gt;right, node2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">     * 内存消耗 :37.9 MB, 在所有 Java 提交中击败了31.25%的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> cmp(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cmp</span><span class="params">(TreeNode node1, TreeNode node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//递归到头了，必须回溯。 不能在满足条件(node1 != null &amp;&amp; node2 != null &amp;&amp; node1.val == node2.val)时return true，因为此时需要继续向下递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span> || node1.val != node2.val) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//此时必然非对称</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> cmp(node1.left, node2.right) &amp;&amp; cmp(node1.right, node2.left); <span class="comment">//向下递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>我们可以引入一个队列，迭代判断所有节点对。<br>第一代poll root节点的左右孩子节点，判断节点状态。<br>往后每一代（如果有的话）保留了上一代判断条件得出的信息，poll出两个节点，再进行下一个判断。<br>一次又一次，迭代地进行判断。只要中间出现了一个不满足对称的情况：<br><code>node1 == null || node2 == null || node1.val != node2.val</code>，直接<code>return false</code>。<br>当所有节点入队出队迭代判断完毕均为出现非对称情况，那么可以认为二叉树是对称的。<br>注意到 <code>null</code> 节点的情况，队列应该使用 <code>LinkedList</code> 而非 <code>ArrayDeque</code> ——前者支持 <code>null</code> 元素，而后者不支持。</p>
<div class="tabs" id="g_tab2"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab2-1">C++</a></li><li class="tab"><a href="#g_tab2-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab2-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-26 11:13:35</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line">    pair&lt;TreeNode*,TreeNode*&gt; q[N];</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        q[++tt] = &#123;root-&gt;left, root-&gt;right&#125;;</span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh; ++hh) &#123;</span><br><span class="line">            TreeNode* node1 = q[hh].first;</span><br><span class="line">            TreeNode* node2 = q[hh].second;</span><br><span class="line">            <span class="keyword">if</span> (!node1 &amp;&amp; !node2) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((!node1 &amp;&amp; node2) || (node1 &amp;&amp; !node2)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;val != node2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q[++tt] = &#123;node1-&gt;left, node2-&gt;right&#125;;</span><br><span class="line">            q[++tt] = &#123;node1-&gt;right, node2-&gt;left&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab2-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *执行用时 :1 ms, 在所有 Java 提交中击败了37.93%的用户</span></span><br><span class="line"><span class="comment">     *内存消耗 :39.8 MB, 在所有 Java 提交中击败了5.00%的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node1 = queue.poll();    </span><br><span class="line">            TreeNode node2 = queue.poll();  </span><br><span class="line">            <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) <span class="keyword">continue</span>; <span class="comment">//继续迭代判断</span></span><br><span class="line">            <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span> || node1.val != node2.val) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//必然非对称</span></span><br><span class="line">            queue.offer(node1.left);</span><br><span class="line">            queue.offer(node2.right);</span><br><span class="line">            queue.offer(node1.right);</span><br><span class="line">            queue.offer(node2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//当所有节点入队出队结束，均未出现非对称情况，结果显然是对称的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">LeetCode 101. 对称二叉树</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>fix Intellj IDEA git pust rejected</title>
    <url>/2020/07/25/fix-Intellj-IDEA-git-pust-rejected/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>IntelliJ IDEA</tag>
        <tag>git</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title>驾驶技术学习心得</title>
    <url>/2020/08/17/%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h2><blockquote>
<p>项目开始前准备：<br>系好安全带，放下手刹，踩下刹车，启动引擎，踩下离合器。</p>
</blockquote>
<hr>
<h3 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h3><p><img src="2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/%E5%80%92%E8%BD%A6%E5%85%A5%E5%BA%93.png" alt="pic0x0"><br><strong>左倒库：</strong> </p>
<ul>
<li>step 1: 挂1挡，轻踩离合至左后视镜看到L1角，方向盘向左打满。</li>
<li>step 2: 车身垂直于A线方向盘回正。</li>
<li>step 3: 行驶至胳膊超过A线离合刹车踩满停下，准备左倒车入库。</li>
<li>step 4: 挂倒挡，轻踩离合当车辆倒至左后视镜下边缘与A线重合，方向盘向左打满。</li>
<li>step 5: 此时注意左后视镜L1角，当L1角出现时，注意它和车身距离。大于30cm则车辆位置正确；小于则转角过大，方向盘向右回一圈减小转角。</li>
<li>step 6: 此时注意观察右后视镜，观察当R2角出现时，方向盘迅速回正，此时注意到车身和R线平行。</li>
<li>step 7: 继续倒车直至左后视镜下边缘与L1角重合。</li>
</ul>
<p><strong>右倒库：</strong></p>
<ul>
<li>step 1: 挂1挡，轻踩离合至左后视镜看到L1角，方向盘向右打满。</li>
<li>step 2: 车身垂直于B线方向盘回正。</li>
<li>step 3: 行驶至胳膊超过B线离合刹车踩满停下，准备右倒车入库。</li>
<li>step 4: 挂倒挡，轻踩离合当车辆倒至左后视镜下边缘与B线重合，方向盘向右打满。</li>
<li>step 5: 此时注意观察右后视镜R1角，当R1角出现时，注意它和车身距离。大于30cm则车辆位置正确；小于则转角过大，方向盘向左回一圈减小转角。</li>
<li>step 6: 此时注意左后视镜，观察当L2角出现时，方向盘迅速回正，此时注意到车身和L线平行。</li>
<li>step 7: 继续倒车直至左后视镜下边缘与L1角重合。</li>
</ul>
<h3 id="侧方位停车"><a href="#侧方位停车" class="headerlink" title="侧方位停车"></a>侧方位停车</h3><p><img src="2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/%E4%BE%A7%E6%96%B9%E5%81%9C%E8%BD%A6.png" alt="pic0x1"><br><strong>将车开出车库至准备区域：</strong></p>
<ul>
<li>step 1: 挂1挡，踩离合，打左转向灯，方向盘向左打满。</li>
<li>step 2：注意观察左后视镜，当B角出现时，回正方向盘。</li>
<li>step 3：让车辆继续缓缓行驶，注意观察左后视镜，当左前门门把手与车库虚线重合时，方向盘向右打满。</li>
<li>step 4：观察右后视镜，当车右侧与虚线平行时，车身已正，方向盘回正。</li>
<li>step 5：观察右后视镜，当A角出现时，停车。</li>
</ul>
<p><strong>右侧方停车：</strong></p>
<ul>
<li>step 1：挂倒挡，观察右后视镜，当A直角消失，方向盘又打满。</li>
<li>step 2：注意观察左后视镜，当B直角出现，方向盘回正。</li>
<li>step 3：注意观察左后视镜，当左后轮即将碰到车库虚线时，方向盘左打满。</li>
<li>step 4：注意观察右后视镜，当车右侧与车库边线平行时，车身已正。停车。</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>驾驶技术</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 102. 二叉树的层序遍历</title>
    <url>/2020/08/21/LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>二叉树基础。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例：<br>二叉树：$[3,9,20,null,null,15,7]$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其层序遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>二叉树定义：</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></div></div>

<hr>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>直接队列BFS。</p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-26 09:55:29</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()&#123;</span><br><span class="line">     <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"> &#125;();</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line">    TreeNode* q[N];</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        q[++tt] = root;</span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh;) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> len = tt - hh + <span class="number">1</span>; len; len--, hh++) &#123;</span><br><span class="line">                TreeNode* node = q[hh];</span><br><span class="line">                level.emplace_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                    q[++tt] = node-&gt;left;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                    q[++tt] = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            res.emplace_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>可以在dfs函数中维护一个 <code>level</code> 变量，递归遍历这颗二叉树，将每个节点值放入到对应层的数组中。</p>
<div class="tabs" id="g_tab2"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab2-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab2-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-26 10:11:16</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()&#123;</span><br><span class="line">     <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"> &#125;();</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() &lt;= level) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lvl;</span><br><span class="line">            res.push_back(lvl);</span><br><span class="line">        &#125;</span><br><span class="line">        res[level].push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">            dfs(node-&gt;left, level + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            dfs(node-&gt;right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LeetCode 102. 二叉树的层序遍历</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>沟通的艺术</title>
    <url>/2020/08/01/%E6%B2%9F%E9%80%9A%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="沟通的基本功"><a href="#沟通的基本功" class="headerlink" title="沟通的基本功"></a>沟通的基本功</h3><blockquote>
<ul>
<li>聪明的脑子和活跃的思维<blockquote>
<p>十八核大脑不是盖的，你能透彻地理解对方说的意思，甚至包括言外之意；你能清晰地明白对方语句间的逻辑关系，哪怕他的逻辑存在漏洞你也能够指出；你能设身处地地理解周围所有人的感受，无缝切换各个角色轻松地实现换位思考；你能一定程度上预判对面将要说的话，从而为将来的谈话提前做好准备；</p>
</blockquote>
</li>
<li>敏锐的洞察力（察言观色）</li>
<li></li>
</ul>
</blockquote>
<h3 id="话题穿插切换"><a href="#话题穿插切换" class="headerlink" title="话题穿插切换"></a>话题穿插切换</h3><p>如果对方对和你要聊的话题并无兴趣的话，这时就需要切换话题，把话题转移到另一个方向去。<br><strong>常见话题切换语句</strong></p>
<blockquote>
<ul>
<li>你知道么，其实。。。<blockquote>
<p>举例：你知道么，今天你跟平常不太一样。。。</p>
</blockquote>
</li>
<li>我觉得。。。</li>
<li>对了。。。</li>
</ul>
</blockquote>
<h3 id="1个核心思维模式：「把对方当主角」"><a href="#1个核心思维模式：「把对方当主角」" class="headerlink" title="1个核心思维模式：「把对方当主角」"></a>1个核心思维模式：「把对方当主角」</h3><p>把对方当成聊天的主角，每一步聊天，都围绕着对方，使其感受到「主角」般的爽感，谁都是希望自己被重视，被宠着的。<br>现在，请你在心里默念三遍：<br><strong>TA才是聊天的主角，我要宠着惯着！</strong><br><strong>TA才是聊天的主角，我要宠着惯着！</strong><br><strong>TA才是聊天的主角，我要宠着惯着！</strong></p>
<h3 id="打招呼"><a href="#打招呼" class="headerlink" title="打招呼"></a>打招呼</h3><blockquote>
<p>当然首先还是吸引对方的注意，不然的话，你跟对方打招呼结果他没注意到，那就尴尬了哈哈。<br>其次呢，神情自然大方地去释放你阳光的情绪吧。<br>微笑是最能感染人的，但是别皮笑肉不笑那种。用你的眼神去“微笑”，一个温柔的眼神胜过千言万语。眼睛一定要看着对方哦，瞳孔适当放大。<br>打招呼也有intro和outro的，outro可以用关怀的态度，还是把对方当主角宠。比如：注意安全喔、玩的开心喔，等等，当然，最简单的还是拜拜。</p>
</blockquote>
<h3 id="怎样说话让对面很容易接下去"><a href="#怎样说话让对面很容易接下去" class="headerlink" title="怎样说话让对面很容易接下去"></a>怎样说话让对面很容易接下去</h3><p><strong>在对方给的回答上做文章，谈谈自己的感受，并抛出一个或多个话题。</strong><br>其实如果你是个接话高手，那么只需要在接住话之后稍加 <strong>感受</strong>，再次将话题回到对方身上即可。</p>
<h3 id="沟通前的准备"><a href="#沟通前的准备" class="headerlink" title="沟通前的准备"></a>沟通前的准备</h3><blockquote>
<p><strong>step 1:</strong> 观察。我认为，沟通之前应该迅速判断对面有没有和你沟通的意愿。所以沟通前第一件事，就是用眼观察对方。这一步需要在一瞬间内完成。<br><strong>step 2:</strong> 观察。对的，第二步还是观察，只不过这一步观察对方的状态，根据这一状态可以自然而然开启沟通。<br><strong>step 3:</strong> 营造氛围。这一步开始营造聊天氛围。和人聊天，过了很久之后，具体说些啥，对方可能不会再记起，但是你们聊天的氛围、双方的感受是很难忘却的，特别是当这是一种特别舒服或者特别尴尬的时候。两人见面，不管是两者关系如何，这都不重要，重要的是你对氛围的把控。即便是双方不熟，只要把握好聊天氛围，一样可以有话聊。<br>聊天氛围客观描述：</p>
<blockquote>
<ul>
<li>你自己在即将展开的聊天中扮演什么样的角色，塑造什么样的形象。<br>例1：<strong>自己处于弱势时，可以塑造大方乐观的形象。</strong> 今天和对方在家乐福门口见面，我俩都是从健身房出来，他带了伞，我没带伞，外面下着雨。他有伞我没有，自己处于弱势地位（这里的地位强弱不是说要去竞争什么），这时候你可以营造出一种自己乐观大度的形象：这些雨不算什么，我等会儿再走即可。这样聊天的基调就有了，你对将要发生的谈话已经有了一个非常十足的把握。和谐的氛围油然而生。具体说些啥，这些都不是很重要了。无非就是先寒暄，再顺着你准备的氛围说下去。<br>例2：<strong>塑造赞美者的形象</strong> 今天遇到同事或者同学或者一起健身的朋友，你发现对面穿了一件骚气的衣服，你可以把自己塑造成一个赞美者的形象，其实赞美是一门很深的学问，力度不够，会让人觉得肤浅做作；力度太大会变成讥笑，中国人是最敏感的；力度更大，就成了马屁精，或者舔狗。夸细节啊真诚啊啥的，这些都是最基本的东西，所有人都知道。<br>夸得别人舒服，营造马屁味道，这是需要长期磨炼反思的。人情练达即文章，我现在也不是很在行，以后慢慢补充。<br>例3：____</li>
<li></li>
<li><strong>step 4:</strong> 寒暄。此时开始聊天，在正式聊天前，会有一个intro，这是从不说话到正式聊天之间的一个平稳的过度，让对面做好准备，意思是说，我们要开始聊天了，双方都准备一下。<br>寒暄嘛，都是些无关痛痒的废话。它是根据两人 <strong>关系</strong> 来的。<br>中国人寒暄的时候，关系一般或者不熟可以问对方刚发生的事情。你可以问对方吃了吗？刚健完身啊？刚放学啊？刚下班啊？等等<del>我们一般寒暄的时候会根据对方的状态问一下刚发生的事情，这些事情必须是无关痛痒的。但你不要哪壶不开提哪壶，揭人伤疤啥的。一般也不要问对方将要去做什么，因为有些人很在意这些，你问他要去做啥，他可能不想告诉你，会认为你居心叵测，打探隐私。<br>例1： 噫</del>你也从这边走 or 噫<del>好巧啊，在这遇到你 or 噫</del>你也刚下来么 or 噫~很少在这碰到你等等。<br>关系是熟人或者很好，这个时候你再像上面这样寒暄就会拉开距离，千万注意。这时候，你就单刀直入，可以从 <strong>关怀</strong> 的角度入手。不管关系好坏，关怀可以通吃。<br>例2：</li>
</ul>
</blockquote>
</blockquote>
<h3 id="话轮技术"><a href="#话轮技术" class="headerlink" title="话轮技术"></a>话轮技术</h3><p>话轮技术：一个原则，三条注意事项<br>效果：一个人掌握话轮，就可以让交谈的双方获益<br>一、相当原则：双方说话时长相当，注意力投入相当，地位相当。<br>（一）第一不要说太多也不要听太多，公式化表达：表述自身资源和观点，再以好奇心抛出一个半开放性问题。<br>（二）第二不要高姿态也不要低姿态。减少那些只能靠“是、否”就能回答的问题，不要让人觉得你太强势，姿态高。交流时也不要让出所有的选择权，适当表达是礼貌，但过度就是姿态低。有时候“我不这么想”可以进一步让沟通继续。<br>（三）第三保持高投入，也引导对方高投入。有资源的炫耀和没资源的胡扯都会让人反感。请注意在你的话里表达观点，而不是太多内容。<br>二、注意避免话轮被打断。<br>请尽量减少外界的干扰和潜在的干扰：约会环境要单一，不要嘈杂；选择无意识加工就能完成的事情，比如一起吃个饭、散个步。约会时请把手机收起来。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>人际关系</tag>
        <tag>情商</tag>
        <tag>生活</tag>
        <tag>沟通</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 111. 二叉树的最小深度</title>
    <url>/2020/08/21/LeetCode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>树的深度计算。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明: 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最小深度  2.</p>
<p>二叉树定义：</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></div></div>

<hr>
<p>本题考查树深度，考虑到树结构的递归特性，可以很容易利用递归去计算。</p>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>当<code>root</code>节点左右孩子都非空时，二叉树深度最小当且仅当<code>root</code>的左右孩子节点深度取最小。另外，<code>root</code>为空或者<code>root</code>的左或右孩子节点为空的情况可以很容易判断。</p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li><li class="tab"><a href="#g_tab1-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-25 15:21:19</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lheight = minDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rheight = minDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">        <span class="keyword">if</span> ((!lheight &amp;&amp; !rheight) || (lheight &amp;&amp; rheight)) &#123;   <span class="comment">// 在某个节点的左右子树都有深度或者都没有深度的情况下，取较小的</span></span><br><span class="line">            <span class="built_in">height</span> = <span class="built_in">min</span>(lheight, rheight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;                                                 <span class="comment">// 否则，左右子树有一个没有深度，那么就不能取较小的，而是取较大的</span></span><br><span class="line">            <span class="built_in">height</span> = <span class="built_in">max</span>(lheight, rheight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;                                <span class="comment">// 左边没有深度，右边有深度，不能取较小的，而是取右边的深度</span></span><br><span class="line">            <span class="keyword">return</span> dfs(node.right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;                               <span class="comment">// 右边没有深度，左边有深度，不能取较小的，而是取左边的深度</span></span><br><span class="line">            <span class="keyword">return</span> dfs(node.left) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dfs(node.left), dfs(node.right)) + <span class="number">1</span>;   <span class="comment">// 左右都有深度，取较小的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>另外，我们亦可维护一个 <strong>最小值变量</strong>，通过不断和其比较最终得出最小深度。该方法参考官方题解。<br>注意这个最小值变量不是全局的，而是对于某一层递归产生一个最小值，即左右子树深度和该最小值比较返回至上一层。</p>
<div class="tabs" id="g_tab2"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab2-1">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab2-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min_depth = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.left), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min_depth = Math.min(minDepth(root.right), min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>; <span class="comment">//+1为root节点自身深度。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>可以使用 <strong>逐层遍历</strong> 方法找到树最小深度。树具有最小深度当且仅当某一层的某节点无左右孩子节点。</p>
<div class="tabs" id="g_tab3"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab3-1">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab3-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>) &#123;  <span class="comment">//size &gt; 0保证一行可以被完全访问</span></span><br><span class="line">                TreeNode cur_node = queue.poll();</span><br><span class="line">                size--;</span><br><span class="line">                TreeNode left = cur_node.left;</span><br><span class="line">                TreeNode right = cur_node.right;</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//while size == 0, column over</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>亦可自定义包含深度信息的节点类，此方法参考官方题解。</p>
<div class="tabs" id="g_tab4"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab4-1">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab4-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QueueNode</span> </span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> depth;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">QueueNode</span><span class="params">(TreeNode node, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.depth = depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;QueueNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;QueueNode&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> QueueNode(root, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            QueueNode nodeDepth = queue.poll();</span><br><span class="line">            TreeNode node = nodeDepth.node;</span><br><span class="line">            <span class="keyword">int</span> depth = nodeDepth.depth;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> QueueNode(node.left, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> QueueNode(node.right, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCode 111. 二叉树的最小深度</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>爱的魔力转圈圈：仿shell风火轮进度条实现</title>
    <url>/2020/08/22/%E7%88%B1%E7%9A%84%E9%AD%94%E5%8A%9B%E8%BD%AC%E5%9C%88%E5%9C%88%EF%BC%9A%E4%BB%BFshell%E9%A3%8E%E7%81%AB%E8%BD%AE%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>今天在shell上安装Anaconda的时候，发现安装过程中的「风火轮」进度条很有趣，于是就简单实现了一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">icon = [<span class="string">'\\'</span>, <span class="string">'-'</span>, <span class="string">'/'</span>]</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">40</span>):</span><br><span class="line">    print(<span class="string">'\rAll work and no play make Jack a dull boy: &#123;&#125;'</span>.format(icon[m % <span class="number">3</span>]), end=<span class="string">''</span>)</span><br><span class="line">    time.sleep(<span class="number">0.25</span>)  <span class="comment"># -- control the r.p.m</span></span><br></pre></td></tr></table></figure>
<p>无非就是把<code>print</code>函数的<code>end=&#39;\n&#39;</code>换成<code>end=&#39;&#39;</code>以便每次打印光标可以回到行首。再就是循环<code>icon</code>列表，制造「动画效果」。<br>比如你要倒计时10s，每0.25s输出一帧，那么就要输出40帧。每一帧依次选取列表的下标可以用m对列表长度取余。</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
      </categories>
      <tags>
        <tag>进度条</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 110. 平衡二叉树</title>
    <url>/2020/08/18/LeetCode-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>还是和树深度有关。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：<br> 一个二叉树 <em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p>
<p><strong>示例 1:</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回 <code>true</code> 。</p>
<p><strong>示例 2:</strong><br>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>
<p>返回 <code>false</code> 。</p>
<p>二叉树定义:</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></div></div>
<hr>
<p>本题绕不开树的高度计算，用到了递归思想（DFS）。从<code>root</code>节点开始向下依次计算每个节点高度，高度为左右孩子节点的高度较大的那个加一，当节点为<code>null</code>时，认为高度为零。</p>
<h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>从<code>root</code>节点开始，比较左右孩子高度差，接着递归比较左右孩子的左右孩子。当出现不平衡条件返回<code>false</code>，一旦某一个子节点出现<code>false</code>，则整个结果是<code>false</code>。<br>不推荐该方法，因为对于每个节点需要递归计算高度，复杂度太高。</p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(height(root.left) - height(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height(p.left), height(p.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>注意到在计算高度时仍然需要递归，所以这种方法会造成重复遍历。</p>
<h3 id="解法二：自底向上DFS（后序遍历）"><a href="#解法二：自底向上DFS（后序遍历）" class="headerlink" title="解法二：自底向上DFS（后序遍历）"></a>解法二：自底向上DFS（后序遍历）</h3><p>在计算高度的同时可以对平衡性进行判断。一旦出现不平衡情况，直接逐层返回一个特殊值。<br>这是我的原始代码：</p>
<div class="tabs" id="g_tab2"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab2-1">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab2-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (height(root) == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height_left = height(p.left);</span><br><span class="line">        <span class="keyword">if</span> (height_left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> height_right = height(p.right);</span><br><span class="line">        <span class="keyword">if</span> (height_right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(height_left - height_right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height_left, height_right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>优化一下：</p>
<div class="tabs" id="g_tab3"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab3-1">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab3-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height_left = height(p.left);</span><br><span class="line">        <span class="keyword">if</span> (height_left == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height_right = height(p.right);</span><br><span class="line">        <span class="keyword">if</span> (height_right == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(height_left - height_right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height_left, height_right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>三个<code>return -1</code>的情况可以合并：</p>
<div class="tabs" id="g_tab4"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab4-1">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab4-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> height_left = height(p.left);</span><br><span class="line">        <span class="keyword">int</span> height_right = height(p.right);</span><br><span class="line">        <span class="keyword">if</span> (height_left == -<span class="number">1</span> || height_right == -<span class="number">1</span> || Math.abs(height_left - height_right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height_left, height_right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>可以不用以返回特殊值<code>-1</code>的方式判断不平衡状态，而是定义一个全局变量<code>res</code>：</p>
<div class="tabs" id="g_tab5"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab5-1">C++</a></li><li class="tab"><a href="#g_tab5-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab5-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-25 17:45:51</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> * 时隔若干月，回头做这道题，一下就用了最优的方法，印象还在。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            l = dfs(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (!res) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            r = dfs(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (!res) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(r - l) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab5-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = helper(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = helper(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left-right) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            res = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">LeetCode 110. 平衡二叉树</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 559 N叉树的最大深度（Maximum Depth of N-ary Tree）</title>
    <url>/2020/08/31/LeetCode-559-N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88Maximum-Depth-of-N-ary-Tree%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个 N 叉树，找到其最大深度。<br>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。<br>例如，给定一个 <code>3叉树</code> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       1</span><br><span class="line">   &#x2F;   |   \</span><br><span class="line">  3    2    4</span><br><span class="line"> &#x2F; \   </span><br><span class="line">5   6</span><br></pre></td></tr></table></figure>
<p>我们应返回其最大深度，3。<br>说明:</p>
<blockquote>
<p>1.树的深度不会超过 1000。<br>2.树的节点总不会超过 5000。</p>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>没啥可说的，和「LeetCode-104-二叉树的最大深度（Maximum-Depth-of-Binary-Tree）」对比，无非就是取最大值的不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.children.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; heights = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Node item : root.children) &#123;</span><br><span class="line">        heights.add(maxDepth(item)); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Collections.max(heights) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，亦可维护一个「最大值变量」，children的每个元素，和它作比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本方法参考HJF的题解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">            result = Math.max(result, <span class="number">1</span> + maxDepth(child));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>可以由DFS递归改成迭代，同时维护一个最大值变量，每次出队需要将节点的深度信息和最大值变量作比较。所以节点需要携带深度信息。可以借助<code>pair</code>，也可以写一个新的节点类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本方法参考官方题解</span></span><br><span class="line"><span class="keyword">import</span> javafx.util.Pair;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Pair&lt;Node, Integer&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.add(<span class="keyword">new</span> Pair(root, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      Pair&lt;Node, Integer&gt; current = stack.poll();</span><br><span class="line">      root = current.getKey();</span><br><span class="line">      <span class="keyword">int</span> current_depth = current.getValue();</span><br><span class="line">      <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        depth = Math.max(depth, current_depth);</span><br><span class="line">        <span class="keyword">for</span> (Node c : root.children) &#123;</span><br><span class="line">          stack.add(<span class="keyword">new</span> Pair(c, current_depth + <span class="number">1</span>));    </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题亦可使用BFS，但是我不想写了。</p>
<p><strong>题目链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/</a><br><strong>官方题解：</strong> <a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/solution/ncha-shu-de-zui-da-shen-du-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/solution/ncha-shu-de-zui-da-shen-du-by-leetcode/</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>树</tag>
        <tag>N叉树</tag>
        <tag>树深度</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 104. 二叉树的最大深度</title>
    <url>/2020/08/21/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>另一道树深度题目。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<p>二叉树定义：</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></div></div>

<hr>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>和最小深度不同，当节点仅有左孩子或右孩子，可以直接比较取二者最大值。代码更简单：</p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">c++</a></li><li class="tab"><a href="#g_tab1-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []() &#123;</span><br><span class="line">     <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"> &#125;();</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>逐层遍历，每层遍历完之后，深度加一，当整个树遍历完，返回深度。</p>
<div class="tabs" id="g_tab2"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab2-1">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab2-1"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>注意和<a href="https://eetoa.github.io/2020/08/21/LeetCode-111-二叉树的最小深度/" target="_blank" rel="noopener">LeetCode 111. 二叉树的最小深度</a>比较学习。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCode 104. 二叉树的最大深度</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法模板</title>
    <url>/2020/10/24/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>详尽地记录了各种基础算法模板，以及一些个人理解。</p>
<a id="more"></a>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快排最难的地方在于边界问题。边界问题涉及到比较因子的选择以及各种条件判断。建议将模板直接背过。<br>今天看了闫学灿的快排讲解之后，感悟颇多，特地记录下来供以后复习。<br>首先上快排模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>; <span class="comment">//end of recursion</span></span><br><span class="line">    <span class="keyword">int</span> cmp = q[(lo + hi) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = lo - <span class="number">1</span>, j = hi + <span class="number">1</span>; <span class="comment">// 每次指针移动，需要向中间偏移一位，故在这里也初始化设置成lo - 1和hi + 1</span></span><br><span class="line">    <span class="keyword">for</span> (;i &lt; j;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; q[++ i] &lt; cmp; );</span><br><span class="line">        <span class="keyword">for</span> (; q[-- j] &gt; cmp; );</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    qSort(q, lo, j); <span class="comment">//                         1</span></span><br><span class="line">    qSort(q, j + <span class="number">1</span>, hi); <span class="comment">//                     2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>j</code> 要么等于 <code>i</code> 要么 <code>j</code> 在 <code>i</code> 左边一位，故其中 <code>1</code> 和 <code>2</code> 可以改成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, i - <span class="number">1</span>); </span><br><span class="line">qSort(q, i, hi);</span><br></pre></td></tr></table></figure>
<p>但是注意，如果 <code>cmp</code> 设置成 <code>q[lo]</code> 的话，则只能是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, j); </span><br><span class="line">qSort(q, j + <span class="number">1</span>, hi);</span><br></pre></td></tr></table></figure>
<p>因为如果换成了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, i - <span class="number">1</span>); </span><br><span class="line">qSort(q, i, hi);</span><br></pre></td></tr></table></figure>
<p>的话会出现死循环问题。<br>举个例子：数组<code>{1, 2}</code>排序，<code>lo = 0, hi = 1, i = -1 , j = 2, cmp = 1</code>.<br>第一轮递归，<code>i = 0, j = 0</code>.<br><code>qSort(q, 0, -1);</code>  直接return.<br><code>qSort(q, 0, 1);</code>   死循环.</p>
<p>同理，如果 <code>cmp</code> 设置成 <code>q[hi]</code> 的话，使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, j); </span><br><span class="line">qSort(q, j + <span class="number">1</span>, hi);</span><br></pre></td></tr></table></figure>
<p>也会发生死循环.</p>
<p>所以：<br><strong><code>cmp</code> 设置成 <code>q[lo]</code> 的话，递归调用必须是：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, j); </span><br><span class="line">qSort(q, j + <span class="number">1</span>, hi);</span><br></pre></td></tr></table></figure>
<p><strong><code>cmp</code> 设置成 <code>q[hi]</code> 的话，递归调用必须是：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qSort(q, lo, i - <span class="number">1</span>); </span><br><span class="line">qSort(q, i, hi);</span><br></pre></td></tr></table></figure>
<p>为了保险起见，建议将 <code>cmp</code> 设置成中间位置。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是将原数组递归地一分为二，在最短子数组处完成排序，在回溯过程中合并子数组，以完成整个数组的排序。<br>过程感觉很像二叉树的遍历。<br>以下是归并排序模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000010</span>;                                     <span class="comment">// test data amount range</span></span><br><span class="line"><span class="keyword">int</span> q[N];                                                   <span class="comment">// original array</span></span><br><span class="line"><span class="keyword">int</span> tmp[N];                                                 <span class="comment">// temporary array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;                                   <span class="comment">// end of recursion</span></span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;                               </span><br><span class="line">    merge_sort(q, lo, mid), merge_sort(q, mid + <span class="number">1</span>, hi);     <span class="comment">// recursively divides into two</span></span><br><span class="line">    <span class="comment">// backtrack progress</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;                                 </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;                                              <span class="comment">// index of temporary array            </span></span><br><span class="line">    <span class="keyword">for</span> (;i &lt;= mid &amp;&amp; j &lt;= hi;)                             <span class="comment">// puts smaller one into tmp[]</span></span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[t++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[t++] = q[j++]; </span><br><span class="line">    <span class="keyword">for</span> (;i &lt;= mid;) tmp[t++] = q[i++];                     <span class="comment">// puts remaining array into tmp[]</span></span><br><span class="line">    <span class="keyword">for</span> (;j &lt;= hi;) tmp[t++] = q[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo, j = <span class="number">0</span>; i &lt;= hi;) q[i++] = tmp[j++];    <span class="comment">// overrides original array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为一分为二的过程一共持续 <strong><em>log(N)</em></strong> 次（以2为底）,把数放入 <code>tmp[]</code> 再覆盖原数组需要 <strong><em>O(N)</em></strong>。<br>故时间复杂度为 <strong><em>ONlog(N)</em></strong> </p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="整数二分查找"><a href="#整数二分查找" class="headerlink" title="整数二分查找"></a>整数二分查找</h3><p>一般涉及到单调性的问题，查找某个边界，可以使用二分查找。但是二分查找不仅仅只适用于单调性问题。<br>即：<br>单调性问题查找一定可以用二分，非单调性问题也有可能可以用二分。<br>二分查找的本质目的是：<br><strong>在一个整数区间上，前一段满足某种性质A，后一段满足另一性质B。使用二分查找找到满足性质A的边界点edgeA或者满足性质B的边界点edgeB。</strong><br><code>____________Satisfied A______________| |___________Satisfied B________________</code><br>整个查找过程围绕 <strong>性质</strong> 展开，不断更新<code>mid</code>值，从两个方向逼近边界。但是请注意，这个 <strong>性质</strong> 并非必然和目标值有关。找目标值，在考虑性质的时候，不一定从目标值入手（这一点非常重要，请仔细体会）。</p>
<p><strong>找A的边界，mid从A向右更新</strong><br>当<code>mid</code>满足条件A时，A的边界至少可以取到<code>mid</code>；<br><strong>找B的边界，mid从B向左更新</strong><br>当<code>mid</code>满足条件B时，B的边界最多可以取到<code>mid</code>；</p>
<p>整数二分查找模板：<br><strong>查找A边界</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// finds edge A</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_satisfied_A</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/*---*/</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_satisfied_B</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/*---*/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;lo &lt; hi;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;                      <span class="comment">//  1</span></span><br><span class="line">        <span class="keyword">if</span> (is_satisfied_B(mid)) hi = mid;</span><br><span class="line">        <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找B边界</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// finds edge B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_satisfied_A</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/*---*/</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_satisfied_B</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/*---*/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;lo &lt; hi;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;                   <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (is_satisfied_A(mid)) lo = mid;</span><br><span class="line">        <span class="keyword">else</span> hi =  mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：2处为了防止边界问题，需要在计算mid的时候加一。</strong></p>
</blockquote>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://eetoa.github.io/2021/02/07/AcWing-789-数的范围/" target="_blank" rel="noopener">数的范围</a><br><a href="http://eetoa.github.io/2021/02/26/LeetCode-153-寻找旋转排序数组中的最小值/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a></p>
</blockquote>
<h3 id="浮点数二分查找"><a href="#浮点数二分查找" class="headerlink" title="浮点数二分查找"></a>浮点数二分查找</h3><h4 id="根据精度迭代"><a href="#根据精度迭代" class="headerlink" title="根据精度迭代"></a>根据精度迭代</h4><p>因为是找浮点数，所以可以不用考虑边界问题。<br><strong>例子：</strong><br>求数字x的开方。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">double</span> lo = <span class="number">0</span>, hi = <span class="built_in">max</span>(<span class="number">1</span>, x);                      <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> (;hi - lo &gt; <span class="number">1e-8</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &gt;= x) hi = mid;</span><br><span class="line">        <span class="keyword">else</span> lo = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, lo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意1处当<code>x&lt;1</code>时，右边界是1。因为小于1的数，开方比自己大。<code>x&gt;1</code>时，右边界当然可以取到<code>x</code>。<br>题目中一般会给出<code>x</code>的取值范围，如 <code>-10000 &lt; x &lt; 10000</code>，那么<code>lo</code>和<code>hi</code>可以分别初始化为<code>-10000</code>和<code>10000</code>。<br>根据经验，如果题目要求保留<code>n</code>位有效数字，那么一般<code>lo</code>和<code>hi</code>之间判定的精度为<code>1e-(n + 2)</code>。</p>
<h4 id="根据循环次数迭代"><a href="#根据循环次数迭代" class="headerlink" title="根据循环次数迭代"></a>根据循环次数迭代</h4><p>这是浮点数二分的另一种写法，直接循环个<code>100</code>次。<br>如上题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">double</span> lo = <span class="number">0</span>, hi = <span class="built_in">max</span>(<span class="number">1</span>, x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &gt;= x) hi = mid;</span><br><span class="line">        <span class="keyword">else</span> lo = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, lo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这相当于把lo到hi范围缩小2的100次方倍。（100次2分）<br>因为2的100次幂足够大，所以结果是正确的。</p>
<h2 id="高精度四则运算"><a href="#高精度四则运算" class="headerlink" title="高精度四则运算"></a>高精度四则运算</h2><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><p>两个 <strong>超长位数正整数</strong> 相加，一般是以 <strong>字符串</strong> 形式读取整数，再把整数放入 <strong>数组</strong> 中，进行模拟加法运算。<br><strong>模板1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span>                             <span class="comment">//1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i++)                      <span class="comment">//2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(<span class="number">1</span>);                                                  <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = add(A, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">cout</span> &lt;&lt; C[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释：</p>
<blockquote>
<ol>
<li>以数组引用传入参数，可以避免没必要的数组拷贝。</li>
<li><code>A</code>或<code>B</code>至少有一个没有遍历完，都需要继续计算。</li>
<li>注意结束之后进位有可能非0.</li>
</ol>
</blockquote>
<p>该模板可以改写成总是模拟以一个更长的数组加长度较小的数组：<br><strong>模板2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> add(B, A);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，就可以只考虑遍历较长数组，只进行一次长度判断。</p>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://eetoa.github.io/2020/11/08/AcWing-791-高精度加法/" target="_blank" rel="noopener">高精度加法</a></p>
</blockquote>
<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p>两个超长正整数相减。因为结果可能为负数，负数的时候输出需要在最前面补<code>&#39;-&#39;</code>。<br><code>A B</code>相减最核心的部分，<code>A</code>总是大于等于<code>B</code>的，这样可以只遍历<code>A</code>，对对应的<code>B</code>有无数字进行判断。<br><strong>模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C = A - B， A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return if A &gt;= B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i]) <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A - B while A &gt;= B</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="comment">// consider if should sub slot of B</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        <span class="comment">// t might be a negative</span></span><br><span class="line">        <span class="comment">// t will be the right slot whatever its negative or positive</span></span><br><span class="line">        <span class="comment">// t + 10 means it will borrow 10 from next slot</span></span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);                                          <span class="comment">//1</span></span><br><span class="line">        <span class="comment">// update t</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;                    </span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// there might be some '0' in back of C</span></span><br><span class="line">    <span class="comment">// dont't have to remove while C.size() == 1</span></span><br><span class="line">    <span class="keyword">for</span> (; C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>; ) C.pop_back();                    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B, C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmp(A, B)) C = sub(A, B);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        C = sub(B, A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">"%d"</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>此处<code>t</code>有可能被减成了负数（最低可以取到-10，最高可取到9），此时向后一位借10，于是最低取到0；同时由于借10的时候并没有判断正负，所以+10可能会导致结果高于10。也就是说，此时运算过程放入<code>C</code>中的数可能的取值范围是：<code>(0, 19)</code>。这样我对10取模，即可得到正确的放入<code>C</code>中的数了。<br>注意，在把“优化”后的（指借位模10）运算结果放入<code>C</code>时，并没有把结果赋值给<code>t</code>，因为后面需要判断<code>t</code>的正负，以更新下一轮的<code>t</code>取值。如果赋值了，则<code>t</code>必然为正，无法更新进位信息。</li>
<li>注意当A与B前几位部分相等时，C后面会存在’0’，如<code>123 - 120</code>结果类似<code>003</code>。但在结果仅为1位时，不用考虑。</li>
</ol>
</blockquote>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://eetoa.github.io/2020/11/08/AcWing-792-高精度减法/" target="_blank" rel="noopener">高精度减法</a></p>
</blockquote>
<h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><p>一个超长正整数乘一个普通int正整数。模拟相乘过程把普通int整数看成一个整体。<br><strong>模板1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )                       <span class="comment">//1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);                                        <span class="comment">//2</span></span><br><span class="line">        t /= <span class="number">10</span>;                                                    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>注意1处条件，当A没有遍历完的时候，需要一直和b相乘，更新进位t。当乘完的时候，依然进入处理进位t，只不过此时不需要和b相乘，而是直接模10获得最高位数。</li>
<li>放入slot中的数一直都是对10取模。</li>
<li>当小整数为0，而大数不止一位时，结果会产生多个0.此时需要消除多个0.</li>
</ol>
</blockquote>
<p>当然也可以在遍历完A后再处理最终进位问题，即：<br><strong>模板2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t = A[i] * b + t;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">for</span> (;C.<span class="built_in">size</span>() &gt;  &amp;&amp; C.back() == <span class="number">0</span>;) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 在处理最终进位<code>t</code>的时候，模板1是对<code>t</code>再进入循环处理，这时候如果<code>t &lt; 10</code>的话，只循环一次，但是如果<code>t &gt;= 10</code>的话，需要反复进入循环，依次取模，除10.</p>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://eetoa.github.io/2020/11/09/AcWing-793-高精度乘法/" target="_blank" rel="noopener">高精度乘法</a></p>
</blockquote>
<h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><p>一个超长正整数除以一个短正整数。<br>和高精度加减乘不一样的是，高精度除法是从大整数高位开始的。在复习了小学二年级下册的相关内容后，我觉得算法基本上就是模拟除法竖式。<br>高精度加计算过程会产生进位，减计算过程会产生借位，乘计算过程会产生进位，而高精度除法计算过程会产生余数。<br>余数作为下一位的高位需要乘10进行新一轮的除法运算。<br><strong>模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;                                                      <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];                                      <span class="comment">// 2</span></span><br><span class="line">        C.push_back(r / b);                                     <span class="comment">// 3</span></span><br><span class="line">        r %= b;                                                 <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());                                <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();         </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>初始化余数<code>r</code>aka <code>remain</code>。</li>
<li>对于被除数<code>A</code>的每一位，需要将上一位除法运算产生的余数作为当前数的高位乘10加上当前数。</li>
<li>用当前数作为被除数和除数<code>b</code>进行除法运算，放到结果槽中。</li>
<li>将余数保留给下一位。</li>
<li>首位可能产生0，所以我们将结果数组反转再去除结尾0.</li>
</ol>
</blockquote>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://eetoa.github.io/2020/11/09/AcWing-794-高精度除法/" target="_blank" rel="noopener">高精度除法</a></p>
</blockquote>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>对于一个给定数组<code>alls[N]</code>，其前缀和数组<code>s[N]</code>对应着对于<code>alls[N]</code>的每一个元素，其前缀所有元素（包括这一位）之和。<br>前缀和数组的应用一般伴随着一些查询操作，一个查询操作就是给定一个区间范围，让你求该范围内数的和。<br>另外，注意构造前缀和数组是从下标1开始构造，整体数目不变。相当于是数组下标向右偏移一位。这是因为构造前缀和数组的每一位需要依赖其前一位。当构造第1位时，需要依赖第0位。<br><strong>模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://eetoa.github.io/2020/11/10/AcWing-795-前缀和/" target="_blank" rel="noopener">前缀和</a></p>
</blockquote>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>双指针的核心思想，是在暴力求解的基础上，通过已知的某种性质，用两个指针进行优化。<br><strong>模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; check(i, j)) j ++ ;</span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常见问题分类：</p>
<blockquote>
<ul>
<li>对于一个序列，用两个指针维护一段区间</li>
<li>对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</li>
</ul>
</blockquote>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://eetoa.github.io/2020/11/04/AcWing-799-最长连续不重复子序列/" target="_blank" rel="noopener">最长连续不重复子序列</a></p>
</blockquote>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>当有一堆数，总量不多，比如说1e5，不算多，但是每个数可能取到很大值或很小值，比如说最大取到1e10。那么在需要把数值当成数组下标进行操作的时候，比如说计数数组，无法开出如此大空间的数组，这时候就需要离散化操作。<br>离散化：把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。<br><strong>模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line">sort(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.erase(unique(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>离散化的映射，主要是将待离散化的数放到容器中，进行排序、去重，再用二分查找找到对应下标，将下标放到一个数组中。</li>
<li>排序：一般是通过二分查找的方式进行下标映射，所以需要对原数据排序。</li>
<li>去重：因为要将待离散化数映射成各自的下标，所以需要对其去重复。</li>
<li>注意离散化操作的重要前提是，原数据本身的值并不重要，我们不感兴趣，重要的是其位置。</li>
</ul>
</blockquote>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://eetoa.github.io/2020/11/06/AcWing-802-区间和" target="_blank" rel="noopener">区间和</a></p>
</blockquote>
<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><p>现有若干区间，相互之间可能相交。将所有相交的区间合并为一个区间，返回合并后的区间。<br><strong>模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    sort(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());                             <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;                                   <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)                                     <span class="comment">// 3</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.push_back(&#123;st, ed&#125;);            <span class="comment">// 4 </span></span><br><span class="line">            st = seg.first, ed = seg.second;                    <span class="comment">// 5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);                          <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.push_back(&#123;st, ed&#125;);                    <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>segs</code>存放的是所有区间的左右端点构成的<code>pair</code>。<br>算法思想是维护一个前置区间，维护一个当前区间。比较两个区间是否相交，不相交就认为前置区间是一个孤立区间。不管是否相交，更新前置区间的左右端点，在更新当前区间左右端点。当最后一个当前区间与其前置区间比较完毕后，不管二者是否相交，最后一次更新前置区间将不会有新的当前区间。此时新的前置区间将必然是一个孤立区间。</p>
<blockquote>
<ul>
<li><ol>
<li>区间按照左端点排序。<code>sort()</code>用于排序<code>pair</code>类时，默认按照左端点升序排序。</li>
</ol>
</li>
<li><ol start="2">
<li>初始化区间左右端点，后面会更新它们。这里是初始化为无穷小（相对来说），初始化值在不同题目可以按需调整。</li>
</ol>
</li>
<li><ol start="3">
<li>比较两个区间是否相交。</li>
</ol>
</li>
<li><ol start="4">
<li>因为初始化的前置区间是无穷小的一个点，所以当前区间是第一个区间时，必然成立。但我们不能将无穷小点放入<code>res</code>中。只有在前置区间从第一个区间开始时，满足3的条件才可以放入<code>res</code>中。</li>
</ol>
</li>
<li><ol start="5">
<li>不相交情况下更新前置区间左右端点。</li>
</ol>
</li>
<li><ol start="6">
<li>相交情况下更新前置区间左右端点。（此时只需更新右端点）</li>
</ol>
</li>
<li><ol start="7">
<li>处理最后一个前置区间，此时前置区间必然是孤立区间当且仅当区间集合<code>segs</code>非空时（或者说当且仅当前置区间非初始化值时）</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>题目链接：</strong></p>
<blockquote>
<p><a href="https://eetoa.github.io/2020/11/06/AcWing-803-区间合并" target="_blank" rel="noopener">区间合并</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>AcWing</category>
        <category>算法基础课</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>双指针</tag>
        <tag>算法模板</tag>
        <tag>快速排序</tag>
        <tag>归并排序</tag>
        <tag>二分查找</tag>
        <tag>高精度四则运算</tag>
        <tag>前缀和</tag>
        <tag>差分</tag>
        <tag>位运算</tag>
        <tag>离散化</tag>
        <tag>区间合并</tag>
        <tag>AcWing</tag>
      </tags>
  </entry>
  <entry>
    <title>C++字符串及其指针类型定义</title>
    <url>/2020/10/01/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%85%B6%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">Meaning in MBCS builds</th>
<th align="center">Meaning in Unicode builds</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WCHAR</td>
<td align="center">wchar_t</td>
<td align="center">wchar_t</td>
</tr>
<tr>
<td align="center">LPSTR</td>
<td align="center">char*</td>
<td align="center">char*</td>
</tr>
<tr>
<td align="center">LPCSTR</td>
<td align="center">const char*</td>
<td align="center">const char*</td>
</tr>
<tr>
<td align="center">LPWSTR</td>
<td align="center">wchar_t*</td>
<td align="center">wchar_t*</td>
</tr>
<tr>
<td align="center">LPCWSTR</td>
<td align="center">wchar_t*</td>
<td align="center">wchar_t*</td>
</tr>
<tr>
<td align="center">TCHAR</td>
<td align="center">TCHAR char</td>
<td align="center">wchar_t</td>
</tr>
<tr>
<td align="center">LPTSTR</td>
<td align="center">TCHAR*</td>
<td align="center">TCHAR*</td>
</tr>
<tr>
<td align="center">LPCTSTR</td>
<td align="center">const TCHAR*</td>
<td align="center">const TCHAR*</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>使用youtube-dl下载YouTube频道所有视频</title>
    <url>/2020/10/19/%E4%BD%BF%E7%94%A8youtube-dl%E4%B8%8B%E8%BD%BDYouTube%E9%A2%91%E9%81%93%E6%89%80%E6%9C%89%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>使用youtube-dl一键下载指定YouTube频道所有视频。</p>
<a id="more"></a>
<p><code>youtube-dl -f &quot;bestvideo[width&gt;=&lt;resolution width such as: 3840&gt;]+bestaudio/best&quot; -ciw -o &quot;%(title)s.%(ext)s&quot; -v &lt;channel url like: xxx/channel/xxx&gt; --download-archive downloaded.txt</code></p>
<blockquote>
<p>-f, –format FORMAT<br>    video format code. with adding <code>bestvideo[width&gt;=3840]+bestaudio/best</code> youtube-dl will pick the quality &gt;= 4K</p>
</blockquote>
<blockquote>
<p>-c, –continue<br>    force resume of partially downloaded files</p>
</blockquote>
<blockquote>
<p>-i, –ignore-errors<br>    continue on download errors, for example to skip unavailable videos in a channel </p>
</blockquote>
<blockquote>
<p>-w, –no-overwrites<br>    do not overwrite files</p>
</blockquote>
<blockquote>
<p>-o, –output<br>    Output filename template, this example functions similarly to the old –title option</p>
</blockquote>
<blockquote>
<p>-v, –verbose<br>    print various debugging information</p>
</blockquote>
<blockquote>
<p>with –download-archive download.txt flag you gonna archive all videos’ info so that you can ezlly resume download.<br>-f </p>
</blockquote>
<p><em>reference:</em></p>
<blockquote>
<p><a href="https://askubuntu.com/questions/856911/using-youtube-dl-to-download-entire-youtube-channel" target="_blank" rel="noopener">https://askubuntu.com/questions/856911/using-youtube-dl-to-download-entire-youtube-channel</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>YouTube</tag>
        <tag>youtube-dl</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算妙妙屋</title>
    <url>/2020/10/25/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%A6%99%E5%A6%99%E5%B1%8B/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>位运算使用技巧。</p>
<a id="more"></a>
<h3 id="1-int类型利用位运算乘除2的k次幂"><a href="#1-int类型利用位运算乘除2的k次幂" class="headerlink" title="1. int类型利用位运算乘除2的k次幂"></a>1. int类型利用位运算乘除2的k次幂</h3><p>a乘以2的k次幂，相当于a &lt;&lt; k 不管a是否为正数。<br>a除以2的k次幂，相当于a &gt;&gt; k 当且仅当a为正数。<br>注意，其他类型不常用，有的可以有的不可以，故不列出。</p>
<h3 id="2-判断二进制数的第k位"><a href="#2-判断二进制数的第k位" class="headerlink" title="2. 判断二进制数的第k位"></a>2. 判断二进制数的第k位</h3><p>首先明确第k位是指从右边最低位向左边最高位第<code>k</code>位。注意低位是从0开始计算，这样也是方便适配左移右移位数。和循环计数一般从0开始一个道理。<br>代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">m = x &gt;&gt; k &amp; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>右移k位就把第k位移到了最低位，再判断该位置数字。</p>
<h3 id="3-二进制数最后一位1的————lowbit-x"><a href="#3-二进制数最后一位1的————lowbit-x" class="headerlink" title="3. 二进制数最后一位1的————lowbit(x)"></a>3. 二进制数最后一位1的————lowbit(x)</h3><p>这里最后一位1是从左往右最后一位，也就是指最低位1，函数lowbit()返回的是包含该1与右边所有0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; - x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>- x</code> 在计算机内部是以补码方式运算的，即:<br><code>- x = ~ x + 1</code><br>假设一个二进制数为：  0010101…0010100000<br><code>~ x</code>为：            1101010…1101011111<br><code>~ x + 1</code>为：        1101010…1101100000<br>注意到+1操作使得最后一位1及其右边所有数字发生了变化，而左边不变。<br>此时在和原数字进行&amp;运算，它和原数字在最后一位1左侧全部不同，右侧全部相同。</p>
<p><strong>参考题目：</strong> <a href="https://eetoa.github.io//2020/11/04/AcWing-801-二进制中1的个数/" target="_blank" rel="noopener">二进制中1的个数</a></p>
<h3 id="4-一个获取二进制数中1的个数的轮子"><a href="#4-一个获取二进制数中1的个数的轮子" class="headerlink" title="4. 一个获取二进制数中1的个数的轮子"></a>4. 一个获取二进制数中1的个数的轮子</h3><p>在c++中：<br><code>__builtin_popcount(unsigned int x)</code><br>用于计算一个32位无符号整数有多少个位为1。<br>类似地，可以用 <code>__builtin_popcountl(unsigned long x)</code> 和 <code>__builtin_popcountll(unsigned long long x)</code> 分别计算无符号 <code>long</code> 和 <code>long long</code> 整数二进制表示中1的位数。</p>
<p>在Java中：<br><code>Integer.bitCount(int x)</code></p>
<p><strong>更多计算二进制表示的数中数字1的个数：</strong> <a href="https://eetoa.github.io/2021/03/03/LeetCode-191-位1的个数/" target="_blank" rel="noopener">位1的个数</a></p>
<h3 id="5-二进制数中最高位1距离最低位的距离"><a href="#5-二进制数中最高位1距离最低位的距离" class="headerlink" title="5. 二进制数中最高位1距离最低位的距离"></a>5. 二进制数中最高位1距离最低位的距离</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_len</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; len ++) x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考题目：</strong> <a href="https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers/" target="_blank" rel="noopener">LeetCode 5620. 连接连续的二进制数字</a></p>
<h3 id="6-两个数之间交换位置"><a href="#6-两个数之间交换位置" class="headerlink" title="6. 两个数之间交换位置"></a>6. 两个数之间交换位置</h3><p>我们有<code>int a = 5, int b = 6</code>, 现需要交换二者位置，可以利用异或运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>

<h3 id="7-实现加法运算"><a href="#7-实现加法运算" class="headerlink" title="7. 实现加法运算"></a>7. 实现加法运算</h3><p>现有<code>int a</code>和<code>int b</code>，用位运算实现加法运算。<br>可以用<code>a ^ b</code>计算无进位加，用<code>a &amp; b &lt;&lt; 1</code>计算进位。<br>二者递归相加即可得到<code>a + b</code>的值。<br>举例：<br><code>int a = 8</code>, <code>int b = 13</code>；<br>8的二进制补码为：1000<br>13为：1101<br><code>a</code>和<code>b</code>的无进位加为：1000 ^ 1101 = 0101<br><code>a</code>和<code>b</code>的加法进位为：1000 &amp; 1101 = 10000<br>接着，我们递归地用上述方法计算0101和10000的和，直到进位为0.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!num2) <span class="keyword">return</span> num1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = num1 ^ num2;</span><br><span class="line">        <span class="keyword">int</span> carry = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Add(sum, carry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，c++支持负数左移，都是存的补码，int会越界所以转为unsigned int</p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 788.逆序对的数量</title>
    <url>/2020/10/27/AcWing-788.%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>归并排序模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为 <code>n</code> 的整数数列，请你计算数列中的逆序对的数量。</p>
<p>逆序对的定义如下：对于数列的第 <code>i</code> 个和第 <code>j</code> 个元素，如果满足 <code>i &lt; j</code> 且 <code>a[i] &gt; a[j]</code>，则其为一个逆序对；否则不是。</p>
<p><strong>输入格式</strong><br>第一行包含整数 <code>n</code> ，表示数列的长度。</p>
<p>第二行包含 <code>n</code> 个整数，表示整个数列。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示逆序对的个数。</p>
<p><strong>数据范围</strong><br>$1≤n≤100000$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>6<br>2 3 4 5 6 1</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>5</p>
</blockquote>
<hr>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> nums[N];</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    helper(lo, mid), helper(mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i &lt;= mid &amp;&amp; j &lt;= hi;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[j]) tmp[t++] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = nums[j++];</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;i &lt;= mid;) tmp[t++] = nums[i++];</span><br><span class="line">    <span class="keyword">for</span> (;j &lt;= hi;) tmp[t++] = nums[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo, j = <span class="number">0</span>; i &lt;= hi;) nums[i++] = tmp[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nums[i]);</span><br><span class="line">    helper(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Wenda</title>
    <url>/2020/09/04/Wenda/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>记录Wenda项目学习过程中的一些重点。</p>
<a id="more"></a>
<h2 id="第一章-开发工具和Java语言介绍"><a href="#第一章-开发工具和Java语言介绍" class="headerlink" title="第一章 开发工具和Java语言介绍"></a>第一章 开发工具和Java语言介绍</h2><p>略</p>
<h2 id="第二章-Spring入门和模板语法"><a href="#第二章-Spring入门和模板语法" class="headerlink" title="第二章 Spring入门和模板语法"></a>第二章 Spring入门和模板语法</h2><h3 id="2-1-项目结构"><a href="#2-1-项目结构" class="headerlink" title="2.1 项目结构"></a>2.1 项目结构</h3><p><img src="project_structure.jpg" alt="project_structure"></p>
<blockquote>
<ul>
<li>pom文件记录了项目依赖的所有包。<br>当我们第一次打开项目时，会loading很久，是因为编译器正在导入pom文件中的包所依赖的其他jar包。</li>
<li><code>java</code>目录下是项目源代码。<br>包括处理url请求的<code>controller</code>、程序入口<code>ProjectxApplication</code></li>
<li><code>resources</code>目录下是项目资源文件<br>包括静态的<code>css</code>，<code>js</code>代码、图片文件等，这些放在<code>static</code>目录下。<br>templates目录下是项目使用的模板，写的一般是<code>html</code>代码。</li>
<li><code>test</code>是测试目录</li>
</ul>
</blockquote>
<h3 id="2-2-一个简单demo"><a href="#2-2-一个简单demo" class="headerlink" title="2.2 一个简单demo"></a>2.2 一个简单demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/"</span>, <span class="string">"/index"</span>&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很简单的一个demo，<code>IndexController</code> 类通过 <code>@Controller</code> 注解,它实现了在访问localhost:8080/或者localhost:8080/index时返回一个   <code>Hello World</code>。</p>
<h4 id="2-2-1-指定HTTP请求方法"><a href="#2-2-1-指定HTTP请求方法" class="headerlink" title="2.2.1 指定HTTP请求方法"></a>2.2.1 指定HTTP请求方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(map = &#123;<span class="string">"/"</span>, <span class="string">"/index"</span>&#125;, method = &#123;Requstmethod.GET&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样在访问<code>localhost:8080/</code>或者<code>localhost:8080/index</code>时只能通过HTTP的GET方法访问，当通过其他方法访问时会报错。在处理一些只需要提交数据的情况时，我们可以指定为HTTP请求方法为POST以避免不必要的数据拉取操作。</p>
<h4 id="2-2-2-HTTP-METHOD"><a href="#2-2-2-HTTP-METHOD" class="headerlink" title="2.2.2 HTTP METHOD"></a>2.2.2 HTTP METHOD</h4><blockquote>
<ul>
<li><code>GET</code> ：获取接口信息</li>
<li><code>HEAD</code> ：仅查看接口的<code>HTTP</code>的头</li>
<li><code>POST</code> ：提交数据到服务器</li>
<li><code>PUT</code> ：支持幂等性的<code>POST</code>。client对一个URI发送一个Entity，服务器在这个URI下如果已经有了一个Entity，那么此刻服务器应该替换成client重新提交的，也由此保证了<code>PUT</code>的 <strong>幂等性</strong> 。如果服务器之前没有Entity ，那么服务器就应该将client提交的放在这个URI下。</li>
<li><code>DELETE</code> ：删除服务器上的资源</li>
<li><code>OPTIONS</code> ：查看支持的方法</li>
</ul>
</blockquote>
<h3 id="2-3-路径变量和请求参数传递"><a href="#2-3-路径变量和请求参数传递" class="headerlink" title="2.3 路径变量和请求参数传递"></a>2.3 路径变量和请求参数传递</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/profile/&#123;groupId&#125;/&#123;userId&#125;"</span>&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span>         </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">profile</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> <span class="keyword">int</span> uId,                                                   <span class="comment">// 1 </span></span></span><br><span class="line"><span class="function">                      @<span class="title">PathVariable</span><span class="params">(<span class="string">"groupId"</span>)</span> String gId,                                               <span class="comment">// 1</span></span></span><br><span class="line"><span class="function">                      @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"type"</span>, defaultValue = <span class="string">"1"</span>, required = <span class="keyword">false</span>)</span> <span class="keyword">int</span> type,      <span class="comment">// 2</span></span></span><br><span class="line"><span class="function">                      @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"key"</span>, defaultValue = <span class="string">"zz"</span>, required = <span class="keyword">false</span>)</span> String key) </span>&#123;  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"Profile Page of %d who belong to %s; "</span> +</span><br><span class="line">            <span class="string">"Type: %d Key: %s"</span>, uId, gId, type, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>profile</code> 方法实现了当访问：<br><a href="http://localhost:8080/profile/admins/001?type=1&amp;key=add" target="_blank" rel="noopener">http://localhost:8080/profile/admins/001?type=1&amp;key=add</a><br>时返回：</p>
<blockquote>
<p><strong>Profile Page of 1 who belong to admins; Type: 1 Key: add</strong></p>
</blockquote>
<blockquote>
<ul>
<li><ol>
<li><code>groupId</code> 和 <code>userId</code> 这两个变量位于路径中，为 <strong>路径变量</strong>。Spring使用注解 <code>@PathVariable</code> 将路径变量解析到方法中</li>
</ol>
</li>
<li><ol start="2">
<li>url中的type和key为 <strong>请求参数</strong>。Spring使用注解 <code>@RequestParam</code> 将url中的请求参数解析到方法中。</li>
</ol>
</li>
<li>注意默认值的用法：<code>defaultValue</code>是参数的默认值，在url未指定该值时使用它。<code>required</code>标明是否需要参数，默认为是。</li>
<li>请求参数的默认值不管是什么类型，写的时候都是以String 类型为注解 <code>RequestParam</code> 提供的，例如：zz和1。</li>
</ul>
</blockquote>
<h3 id="2-4-通过模板返回"><a href="#2-4-通过模板返回" class="headerlink" title="2.4 通过模板返回"></a>2.4 通过模板返回</h3><p>注意到2.2的demo我们用<code>@ResponseBody</code>修饰方法时，方法会以字符串方式返回”Hello World”。可以去掉这个<code>@ResponseBody</code>让方法通过框架返回一个模板。<br>一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/template"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">template</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"template"</span>;                     <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/main/resources/templates目录中的template.html代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">hello this is a template</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在src/main/resources/templates目录中的application.properties中添加：<br><code>spring.freemarker.suffix= .html</code><br>这样可以让框架默认方法返回的模板后缀为html。注意到在注释1处是<code>return &quot;template&quot;;</code>。</p>
<h3 id="2-5-FreeMarker模板语法"><a href="#2-5-FreeMarker模板语法" class="headerlink" title="2.5 FreeMarker模板语法"></a>2.5 FreeMarker模板语法</h3><p>通过<code>Model</code>对象的<code>addAttribute()</code>方法向模板传递参数。<br>查看Model.class的反编译文件，注意到<code>Model</code>类属于springMVC中ui的框架，就是那个View：<br><code>package org.springframework.ui;</code><br>查看<code>addAttribute()</code>的反编译文件，注意到<code>addAttribute()</code>方法可以接收两个参数：<br><code>Model addAttribute(String var1, @Nullable Object var2);</code></p>
<blockquote>
<ul>
<li><code>String</code>类型变量为后端变量传递到前端时使用的变量</li>
<li><code>object</code>类型变量为后端变量</li>
</ul>
</blockquote>
<h4 id="2-5-1-简单参数传递"><a href="#2-5-1-简单参数传递" class="headerlink" title="2.5.1 简单参数传递"></a>2.5.1 简单参数传递</h4><p>下面是向模板传递<code>String</code>类型变量的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向welcome.html模板传递参数并且返回模板</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/welcome"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"tValue"</span>, <span class="string">"Wow!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"welcome"</span>; <span class="comment">//welcome.html</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时需要在src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">    $&#123;tValue&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>后端的<code>String</code>类型变量<code>Wow!</code>会被传递到前端，并且在前端用<code>tValue</code>表示。<br>在FreeMarker模板语法中，<code>${}</code>中写入后端参数即可传递参数。<br>以上实现了在访问<code>http://localhost:8080/welcome</code>时显示</p>
<blockquote>
<p>Wow!<br>如果变量在后端中不存在则报错。在<code>$</code>和<code>{}</code>中加入任意字段则不会传递参数，全部会被当成文本解析。</p>
</blockquote>
<h4 id="2-5-2-复杂参数传递"><a href="#2-5-2-复杂参数传递" class="headerlink" title="2.5.2 复杂参数传递"></a>2.5.2 复杂参数传递</h4><h5 id="2-5-2-1-传递List"><a href="#2-5-2-1-传递List" class="headerlink" title="2.5.2.1 传递List:"></a>2.5.2.1 传递List:</h5><ol>
<li><p>通过<code>List</code>的<code>toString()</code>方法将<code>List</code>变量以<code>String</code>类型传递到前端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; colors = Arrays.asList(<span class="string">"RED"</span>, <span class="string">"BLUE"</span>, <span class="string">"GREEN"</span>);</span><br><span class="line">model.addAttribute(<span class="string">"tColors1"</span>, colors.toString());</span><br></pre></td></tr></table></figure>
<p>同时需要在src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">    $&#123;tColors1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它实现了在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p><strong>[RED, BLUE, GREEN]</strong></p>
</blockquote>
</li>
<li><p>直接将<code>List</code>对象传递给前端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; colors = Arrays.asList(<span class="string">"RED"</span>, <span class="string">"BLUE"</span>, <span class="string">"GREEN"</span>);</span><br><span class="line">model.addAttribute(<span class="string">"tColors2"</span>, colors);</span><br></pre></td></tr></table></figure>
<p>同时需要在src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">#list</span> <span class="attr">tColors2</span> <span class="attr">as</span> <span class="attr">x</span>&gt;</span></span><br><span class="line">        This is color $&#123;x?index&#125;: $&#123;x&#125; ,count: $&#123;x?counter&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它实现了在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>This is color 0: RED ,count: 1<br>This is color 1: BLUE ,count: 2<br>This is color 2: GREEN ,count: 3</p>
</blockquote>
</li>
</ol>
<h5 id="2-5-2-2-传递Map"><a href="#2-5-2-2-传递Map" class="headerlink" title="2.5.2.2 传递Map:"></a>2.5.2.2 传递Map:</h5><ol>
<li><p>一般是向模板传递map，再在模板中使用<code>${map?keys}</code>循环keySet迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    map.put(String.valueOf(i), String.valueOf(i*i));</span><br><span class="line">&#125;</span><br><span class="line">model.addAttribute(<span class="string">"tMap"</span>, map);</span><br></pre></td></tr></table></figure>
<p>同时需要在src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">tMap</span>?<span class="attr">keys</span> <span class="attr">as</span> <span class="attr">key</span>&gt;</span></span><br><span class="line">    key: $&#123;key&#125; - value: $&#123;tMap[key]&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它实现了在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>key: 0 - value: 0<br>key: 1 - value: 1<br>key: 2 - value: 4<br>key: 3 - value: 9</p>
</blockquote>
</li>
<li><p>甚至可以直接向模板传递一个<code>entrySet()</code>，接着在模板中迭代它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    map.put(String.valueOf(i), String.valueOf(i*i));</span><br><span class="line">&#125;</span><br><span class="line">model.addAttribute(<span class="string">"tEntry"</span>, map.entrySet());</span><br></pre></td></tr></table></figure>
<p><strong>这里<code>${entry.key}</code>是直接调用了<code>Java</code>对象方法。</strong><br>同时需要在src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">tEntry</span> <span class="attr">as</span> <span class="attr">entry</span>&gt;</span>                 <span class="tag">&lt;<span class="name">#--</span> <span class="attr">ftl</span>语言<span class="attr">map</span>不能<span class="attr">get</span>一个<span class="attr">entry</span>，要想循环<span class="attr">entry</span> <span class="attr">set</span>得从后端传过来 <span class="attr">--</span>&gt;</span></span><br><span class="line">    key: $&#123;entry.key&#125; - value: $&#123;entry.value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span>                                <span class="tag">&lt;<span class="name">#--</span> 这个太神奇了 <span class="attr">--</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它也实现了在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>key: 0 - value: 0<br>key: 1 - value: 1<br>key: 2 - value: 4<br>key: 3 - value: 9</p>
</blockquote>
</li>
</ol>
<h5 id="2-5-2-3-传递自定义对象"><a href="#2-5-2-3-传递自定义对象" class="headerlink" title="2.5.2.3 传递自定义对象:"></a>2.5.2.3 传递自定义对象:</h5><p>除了向模板传递List Map这类Java内置类对象外，还可以传递自定义类。<br>在..src\main\java\plus\fingerdance\projectx\model中创建User类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> plus.fingerdance.projectx.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Controller中加入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">model.addAttribute(<span class="string">"user"</span>, <span class="keyword">new</span> User(<span class="string">"ESP"</span>));</span><br></pre></td></tr></table></figure>
<p>同时需要在src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">User: $&#123;user.name&#125;                            <span class="tag">&lt;<span class="name">#--</span> <span class="attr">1</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">Description:</span><br><span class="line">      $&#123;user.getDescription()&#125;                <span class="tag">&lt;<span class="name">#--</span> <span class="attr">2</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">      $&#123;user.description&#125;                     <span class="tag">&lt;<span class="name">#--</span> <span class="attr">3</span> <span class="attr">--</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它也实现了在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>User: ESP<br>Description:<br>      This is ESP<br>      This is ESP</p>
</blockquote>
<blockquote>
<ul>
<li><ol>
<li>这里模板直接搜索后端Java类User中有没有类似于getxxx isxxx这类方法，接着调用它。</li>
</ol>
</li>
<li><ol start="2">
<li>这里模板是直接调用了Java类方法。</li>
</ol>
</li>
<li><ol start="3">
<li>同1。</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="2-5-3-在模板中自定义变量"><a href="#2-5-3-在模板中自定义变量" class="headerlink" title="2.5.3 在模板中自定义变量"></a>2.5.3 在模板中自定义变量</h4><p>除了从后端传递参数到模板之外，还可以在模板中直接定义参数。<br>在…src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">title</span> = <span class="string">"NowCoder"</span>&gt;</span></span><br><span class="line">$&#123;title&#125;</span><br></pre></td></tr></table></figure>
<p>它也实现了在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>NowCoder</p>
</blockquote>
<h4 id="2-5-4-模板的继承和引用"><a href="#2-5-4-模板的继承和引用" class="headerlink" title="2.5.4 模板的继承和引用"></a>2.5.4 模板的继承和引用</h4><p>可以在一个模板中引用其他模板，工程中一般用于多个页面存在相同部分时。比如网站的头部和尾部，不可能每个页面都写一个头一个尾。这时我们可以单独写一个头模板一个尾模板，接着我们只需要在每个需要用到它们的地方引用它们即可。<br>比如我们定义一个尾模板，在…\src\main\resources\templates中新建tail.html:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Copyright 2020-2025 $&#123;title&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">All rights reserved.</span><br></pre></td></tr></table></figure>
<p>在…src/main/resources/templates/welcome.html中写入引用代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#include</span> "<span class="attr">tail.html</span>"&gt;</span></span><br></pre></td></tr></table></figure>
<p>模板会自动引用tail.html，然后解析其中的变量。因为上文中已经在模板中定义了变量<code>title</code>，所以<br>在访问<code>http://localhost:8080/welcome</code>时页面尾端显示：</p>
<blockquote>
<p>Copyright 2020-2025 NowCoder<br>All rights reserved.</p>
</blockquote>
<p>引用单独的模板文件可以提高代码的复用性，类似地，自定义宏也可以实现这一特性。</p>
<h4 id="2-5-5-模板自定义宏（函数）"><a href="#2-5-5-模板自定义宏（函数）" class="headerlink" title="2.5.5 模板自定义宏（函数）"></a>2.5.5 模板自定义宏（函数）</h4><p>使用<macro>标签自定义一个宏，在标签中需要指明函数名，函数参数；在函数体中指明函数用法。<br>在…src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#macro</span> <span class="attr">render_color</span> <span class="attr">index</span> <span class="attr">color</span>&gt;</span>                   <span class="tag">&lt;<span class="name">#--</span> <span class="attr">1</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">    Color Render Macro $&#123;index&#125;, $&#123;color&#125;           <span class="tag">&lt;<span class="name">#--</span> <span class="attr">2</span> <span class="attr">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>macro标签中指明了函数名<code>render_color</code>，以及函数的两个参数<code>index</code>和<code>color</code>。</li>
<li>函数体中指明了函数用法：当调用函数时，会显示这一行语句<code>Color Render Macro ${index}, ${color}</code>，其中，参数会被模板解析。</li>
</ol>
</blockquote>
<p>函数调用：<br>在…src/main/resources/templates/welcome.html中写入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#list</span> <span class="attr">tColors2</span> <span class="attr">as</span> <span class="attr">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">@render_color</span> <span class="attr">index</span>=<span class="string">"$&#123;color?index&#125;"</span> <span class="attr">color</span>=<span class="string">"$&#123;color&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>Color Render Macro 0, RED<br>Color Render Macro 1, BLUE<br>Color Render Macro 2, GREEN</p>
</blockquote>
<p>使用宏的好处就是，我可以在多个页面调用它，而不必写重复代码。</p>
<h4 id="2-5-6-模板字符串拼接"><a href="#2-5-6-模板字符串拼接" class="headerlink" title="2.5.6 模板字符串拼接"></a>2.5.6 模板字符串拼接</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">hello</span> = <span class="string">"Hello"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">#assign</span> <span class="attr">helloworld</span> = <span class="string">"$&#123;hello&#125; World !"</span>&gt;</span></span><br><span class="line">$&#123;hello&#125;</span><br><span class="line">$&#123;helloworld&#125;</span><br></pre></td></tr></table></figure>
<p>字符串变量<code>helloworld1</code>拼接了变量<code>hello</code>和字符串<code>&quot; World !&quot;</code>.其中，引号为双引号和单引号都可以。<br>在访问<code>http://localhost:8080/welcome</code>时显示：</p>
<blockquote>
<p>Hello<br>Hello World !</p>
</blockquote>
<h4 id="2-5-7-本节项目代码"><a href="#2-5-7-本节项目代码" class="headerlink" title="2.5.7 本节项目代码"></a>2.5.7 本节项目代码</h4><p>代码可能与上文略有出入，但主要体现在格式方面，不用在意这些细节。<br>..src\main\java\plus\fingerdance\projectx\controller\IndexController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以welcome.html模板的方式返回</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/welcome"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"tValue"</span>, <span class="string">"Wow!"</span>);</span><br><span class="line">        List&lt;String&gt; colors = Arrays.asList(<span class="string">"RED"</span>, <span class="string">"BLUE"</span>, <span class="string">"GREEN"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"tColors1"</span>, colors.toString()); <span class="comment">//不加toString会报错：意思就是期待一个String类型啥的，而你给的是一个sequence bla bla</span></span><br><span class="line">        model.addAttribute(<span class="string">"tColors2"</span>, colors);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            map.put(String.valueOf(i), String.valueOf(i*i));</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">"tMap"</span>, map);</span><br><span class="line">        model.addAttribute(<span class="string">"tEntry"</span>, map.entrySet());</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, <span class="keyword">new</span> User(<span class="string">"ESP"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"welcome"</span>; <span class="comment">//welcome.html</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>…\src\main\resources\templates\welcome.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Value:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        $&#123;tValue&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>List:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>list toString represent:<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">            $&#123;tColors1&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>list loop:<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">#list</span> <span class="attr">tColors2</span> <span class="attr">as</span> <span class="attr">x</span>&gt;</span></span><br><span class="line">                This is color $&#123;x?index&#125;: $&#123;x&#125; ,count: $&#123;x?counter&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Map:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>map keySet:<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">#list</span> <span class="attr">tMap</span>?<span class="attr">keys</span> <span class="attr">as</span> <span class="attr">key</span>&gt;</span></span><br><span class="line">                key: $&#123;key&#125; - value: $&#123;tMap[key]&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>map entrySet:<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">#list</span> <span class="attr">tEntry</span> <span class="attr">as</span> <span class="attr">entry</span>&gt;</span>                 <span class="tag">&lt;<span class="name">#--</span> <span class="attr">ftl</span>语言<span class="attr">map</span>不能<span class="attr">get</span>一个<span class="attr">entry</span>，要想循环<span class="attr">entry</span> <span class="attr">set</span>得从后端传过来 <span class="attr">--</span>&gt;</span></span><br><span class="line">                key: $&#123;entry.key&#125; - value: $&#123;entry.value&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">#list</span>&gt;</span>                                <span class="tag">&lt;<span class="name">#--</span> 这个太神奇了 <span class="attr">--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>User:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>User: $&#123;user.name&#125;<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Description:</span><br><span class="line">            $&#123;user.getDescription()&#125;</span><br><span class="line">            $&#123;user.description&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Customized value:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">title</span> = <span class="string">"NowCoder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>$&#123;title&#125;<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Include template:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">#include</span> "<span class="attr">tail.html</span>"&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Customized macro:<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">#macro</span> <span class="attr">render_color</span> <span class="attr">index</span> <span class="attr">color</span>&gt;</span></span><br><span class="line">            Color Render Macro $&#123;index&#125;, $&#123;color&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">#macro</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">#list</span> <span class="attr">tColors2</span> <span class="attr">as</span> <span class="attr">color</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">@render_color</span> <span class="attr">index</span>=<span class="string">"$&#123;color?index&#125;"</span> <span class="attr">color</span>=<span class="string">"$&#123;color&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">#list</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">hello</span> = <span class="string">"Hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">helloworld1</span> = <span class="string">"$&#123;hello&#125; World ! [1]"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">#assign</span> <span class="attr">helloworld2</span> = <span class="string">'$&#123;hello&#125; World ! [2]'</span>&gt;</span></span><br><span class="line">    $&#123;hello&#125;</span><br><span class="line">    $&#123;helloworld1&#125;</span><br><span class="line">    $&#123;helloworld2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-Spring中的Request和Response对象"><a href="#2-6-Spring中的Request和Response对象" class="headerlink" title="2.6 Spring中的Request和Response对象"></a>2.6 Spring中的Request和Response对象</h3><h4 id="2-6-1-Request对象"><a href="#2-6-1-Request对象" class="headerlink" title="2.6.1 Request对象"></a>2.6.1 Request对象</h4><p>Spring对Request和Response对象的一些参数有着很好的封装，可以通过参数方式获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// request和respons对象</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/request"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requests</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                        HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                        )</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String[] str = &#123;<span class="string">"request.getMethod(): "</span>, request.getMethod(),</span><br><span class="line">                    <span class="string">"request.getQueryString(): "</span>, request.getQueryString(),</span><br><span class="line">                    <span class="string">"request.getPathInfo(): "</span>, request.getPathInfo(),</span><br><span class="line">                    <span class="string">"request.getRequestURI(): "</span>, request.getRequestURI()&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length; i ++ ) &#123;</span><br><span class="line">        sb.append(str[i]);</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以在访问<code>http://localhost:8080/request</code>时显示：</p>
<blockquote>
<p>request.getMethod(): GET<br>request.getQueryString(): null<br>request.getPathInfo(): null<br>request.getRequestURI(): /request</p>
</blockquote>
<p>我们还可以通过<code>request.getHeader()</code>获取请求头信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Enumeration&lt;String&gt; headerNames = request.getHeaderNames();headerNames.hasMoreElements();) &#123;</span><br><span class="line">    String name = headerNames.nextElement();</span><br><span class="line">    sb.append(name).append(<span class="string">":"</span>).append(request.getHeader(name)).append(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒号前为headerName，后面为header.<br><code>sb</code>添加了如上信息后，会在访问<code>http://localhost:8080/request</code>时多显示如下信息：</p>
<blockquote>
<p>host: localhost:8080<br>connection: keep-alive<br>cache-control: max-age=0<br>upgrade-insecure-requests: 1<br>user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36 Edg/86.0.622.69<br>accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3;q=0.9<br>sec-fetch-site: none<br>sec-fetch-mode: navigate<br>sec-fetch-user: ?1<br>sec-fetch-dest: document<br>accept-encoding: gzip, deflate, br<br>accept-language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6<br>cookie: Idea-510111fa=6e59ec78-c3df-46b6-9a42-f2f1d838f830; _ga=GA1.1.234834870.1604220367; _ga_23PFYL4751=GS1.1.1605340925.4.1.1605340955.0; JSESSIONID=E380D4FA65A20F296103B854C08FA844</p>
</blockquote>
<p>其中,cookie可以单独读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">        sb.append(<span class="string">" Cookie:"</span> ).append(cookie.getName()).append(<span class="string">" Value:"</span>).append(cookie.getValue()).append(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sb</code>添加了如上信息后，会在访问<code>http://localhost:8080/request</code>时多显示如下信息：</p>
<blockquote>
<p>Cookie:Idea-510111fa Value:6e59ec78-c3df-46b6-9a42-f2f1d838f830<br>Cookie:_ga Value:GA1.1.234834870.1604220367<br>Cookie:_ga_23PFYL4751 Value:GS1.1.1605340925.4.1.1605340955.0<br>Cookie:JSESSIONID Value:416A8479B0D9CE8C912E3B4AF710D850</p>
</blockquote>
<p>cookies的构成是很多组的<code>Cookie</code>和对应的<code>Value</code>，我们甚至可以通过注解的方式，直接读取cookies中的<code>Value</code>值。<br>在方法参数中加入注解<code>@CookieValue(&quot;JSESSIONID&quot;) String sessionId</code>获取<code>Cookie</code>为<code>JSESSIONID</code>对应的<code>Value</code>值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/request"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requests</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                        HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                        @CookieValue(<span class="string">"JSESSIONID"</span>)</span> String sessionId)</span></span><br></pre></td></tr></table></figure>
<p>这样我们就可以直接读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">sb.append(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">sb.append(<span class="string">"COOKIEVALUE:"</span>).append(sessionId);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br></pre></td></tr></table></figure>
<p><code>sb</code>添加了如上信息后，会在访问<code>http://localhost:8080/request</code>时多显示如下信息：</p>
<blockquote>
<p>COOKIEVALUE:416A8479B0D9CE8C912E3B4AF710D850</p>
</blockquote>
<h4 id="2-6-2-Response对象"><a href="#2-6-2-Response对象" class="headerlink" title="2.6.2 Response对象"></a>2.6.2 Response对象</h4><p>除了操作客户端向服务器请求的<code>Request</code>对象外，我们还可以操作服务器向客户端发送的<code>Response</code>对象。<br>向响应头中添加字段<code>nowcoderID:hello</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/request"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">requests</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                        HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                        HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                        @CookieValue(<span class="string">"JSESSIONID"</span>)</span> String sessionId)</span></span><br><span class="line"><span class="function"><span class="comment">// ...</span></span></span><br><span class="line"><span class="function">response.<span class="title">addHeader</span><span class="params">(<span class="string">"nowcoderID"</span>, <span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br></pre></td></tr></table></figure>
<p>在操作Response对象前需要先在函数参数中声明对象。如上会在访问<code>http://localhost:8080/request</code>时用F12浏览器调试页面看到响应头已经包含了我们添加的字段：</p>
<blockquote>
<p><strong>nowcoderID:</strong> hello</p>
</blockquote>
<p>另外我们还可以向响应头中添加cookies对象，例如，我们可以添加一组cookies：name:<code>username</code>, value:<code>nowcoder</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.addCookie(<span class="keyword">new</span> Cookie(<span class="string">"username"</span>, <span class="string">"nowcoder"</span>));</span><br></pre></td></tr></table></figure>
<p>添加后会在访问<code>http://localhost:8080/request</code>时用F12浏览器调试页面看到响应头中已经添加了cookies：</p>
<blockquote>
<p><strong>Set-Cookie:</strong> username=nowcoder</p>
</blockquote>
<h3 id="2-7-重定向"><a href="#2-7-重定向" class="headerlink" title="2.7 重定向"></a>2.7 重定向</h3><p>重定向在工业中应用广泛。比如，一个网站制作了一个PC端网页<code>www.nowcoder.com</code>和一个手机端网页<code>m.nowcoder.com</code>，当服务器通过用户的UserAgent判断用户是使用了手机访问网页时，我们就可以让它跳转到手机端的网页。这样可以很好地提高用户体验。<br>再比如，网站新开发了一个网页，当我们已经将网页部署上线了，但是突然需要对网页做一个更改，又不能临时将网页下线。此时我们就可以为网页做一个跳转，跳转到更改之后部署的页面去。</p>
<h4 id="2-7-1-302临时跳转"><a href="#2-7-1-302临时跳转" class="headerlink" title="2.7.1 302临时跳转"></a>2.7.1 302临时跳转</h4><p>我们可以使用Spring框架为网站自定义跳转：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//302临时性跳转</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/redirect/&#123;code&#125;"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">redirect302</span><span class="params">(@PathVariable(<span class="string">"code"</span>)</span> <span class="keyword">int</span> code) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数返回一个<code>&quot;redirect:/&quot;</code>这样当我们访问：<code>http://localhost:8080/redirect/113</code>时（<code>code</code>可以是任意整型变量），就会临时性地跳转到首页。</p>
<blockquote>
<p>Hello World</p>
</blockquote>
<p>我们可以设置在跳转时，通过<code>HttpSession</code>对象传递一个消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//302临时性跳转</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/redirect/&#123;code&#125;"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">redirect302</span><span class="params">(@PathVariable(<span class="string">"code"</span>)</span> <span class="keyword">int</span> code,</span></span><br><span class="line"><span class="function">                        HttpSession httpSession) </span>&#123;</span><br><span class="line">    httpSession.setAttribute(<span class="string">"msg"</span>, <span class="string">" --jump from redirect"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为函数添加一个<code>HttpSession</code>对象作为参数，并且为该对象设置一个属性，该属性由一个<code>String</code>对象和一个<code>Object</code>对象构成。前者定义了消息的名称，后者为消息对象本身。<br>接着，我们给定义地首页的<code>index</code>方法设置一个<code>Httpsession</code>对象作为参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/"</span>, <span class="string">"/index"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(HttpSession httpSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World"</span> + httpSession.getAttribute(<span class="string">"msg"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当我们访问：<code>http://localhost:8080/redirect/113</code>时，会临时性地跳转到首页，并且将消息<code>--jump from redirect</code>传递到首页，首页会显示：</p>
<blockquote>
<p>Hello World –jump from redirect</p>
</blockquote>
<p>除了让方法通过返回<code>String</code>对象<code>&quot;redirect:/&quot;</code>的方式实现跳转之外，我们还可以让其返回<code>RedirectView</code>对象实现跳转：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//302临时性跳转</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/redirect/&#123;code&#125;"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedirectView <span class="title">redirects302</span><span class="params">(@PathVariable(<span class="string">"code"</span>)</span> <span class="keyword">int</span> code,</span></span><br><span class="line"><span class="function">                                HttpSession httpSession) </span>&#123;</span><br><span class="line">    httpSession.setAttribute(<span class="string">"msg"</span>, <span class="string">" --redirected from redirect."</span>);</span><br><span class="line">    RedirectView red = <span class="keyword">new</span> RedirectView(<span class="string">"/index"</span>, <span class="keyword">true</span>);</span><br><span class="line">    red.setStatusCode(HttpStatus.FOUND);    <span class="comment">// 可以省略</span></span><br><span class="line">    <span class="keyword">return</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上302跳转的情况，我们事先打开浏览器F12控制台，在跳转之后会看到当前网页的网络状态码为<code>302</code>。<br>其中，Spring默认跳转状态码为 <code>302</code> ，所以可以不用人为指定。<br>路径中的code可以是任意整型。</p>
<h4 id="2-7-2-301永久性跳转"><a href="#2-7-2-301永久性跳转" class="headerlink" title="2.7.2 301永久性跳转"></a>2.7.2 301永久性跳转</h4><p>除了设置302临时性跳转之外，我们还可以设置永久性跳转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//301 permanently moved</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/redirect/&#123;code&#125;"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedirectView <span class="title">redirect301</span><span class="params">(@PathVariable(<span class="string">"code"</span>)</span> <span class="keyword">int</span> code,</span></span><br><span class="line"><span class="function">                                HttpSession httpSession) </span>&#123;</span><br><span class="line">    httpSession.setAttribute(<span class="string">"msg"</span>, <span class="string">" --jump from redirect"</span>);  </span><br><span class="line">    RedirectView red = <span class="keyword">new</span> RedirectView(<span class="string">"/index"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">301</span>) &#123;  <span class="comment">//当我们url的code填入301时，触发301跳转，否则为302跳转</span></span><br><span class="line">        red.setStatusCode(HttpStatus.MOVED_PERMANENTLY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>301</code> 只是起到url路径的标记作用，我也可以指定其他值当访问他的时候设置301跳转。<br>依然是通过访问url的<code>/request/{code}</code>实现跳转，当我们访问的code为指定的<code>301</code>时，方法内部设置<code>RedirectView</code>的状态码为 <code>HttpStatus.MOVED_PERMANENTLY</code> ，这样当我们访问：<code>http://localhost:8080/redirect/301</code>时，会永久性地跳转到首页，并且将消息<code>--jump from redirect</code>传递到首页，首页会显示：</p>
<blockquote>
<p>Hello World –jump from redirect</p>
</blockquote>
<p>并且当前网页状态码为：<code>301</code>。</p>
<h3 id="2-8-异常处理"><a href="#2-8-异常处理" class="headerlink" title="2.8 异常处理"></a>2.8 异常处理</h3><p>工业上写网站的时候，经常会用到异常处理。比如说对于有些不存在也页面，访问的时候会显示404 page not found，这其实就是一个统一的异常处理。<br>看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异常处理</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/admin"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">(@RequestParam(<span class="string">"key"</span>)</span> String key) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key.equals(<span class="string">"adminParameter"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数不对"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ExceptionHandler</span>()</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">error</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error:"</span> + e.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个admin页面，访问这个页面需要提供一个参数。当我们提供的参数为<code>adminParameter</code>时，即当我们访问：<code>http://localhost:8080/admin?key=adminParameter</code>时页面返回一个:</p>
<blockquote>
<p>hello admin</p>
</blockquote>
<p>否则就抛出一个异常对象:</p>
<blockquote>
<p>error:参数不对</p>
</blockquote>
<p>我们另外在<code>error</code>函数中对异常进行统一的处理。</p>
<h3 id="2-9-控制反转IOC-aka-依赖注入DI"><a href="#2-9-控制反转IOC-aka-依赖注入DI" class="headerlink" title="2.9 控制反转IOC aka 依赖注入DI"></a>2.9 控制反转IOC aka 依赖注入DI</h3><h4 id="2-9-1-什么是IOC-or-DI"><a href="#2-9-1-什么是IOC-or-DI" class="headerlink" title="2.9.1 什么是IOC or DI"></a>2.9.1 什么是IOC or DI</h4><p>IOC，控制反转（Inversion of Contro）。<br>软件系统在没有引入IOC容器之前，比如说对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p>
<p>软件系统在引入IOC容器之后，这种情形就完全改变了，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p>
<p>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是 <strong>控制反转</strong> 这个名称的由来。</p>
<p>DI，依赖注入（Dependency Injection）。<br>控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。所以 <strong>控制反转</strong> 更合适的名字叫做 <strong>依赖注入</strong></p>
<p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p>
<h4 id="2-9-2-IOC举例"><a href="#2-9-2-IOC举例" class="headerlink" title="2.9.2 IOC举例"></a>2.9.2 IOC举例</h4><p>在…/src/main/java/com.wenda.demo/service 包下创建新的类<code>WendaService</code>。<br>注意要想能让IOC容器在别的地方注入这个类的对象，这里一定要有注解<code>@Service</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WendaService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello User: "</span> + String.valueOf(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在…/src/main/java/com.wenda.demo/controller 包下创建新的类<code>SettingController</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/setting"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setting</span><span class="params">(HttpSession httpSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Setting OK "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>WendaService</code>类，如果我们想在<code>IndexController</code>和<code>SettingController</code>两个类里同时使用，一般来说需要在两个地方各都<code>new</code>出来一个。<br>但是使用IOC的方式，我们只需在两个地方通过注解的方式让IOC容器帮我们注入进来。<br>在<code>SettingController</code>类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// IOC容器注入对象</span></span><br><span class="line">    WendaService wendaService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/setting"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setting</span><span class="params">(HttpSession httpSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Setting OK "</span> + wendaService.getMessage(<span class="number">233</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当访问 <code>http://localhost:8080/setting</code> 时就会看到：</p>
<blockquote>
<p>Setting OK Hello User: 233</p>
</blockquote>
<p>在<code>IndexController</code>类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// IOC容器注入对象</span></span><br><span class="line">    ProjectxService projectxService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/"</span>, <span class="string">"/index"</span>&#125;, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(HttpSession httpSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World."</span> + projectxService.getMessage(<span class="number">113</span>) + httpSession.getAttribute(<span class="string">"msg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当访问主页 <code>http://localhost:8080/index</code> 时就会看到：</p>
<blockquote>
<p>Hello World. Hello User: 113</p>
</blockquote>
<p>其实，不难注意到<code>httpSession</code>对象也是通过IOC容器注入的。</p>
<p>IOC的思想类似于 <strong>享元设计模式（FlyWeight）</strong> ，由一个容器统一管理所有对象，以避免大量的new操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// m_map就看成是IOC容器</span></span><br><span class="line">Class flyWeight</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> key)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_map.containsKey(key)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_map[key];</span><br><span class="line">        &#125;</span><br><span class="line">        Object obj;</span><br><span class="line">        m_map.put_back(key, obj);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, object&gt; m_map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-0-面向切面编程AOP"><a href="#3-0-面向切面编程AOP" class="headerlink" title="3.0 面向切面编程AOP"></a>3.0 面向切面编程AOP</h3><h4 id="3-0-1-什么是面向切面编程"><a href="#3-0-1-什么是面向切面编程" class="headerlink" title="3.0.1 什么是面向切面编程"></a>3.0.1 什么是面向切面编程</h4><p><strong>面向切面编程</strong>（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。<br>但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。<br>也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。<br>一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。<br>这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。<br>AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。</p>
<p>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</p>
<h4 id="3-0-2-AOP举例"><a href="#3-0-2-AOP举例" class="headerlink" title="3.0.2 AOP举例"></a>3.0.2 AOP举例</h4><p>在pom.xml文件中添加相关依赖项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AspectJ 开始--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--AspectJ 结束--&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者直接添加aop起步依赖(starter)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面我们为 <code>IndexController</code> 实现切面类。<br>在 …/src/main/java/com.wenda.demo/ 下新建包：<code>aspect</code>.<br>在 <code>aspect</code> 包下新建一个log切面类 <code>LogAspect</code> ，并为它添加注解 <code>@Aspect</code>。<br>接下来添加注解 <code>@Component</code> ，和 <code>@Service</code> 注解相同的是，他们都是自动注册bean的。区别是后者用于标注业务层组件，前者泛指组件，当组件不好归类的时候，可以使用这个注解标注。如果不明确是不是 <code>@Service</code> ，只要写了 <code>@Component</code> ,它就会以一个组件的方式在依赖注入的时候把对象构造出来。</p>
<p>为 <code>LogAspect</code> 类添加一个logger对象和两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LogAspect<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个*指返回值，第二个*指的是方法，后面跟的是参数</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.wenda.demo.controller.IndexController.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Before method"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* com.wenda.demo.controller.IndexController.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"After method"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在对所有访问 Index的方法做一个切面的“截获”。访问 <code>IndexController</code> 类的所有方法之前执行 <code>beforeMethod()</code> ，之后执行 <code>afterMethod()</code>.<br>注意 <code>&quot;execution(* com.wenda.demo.controller.IndexController.*(..))&quot;</code><br>其中，第一个 <code>*</code> 指返回值，第二个 <code>*</code> 指的是方法，后面跟的 <code>(..)</code> 是参数. 它描述了切面的执行条件。<br>那么当我们访问首页 <a href="http://localhost:8080/index" target="_blank" rel="noopener">http://localhost:8080/index</a> 的时候，在log里就会看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">03</span>-<span class="number">01</span> <span class="number">18</span>:<span class="number">22</span>:<span class="number">32.651</span>  INFO <span class="number">848</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.wenda.demo.aspect.LogAspect          : Before method</span><br><span class="line"><span class="number">2021</span>-<span class="number">03</span>-<span class="number">01</span> <span class="number">18</span>:<span class="number">22</span>:<span class="number">32.665</span>  INFO <span class="number">848</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.wenda.demo.aspect.LogAspect          : After method</span><br></pre></td></tr></table></figure>

<p>切面的好处就是，如果想对系统的性能进行关注，可以在切面方法中为logger写入时间信息，我们可以很清楚地看到访问一个首页的方法的调用情况和执行效率：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LogAspect<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个*指返回值，第二个*指的是方法，后面跟的是参数</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.wenda.demo.controller.IndexController.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Before method"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* com.wenda.demo.controller.IndexController.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"After method"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">03</span>-<span class="number">01</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">12.814</span>  INFO <span class="number">3716</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.wenda.demo.aspect.LogAspect          : Before methodMon Mar <span class="number">01</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">12</span> CST <span class="number">2021</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">03</span>-<span class="number">01</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">12.829</span>  INFO <span class="number">3716</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.wenda.demo.aspect.LogAspect          : After methodMon Mar <span class="number">01</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">12</span> CST <span class="number">2021</span></span><br></pre></td></tr></table></figure>
<p>因为方法执行速度太快，看得不是很明显。</p>
<p>现在我们使用切面的 <code>JoinPoint</code> 切点对象获取被切入方法的参数信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LogAspect<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个*指返回值，第二个*指的是方法，后面跟的是参数</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.wenda.demo.controller.IndexController.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Object arg : joinPoint.getArgs()) &#123;</span><br><span class="line">            sb.append(<span class="string">"arg: "</span>).append(arg).append(<span class="string">"|"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"Before method: "</span> + sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* com.wenda.demo.controller.IndexController.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"After methods: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么当我们访问：<a href="http://localhost:8080/profile/admin/112?type=1" target="_blank" rel="noopener">http://localhost:8080/profile/admin/112?type=1</a> 的时候，可以在log里看到获取的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">21</span>:<span class="number">47.467</span>  INFO <span class="number">19320</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.wenda.demo.aspect.LogAspect          : Before method: arg: <span class="number">112</span>|arg: admin|arg: <span class="number">1</span>|arg: zzz|</span><br></pre></td></tr></table></figure>

<p>面向切面的核心思想就是动态地将代码切入到各种业务流程中去。</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>跑路专用呆湾警署查封页面</title>
    <url>/2020/10/25/%E8%B7%91%E8%B7%AF%E4%B8%93%E7%94%A8%E5%91%86%E6%B9%BE%E8%AD%A6%E7%BD%B2%E6%9F%A5%E5%B0%81%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>显示台湾警察署查封网站的页面html源码。</p>
<a id="more"></a>
<p>效果图：<br><img src="img.jpg" alt="pic0x0"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-TW"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>網站已遭查禁<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Fonts --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span>  <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- CSS --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>  <span class="attr">integrity</span>=<span class="string">"sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">        body&#123;</span><br><span class="line">            font-family: 'Raleway', sans-serif;</span><br><span class="line">            font-size: 14px;</span><br><span class="line">            -webkit-font-smoothing: antialiased;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            h1, h2, h3, h4, h5&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">font-family</span><span class="selector-pseudo">:'Montserrat'</span>, <span class="selector-tag">sans-serif</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="css">            <span class="selector-class">.img-content</span>&#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            align-content: center;</span><br><span class="line">            text-align: center;</span><br><span class="line">            margin: auto;</span><br><span class="line">            height: 50%;</span><br><span class="line">            top: -50%;</span><br><span class="line">            right: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.content</span>&#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            align-content: center;</span><br><span class="line">            text-align: center;</span><br><span class="line">            margin: auto;</span><br><span class="line">            height: 50%;</span><br><span class="line">            top: 0;</span><br><span class="line">            right: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">padding</span><span class="selector-pseudo">:3</span>%;</span></span><br><span class="line">            align-content: center ;</span><br><span class="line">            margin: auto 5% auto 5% ;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">top</span>, <span class="selector-id">#30cfd0</span> 0%, <span class="selector-id">#330867</span> 100%);</span></span><br><span class="line">            border-radius: 20px;</span><br><span class="line"><span class="css">            <span class="selector-tag">box-shadow</span>: 3<span class="selector-tag">px</span> 3<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 6<span class="selector-tag">px</span> <span class="selector-id">#cccccc</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span> <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line">            font-family: "Microsoft JhengHei" ;</span><br><span class="line">            font-size: 50px;   </span><br><span class="line"><span class="css">            <span class="selector-tag">margin-top</span><span class="selector-pseudo">:1</span>%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span> <span class="selector-tag">h2</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-bottom</span><span class="selector-pseudo">:3</span>%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-size</span><span class="selector-pseudo">:40px</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span> <span class="selector-tag">h3</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">opacity</span>: <span class="selector-class">.9</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-size</span><span class="selector-pseudo">:25px</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-class">.banner</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#FFF</span>;</span></span><br><span class="line">            font-size: 24px;</span><br><span class="line">            padding: 20px 0;</span><br><span class="line">            font-weight: 300;</span><br><span class="line">            width: 70%;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;script async src='/cdn-cgi/bm/cv/2172558837/api.js'&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"bg-1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top:-11%;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://i.niupic.com/images/2020/04/10/7mLl.jpeg"</span> <span class="attr">style</span>=<span class="string">"align-content: center;text-align: center;width: 40%;height: auto; margin: auto auto 1% auto; "</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"banner"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-12 text-center"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:firebrick;"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>網站已經遭到查禁<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>(This Domain Has Been Seized)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>已經違背中華民國著作權法第九十一條及九十二條規範，全部或部分內容涉屬盜版，正進入司法偵查中。<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                        The website is in violation of the Copyright Act of the Republic of China (Taiwan) for its unauthorized use of materials.  Investigation is currently underway.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span>&gt;</span>內政部警政署刑事警察局電偵大隊 敬啟 <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                        Criminal Investigation Bureau（Taiwan）<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">window</span>[<span class="string">'__CF$cv$params'</span>]=&#123;<span class="attr">r</span>:<span class="string">'580bbb10ab56988d'</span>,<span class="attr">m</span>:<span class="string">'89a8a3de2b7eced49bf0d7d5400be20e69b51188-1586346206-1800-AXfMipt69xS9k39OseM0Cvbr0f3Kbs2a6i15NQFaHcJ2EE29f4nRPtpVQp/KgduXqsjmOfivLCxx7gGaor0X8kEbM7J50HQX16lmdjp4bzFe+Nr/xYV+BXL01+ME0Wcofw=='</span>,<span class="attr">s</span>:[<span class="number">0xde0ce21efa</span>,<span class="number">0xa321d7537b</span>],<span class="attr">fb</span>:<span class="number">0</span>,&#125;&#125;)();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
  </entry>
  <entry>
    <title>AcWing 799.最长连续不重复子序列</title>
    <url>/2020/11/04/AcWing-799-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道经典的双指针题目。</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p>
<p><strong>输入格式</strong><br>第一行包含整数n。</p>
<p>第二行包含n个整数（均在0~100000范围内），表示整数序列。</p>
<p><strong>输出格式</strong><br>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p>
<p><strong>数据范围</strong><br>1≤n≤100000<br><strong>输入样例：</strong></p>
<blockquote>
<p>5<br>1 2 2 3 5</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3</p>
</blockquote>
<hr>
<h3 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h3><p>双指针的核心思想，是在暴力求解的基础上，通过已知的某种性质，用两个指针进行优化。<br>维护两个指针<code>i</code>，<code>j</code>，维护一个计数数组，<code>i</code>负责遍历原数组，在此过程中用计数数组计数。当i到某一个位置对应的计数数组数值超过1，则认为从<code>j</code>到<code>i</code> 这一段出现了重复。当前最长不重复段为<code>i - j + 1</code>. 接下来移动<code>j</code>，并通过计数数组最后一个值监控<code>j</code>扫过的让最后一个值超过1的下标，当j到达这个下标时，我们认为找到了和<code>i</code>处重复的值，那么，<code>j + 1</code>的位置到<code>i</code>这一段不可能出现重复，<code>j</code>在此固定不动，<code>i</code>继续向后遍历，直到遍历完所有数字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], S[N];                                     <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        S[a[i]] ++;                                 <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">for</span> (;S[a[i]] &gt; <span class="number">1</span>;) &#123;                       <span class="comment">// 2</span></span><br><span class="line">            S[a[j]] --;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><ol>
<li>每一次<code>i</code>移动，让对应数字对应的计数数组下标+1</li>
</ol>
</li>
<li><ol start="2">
<li>保持计数数组非零值全为1，一旦<code>i</code>移动后造成对应计数数组值<code>&gt; 1</code>，就认为出现了重复<br>  此时移动<code>j</code>，直到找到<code>i</code>对应的数的重复数字，并且将移动前<code>j</code>对应的数字在计数数组中抹去。此时从<code>j</code>到<code>i</code>都是不重复的。</li>
</ol>
</li>
<li><ol start="3">
<li>计数数组之所以和原数组开一样大的空间，是因为根据题意，原数组每个数大小不超过100000。</li>
</ol>
</li>
<li><strong>计数数组维护序列的不重复性。</strong> 这道题还有个亮点就是计数数组的使用。为了监控不重复序列，维护一个数值始终为0或1的计数数组，每一次<code>i</code>移动，更新计数数组的对应值，一旦该值超过了1，我们就知道出现了重复。妙啊，妙。</li>
</ul>
</blockquote>
<div class="note primary">
            <h4 id="原题链接："><a href="#原题链接：" class="headerlink" title="原题链接："></a>原题链接：</h4><p><a href="https://www.acwing.com/problem/content/801/" target="_blank" rel="noopener">AcWing 799.最长连续不重复子序列</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计数数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>记录对hexo yilia主题的个性定制</title>
    <url>/2020/10/30/%E8%AE%B0%E5%BD%95%E5%AF%B9hexo-yilia%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%AA%E6%80%A7%E5%AE%9A%E5%88%B6/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>记录在使用hexo-yilia主题时的一些定制选项。</p>
<a id="more"></a>
<h3 id="1-隐藏多余的「展开更多」"><a href="#1-隐藏多余的「展开更多」" class="headerlink" title="1. 隐藏多余的「展开更多」"></a>1. 隐藏多余的「展开更多」</h3><blockquote>
<ul>
<li>打开hexo\themes\yilia\layout_partial\article.ejs</li>
<li>定位到<code>&lt;a class=&quot;.article-more-a&quot; href=&quot;&lt;%- url_for(post.path) %&gt;#more&quot;&gt;</code></li>
<li>行内添加<code>style=“display: none;”</code></li>
</ul>
</blockquote>
<h3 id="2-显示文章阅读次数"><a href="#2-显示文章阅读次数" class="headerlink" title="2. 显示文章阅读次数"></a>2. 显示文章阅读次数</h3><blockquote>
<ul>
<li>打开hexo\themes\yilia\layout_partial\article.ejs</li>
<li>定位到<code>&lt;div class=&quot;article-inner&quot;&gt;</code></li>
<li>定位到<code>&lt;header class=&quot;article-header&quot;&gt;</code></li>
<li>在<code>&lt;%- partial(&#39;post/title&#39;, {class_name: &#39;article-title&#39;}) %&gt;</code>下添加：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--显示阅读次数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (!<span class="attr">index</span> &amp;&amp; <span class="attr">post.comments</span>)&#123; %&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"cloud-tie-join-count"</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span> <span class="attr">style</span>=<span class="string">"color:gray;font-size:14px;"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-sort"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_page_pv"</span> <span class="attr">style</span>=<span class="string">"color:#696969;font-size:14px;"</span>&gt;</span></span><br><span class="line">           阅读数: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_page_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次 <span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="comment">&lt;!--显示阅读次数--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="3-添加文章字数统计和阅读时长"><a href="#3-添加文章字数统计和阅读时长" class="headerlink" title="3. 添加文章字数统计和阅读时长"></a>3. 添加文章字数统计和阅读时长</h3><blockquote>
<ul>
<li>安装wordcount插件: <code>npm i –save hexo-wordcount</code></li>
<li>打开theme\yilia\layout_partial\post，创建<code>word.ejs</code>文件</li>
<li>在<code>word.ejs</code>中写入:<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top:10px;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-keyboard-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>  字数统计: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">wordcount</span>(<span class="attr">post.content</span>) %&gt;</span>字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span></span><br><span class="line">  <span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-hourglass-half"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>  阅读时长: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">min2read</span>(<span class="attr">post.content</span>) %&gt;</span>分<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>打开hexo\themes\yilia\layout_partial\article.ejs</li>
<li>在<code>&lt;%- partial(&#39;post/title&#39;, {class_name: &#39;article-title&#39;}) %&gt;</code>下添加：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--显示文章字数统计以及阅读时长--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span>(<span class="attr">theme.word_count</span> &amp;&amp; !<span class="attr">post.no_word_count</span>)&#123; %&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">post</span>/<span class="attr">word</span>') %&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="comment">&lt;!--显示文章字数统计以及阅读时长--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="4-添加页面顶部加载条"><a href="#4-添加页面顶部加载条" class="headerlink" title="4. 添加页面顶部加载条"></a>4. 添加页面顶部加载条</h3><blockquote>
<ul>
<li>打开theme\yilia\layout_partial\head.ejs</li>
<li>定位到：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">title</span>)&#123; %&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span> | <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">config.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>在其下方添加：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--顶部加载条--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/pace/1.0.2/pace.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">   <span class="selector-class">.pace</span> <span class="selector-class">.pace-progress</span> &#123;</span></span><br><span class="line"><span class="css">       <span class="selector-tag">background</span>: <span class="selector-id">#6d6d6d</span>; <span class="comment">/*进度条颜色*/</span></span></span><br><span class="line">       height: 2px;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="css">   <span class="selector-class">.pace</span> <span class="selector-class">.pace-progress-inner</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#1E92FB</span>, 0 0 5<span class="selector-tag">px</span>     <span class="selector-id">#6d6d6d</span>; <span class="comment">/*阴影颜色*/</span></span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="css">   <span class="selector-class">.pace</span> <span class="selector-class">.pace-activity</span> &#123;</span></span><br><span class="line"><span class="css">       <span class="selector-tag">border-top-color</span>: <span class="selector-id">#6d6d6d</span>;    <span class="comment">/*上边框颜色*/</span></span></span><br><span class="line"><span class="css">       <span class="selector-tag">border-left-color</span>: <span class="selector-id">#6d6d6d</span>;    <span class="comment">/*左边框颜色*/</span></span></span><br><span class="line">   &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--顶部加载条--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>数组排序去重</title>
    <url>/2020/11/04/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一个快速实现数组排序去重的小技巧。</p>
<a id="more"></a>
<p>为什么要记录这个呢，因为算法题中经常用到。</p>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ol>
<li><p>用sort函数配合STL的unique函数实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());                                 <span class="comment">// 1</span></span><br><span class="line">nums.erase(unique(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());       <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><ol>
<li>将原数组排序</li>
</ol>
</li>
<li><ol start="2">
<li>unique函数实现将数组相邻数中重复的移动到函数尾端，返回包含所有重复数字的数组段的起始位置。<br>接下来用erase函数将重复段擦除。</li>
</ol>
</li>
</ul>
</blockquote>
</li>
<li><p>自己造轮子<br>维护两个指针i和j，i负责遍历数组，比较每一项与上一项；j负责指向存储不重复元素的位置。当i遇到不重复项时，j跟随i移动；否则j停止，等待i遇到下一个不重复项。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || a[i] != a[i - <span class="number">1</span>]) &#123;                     <span class="comment">// 1</span></span><br><span class="line">            a[j ++] = a[i];                               <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// unique between 0 and j - 1</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><ol>
<li><code>!i</code>等价于<code>i == 0</code>。当i取首位或者<code>a[i]</code>与上一位相等时，说明<code>a[i]</code>是不重复元素。</li>
</ol>
</li>
<li><ol start="2">
<li>这里体现了 <strong>原地算法思想（in-place algorithm）</strong>。一旦<code>i</code>超过首位且<code>a[i] == a[i - 1]</code>（遇到重复情况），<code>j</code>指针会停留在重复位置，等待<code>i</code>指针找到下一个不重复元素, 直接将不重复元素覆盖掉j指针指向的重复位置。</li>
</ol>
</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>用到再来写. </p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
        <tag>去重</tag>
        <tag>unique</tag>
        <tag>原地算法</tag>
        <tag>in-place algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈原码、反码和补码</title>
    <url>/2020/11/04/%E6%B5%85%E8%B0%88%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>计算机二进制原码、反码和补码的个人理解。</p>
<a id="more"></a>
<p>首先应该明确一点，原码、反码和补码，它是一套由伟大的计算机前辈们设计出来的系统。目的是适配计算机的正负数表示，和加减运算。<br>当我认真理解了原码、反码和补码这一套系统之后，我深深地觉得如果自己出生于恰当的年代而且恰好也是一位计算机科学家的话，我大概也会这样设计，因为它是那么的和谐且自然————仿佛本就该如此。</p>
<h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>一个<code>int</code>型整数的二进制表示为32个0或1，比如10，它的二进制表示为1010（前方的0省略了）。计算机被设计出来的时候，自带了一个加法器的东西。于是，整数的加法运算很简单。例如，10 + 1，它的二进制计算过程是：<br><code>0000 0000 0000 0000 0000 0000 0000 1010   +</code><br><code>0000 0000 0000 0000 0000 0000 0000 0001   =</code><br><code>0000 0000 0000 0000 0000 0000 0000 1011</code><br>-10的原码二进制表示为：<br><code>1000 0000 0000 0000 0000 0000 0000 1010</code><br><strong>这就是原码的定义，最高位是0，表示正数；最高位是1时，表示负数。其他位表示该数绝对值对应的二进制位。</strong><br>两个正数可以直接按照原码进行加法运算，那么减法呢？<br>当进行减法运算时，我们必须考虑用负数代替减法，把减法转化为加法运算。但是直接拿原码进行减法运算显然得出错误结论（即得到的结果值按照原码的表示方法和正确数值不对应）。为了表示负数，和将负数用于加法计算，科学家设计出了反码表示。</p>
<h3 id="反码的由来"><a href="#反码的由来" class="headerlink" title="反码的由来"></a>反码的由来</h3><p>由于需要表示负数，科学家设计了反码。它的设计原则是：<br><code>x + (-x) = 0</code><br>即，一个数的负数加上它本身等于0。<br>看一下这个例子：<br>数字10的负数应该怎么表示？<br>10的原码二进制表示为：<br><code>0000 0000 0000 0000 0000 0000 0000 1010</code><br>-10的原码二进制表示为：<br><code>1000 0000 0000 0000 0000 0000 0000 1010</code><br>当我们运算<code>10 + (-10)</code>时，<br>如果直接拿原码当负数进行加法运算，得到的值是：<br><code>1000 0000 0000 0000 0000 0000 0000 1100</code><br>显然是错的，它并不是0。<br>于是科学家为了适配负数计算，将负数表示为：<br><strong>原码最高位保持不变，其他位每位取反。</strong><br>这就是反码。<br>那么，<code>10 + (-10)</code>就变成了：<br><code>0000 0000 0000 0000 0000 0000 0000 1010   +</code><br><code>1111 1111 1111 1111 1111 1111 1111 0101   =</code><br><code>1111 1111 1111 1111 1111 1111 1111 1111</code><br>注意，负数参与的加法得到的值依然是反码。为什么呢？因为：<br><strong>正数的反码就是其原码</strong><br>两个反码相加，结果当然还表示为反码。这里就很清晰了，上述计算结果最高位1表示负数，其他位取反还原成原码就是：<br><code>1000 0000 0000 0000 0000 0000 0000 0000</code><br>表示成-0。<br>那么，你可以注意到-0的反码表示为：<br><code>1111 1111 1111 1111 1111 1111 1111 1111</code><br>而+0的反码表示为：<br><code>0000 0000 0000 0000 0000 0000 0000 0000</code><br>而<code>+0 == -0 == 0</code><br>当科学家设计到这里的时候，甭提多尴尬了，同一个数居然出现了两种表示方式。于是，闪耀着人类智慧光芒的 <strong>补码</strong> 应运而生。</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>为了让0只有一种表示方式，科学家们大腿一拍，决定：<br><strong>先让0表示为<code>0000 0000 0000 0000 0000 0000 0000 0000</code></strong><br><strong>所有正数原地不动，表示为其原码。</strong><br><strong>再让所有负数向多出来的-0位置移动一位。即所有负数表示为反码+1位偏移</strong><br>这就是补码。<br>为了更好地理解这一块，你可以把0附近的数在计算机中看成是这样排列的：<br><code>-3  -2  -1  -0   +0   +1   +2   +3</code><br>按照反码规则，他们确实是这样排列的。</p>
<p><strong>做个总结：</strong></p>
<blockquote>
<ul>
<li>原码：正数不变，负数最高位取1表示符号，其余位保持和对应的正数相同（给人看的，让你一看就知道是负几）。</li>
<li>反码：正数和原码相同，负数最高位取1，其余位各位取反（给计算机看的，让计算机可以计算负数加法）。</li>
<li>补码：正数和原码相同，负数为原码取反再加1（给计算机看的，让计算机可以处理0）。<br>其中，你如果直接看负数的补码会觉得好奇怪，其实这个只是一种表示方法，一种外在的表现形式。你按照计算机的规则先减1再取反就得到这个负数的原码的。你就能看懂了。</li>
</ul>
</blockquote>
<p><strong>举个例子：</strong><br><code>3 + (-5)</code><br>3的补码为：<br><code>0000 0000 0000 0000 0000 0000 0000 0011</code><br>-5的原码为：<br><code>1000 0000 0000 0000 0000 0000 0000 0101</code><br>反码为：<br><code>1111 1111 1111 1111 1111 1111 1111 1010</code><br>补码为：<br><code>1111 1111 1111 1111 1111 1111 1111 1011</code><br><code>3 + (-5)</code> 计算机的计算过程是这样的：<br><code>0000 0000 0000 0000 0000 0000 0000 0011   +</code><br><code>1111 1111 1111 1111 1111 1111 1111 1011   =</code><br><code>1111 1111 1111 1111 1111 1111 1111 1110</code><br>结果的补码看起来好奇怪，但是记住这是给计算机看的，在补码体系下它就是被设计成用这一串奇奇怪怪的1、0表示-2。我们只需将其减1再取反即可得到结果的原码表示：<br>结果减1当然也是加上1的补码：<br><code>1111 1111 1111 1111 1111 1111 1111 1110   +   //结果补码</code><br><code>1111 1111 1111 1111 1111 1111 1111 1111   =   //-1补码</code><br><code>1111 1111 1111 1111 1111 1111 1111 1101       //临时码</code><br>高位不变其他位取反：<br><code>1000 0000 0000 0000 0000 0000 0000 0010       //结果原码</code><br>一眼就看出这是-2.<br>其实所谓的一眼看出，不过是让最高位符号匹配后面的正数。</p>
<p><em>参考:</em></p>
<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/105917577" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105917577</a> 【原创】计算机为什么要用补码？ - kaka的文章 - 知乎</li>
<li><a href="https://zh.wikipedia.org/wiki/原码" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/原码</a></li>
<li><a href="https://zh.wikipedia.org/wiki/反码" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/反码</a></li>
<li><a href="https://zh.wikipedia.org/wiki/补码" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/补码</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 802.区间和</title>
    <url>/2020/11/06/AcWing-802-%E5%8C%BA%E9%97%B4%E5%92%8C/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道经典的离散化题目。</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是0。<br>现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。<br>接下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。</p>
<p><strong>输入格式</strong><br>第一行包含两个整数n和m。<br>接下来 n 行，每行包含两个整数x和c。<br>再接下里 m 行，每行包含两个整数l和r。</p>
<p><strong>输出格式</strong><br>共m行，每行输出一个询问中所求的区间内数字和。</p>
<p><strong>数据范围</strong><br>$−1e9≤x≤1e9$,<br>$1≤n,m≤1e5$,<br>$−1e9≤l≤r≤1e9$,<br>$−10000≤c≤10000$ </p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>3 3<br>1 2<br>3 6<br>7 5<br>1 3<br>4 6<br>7 8</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>8<br>0<br>5</p>
</blockquote>
<hr>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;                                           <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> a[N], s[N];                                                 <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; alls;                                               <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; add, query;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; l &lt; r;) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span>;                                               <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (; n -- ;) &#123;                                            <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">int</span> x, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        alls.push_back(x);</span><br><span class="line">        add.push_back(&#123;x, c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; m -- ;) &#123;                                            <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">int</span> l, r;   </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        alls.push_back(l);</span><br><span class="line">        alls.push_back(r);</span><br><span class="line">        query.push_back(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());                             <span class="comment">// 6</span></span><br><span class="line">    alls.erase(unique(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 7</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add) &#123;                                     <span class="comment">// 8</span></span><br><span class="line">        a[<span class="built_in">find</span>(item.first)] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i ++ ) &#123;                  <span class="comment">// 9</span></span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query) &#123;                                   <span class="comment">// 10</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><ol>
<li>add下标最多1e5个，query下标最多2e5个。当最极端的情况出现时，下标总数可达到3e5。</li>
</ol>
</li>
<li><ol start="2">
<li>待离散化数组，存放add下标和query下标。</li>
</ol>
</li>
<li><ol start="3">
<li>为了方便求前缀和，将add每一位映射到a数组向右偏移一位的位置（从1开始）。</li>
</ol>
</li>
<li><ol start="4">
<li>add数据输入。</li>
</ol>
</li>
<li><ol start="5">
<li>query数据输入。</li>
</ol>
</li>
<li><ol start="6">
<li>排序为了方便二分查找映射下标。</li>
</ol>
</li>
<li><ol start="7">
<li>去重为了让所有待离散化数据一一映射自己的下标。</li>
</ol>
</li>
<li><ol start="8">
<li>处理映射数组，所有add下标对应统统加上相应的数；所有query下标对应默认为0。</li>
</ol>
</li>
<li><ol start="9">
<li>求前缀和数组。我们知道求前缀和数组需要从1开始取，但是这里为什么 <strong>可以</strong> 从1开始遍历呢？因为alls数组是从0开始记录的，find方法将坐标映射到下标时已经向右偏移了一位，所以a数组值&gt; 0的位置一定是&gt; 0的。另外注意到这里为什么要用alls.size()呢，那是因为离散化操作将所有的alls数组中的值全部映射到了a数组中，且前缀和数组长度一定和alls一样长。</li>
</ol>
</li>
<li><ol start="10">
<li>输出查询</li>
</ol>
</li>
<li><ol start="11">
<li>当数组范围大的时候一定要在<code>main()</code>函数外面开数组，因为在这里开数组其内存会被分配在数据区，而在<code>main()</code>内开数组其内存你会被分配在代码区，数据量大的话会出错。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>现在我们尝试描述一下a数组：</strong><br>a数组从0开始，到300009位结束。其中，第0位因为映射过程向右偏移一位故为0。从1开始到alls.size()处，其中有一部分值大于0，这些值是add操作增加的值；另一部分值为0，这一部分为查询坐标映射过来的，构建前缀和数组时需要包含在内。从alls.size()起到300009为止全是0.这一部分长度根据测试数据而变化。</p>
<p>本质上，alls数组可以看成是一组映射关系。将可能取到极大或极小但数量有限的坐标和数组下标对应起来。由于vector数组自身的属性，此时是从0开始记录的。由于我们要构建前缀和数组，在处理a数组时要从1开始构建，所以在通过find方法找坐标下标时，要整体向右偏移一位。</p>
<p><strong>举例：</strong><br>现有Add坐标: -314159265358979, -123, -84, -12, 0, 3, 10086, 99999999999999<br>简化一点，分别对应加1。<br>Query坐标：{-314159265358980, -122}, {-13, 5}, {9999, 99999999999999999999}, {-314159265358983, 99999999999999999999}, {0, 0}</p>
<p>alls数组: $$-314159265358983_0, -314159265358980_1, -314159265358979_2, -123_3, -122_4, -84_5, -13_6,\ -12_7, 0_8, 3_9, 5_{10}, 9999_{11}, 10086_{12}, 99999999999999_{13}, 99999999999999999999_{14}$$</p>
<p>a数组：$$0_0, 0_1, 0_2, 1_3, 1_4, 0_5, 0_6, 0_7, 1_8, 1_9, 1_{10}, 0_{11}, 0_{12}, 1_{13}, 1_{14}, 0_{15}, 0_{16}, … , 0_{100009}$$</p>
<div class="note primary">
            <p><strong>原题链接：</strong><br><a href="https://www.acwing.com/problem/content/804/" target="_blank" rel="noopener">AcWing 802.区间和</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 801. 二进制中1的个数</title>
    <url>/2020/11/04/AcWing-801-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>lowbit的经典应用。</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为n的数列，请你求出数列中每个数的二进制表示中1的个数。</p>
<p><strong>输入格式</strong><br>第一行包含整数n。<br>第二行包含n个整数，表示整个数列。</p>
<p><strong>输出格式</strong><br>共一行，包含n个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中1的个数。</p>
<p><strong>数据范围</strong></p>
<ul>
<li>$1≤n≤100000,$</li>
<li>$0≤数列中元素的值≤10^9$</li>
</ul>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>5<br>1 2 3 4 5</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>1 1 2 1 2</p>
</blockquote>
<hr>
<p>本题考查二进制，运用lowbit可快速得出结果。</p>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; - x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>详情请参考：<a href="https://eetoa.github.io/2020/10/25/位运算妙妙屋/" target="_blank" rel="noopener">位运算妙妙屋</a></p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (; n --;) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, s = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">for</span> (; x; x -= x &amp; -x) s ++ ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<blockquote>
<ul>
<li><ol>
<li>对于每个数，循环减去最后一个<code>1</code>，直到数字变成<code>0</code>。每次减<code>1</code>，<code>res</code>加<code>1</code>.<br>注意，这里的减<code>1</code>是指减最后一个<code>1</code>包括后面的所有<code>0</code>.</li>
</ol>
</li>
</ul>
</blockquote>
<p>更多算法请参考：<a href="https://eetoa.github.io/2021/03/03/LeetCode-191-位1的个数/" target="_blank" rel="noopener">LeetCode 191. 位1的个数</a></p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/803/" target="_blank" rel="noopener">AcWing 801. 二进制中1的个数</a></p>
          </div>


]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>位运算</tag>
        <tag>AcWing</tag>
        <tag>lowbit</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 803.区间合并</title>
    <url>/2020/11/07/AcWing-803-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道经典的区间合并问题。</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 n 个区间 [li,ri]，要求合并所有有交集的区间。<br>注意如果在端点处相交，也算有交集。<br>输出合并完成后的区间个数。<br>例如：[1,3]和[2,6]可以合并为一个区间[1,6]。</p>
<p><strong>输入格式</strong><br>第一行包含整数n。<br>接下来n行，每行包含两个整数 l 和 r。</p>
<p><strong>输出格式</strong><br>共一行，包含一个整数，表示合并区间完成后的区间个数。</p>
<p><strong>数据范围</strong><br>1≤n≤100000,<br>−1e9≤li≤ri≤1e9</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>5<br>1 2<br>2 4<br>5 6<br>7 8<br>7 9</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3</p>
</blockquote>
<hr>
<h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;PII&gt; &amp;segs)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; res;</span><br><span class="line">    <span class="keyword">int</span> l = segs[<span class="number">0</span>].first, r = segs[<span class="number">0</span>].second;                  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; segs.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; segs[i].first) &#123;                                <span class="comment">// 3</span></span><br><span class="line">            res.push_back(&#123;l, r&#125;);</span><br><span class="line">            l = segs[i].first, r = segs[i].second;              <span class="comment">// 4</span></span><br><span class="line">        &#125;                                          </span><br><span class="line">        <span class="keyword">else</span> r = <span class="built_in">max</span>(r, segs[i].second);                        <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.push_back(&#123;l, r&#125;);                                      <span class="comment">// 6</span></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; segs;</span><br><span class="line">    <span class="keyword">for</span> (; n -- ;) &#123;                                         </span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.push_back(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());                             <span class="comment">// 1  </span></span><br><span class="line">    merge(segs);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><ol>
<li>区间按照左端点排序。<code>sort()</code>用于排序<code>pair</code>类时，默认按照左端点升序排序。</li>
</ol>
</li>
<li><ol start="2">
<li>初始化区间左右端点，后面会更新它们。因为题目指出区间数量<code>n &gt;= 1</code>，所以这里是初始化为排序后的第一个区间。</li>
</ol>
</li>
<li><ol start="3">
<li>比较两个区间是否相交。</li>
</ol>
</li>
<li><ol start="4">
<li>不相交情况下更新前置区间左右端点。</li>
</ol>
</li>
<li><ol start="5">
<li>相交情况下更新前置区间左右端点。（此时只需更新右端点）</li>
</ol>
</li>
<li><ol start="6">
<li>处理最后一个前置区间，此时前置区间必然是孤立区间。因为<code>n &gt;= 1</code>且最后一个前置区间没有下一个当前区间。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>题目链接：</strong><br><a href="https://www.acwing.com/problem/content/805/" target="_blank" rel="noopener">AcWing 803.区间合并</a></p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>区间合并</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 2767.优秀的拆分 [2020 CCF CSP-J2, NOIP]</title>
    <url>/2020/11/08/AcWing-2767-%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86-2020-CCF-CSP-J2-NOIP/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>2020 CCF CSP-J2普及组 aka NOIP</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一般来说，一个正整数可以拆分成若干个正整数的和。<br>例如，$1=1$，$10=1+2+3+4$ 等。<br>对于正整数 $n$ 的一种特定拆分，我们称它为“优秀的”，当且仅当在这种拆分下，$n$ 被分解为了若干个 <strong>不同</strong> 的 $2$ 的 <strong>正整数</strong> 次幂。<br>注意，一个数 $x$ 能被表示成 $2$ 的正整数次幂，当且仅当 $x$ 能通过正整数个 $2$ 相乘在一起得到。<br>例如，$10=8+2=2^3+2^1$ 是一个优秀的拆分。<br>但是，$7=4+2+1=2^2+2^1+2^0$ 就不是一个优秀的拆分，因为 $1$ 不是 $2$ 的正整数次幂。<br>现在，给定正整数 $n$，你需要判断这个数的所有拆分中，是否存在优秀的拆分。<br>若存在，请你给出具体的拆分方案。<br>本题暂时采用AcWing数据。</p>
<p><strong>输入格式</strong><br>输入文件只有一行，一个正整数 n，代表需要判断的数。</p>
<p><strong>输出格式</strong><br>如果这个数的所有拆分中，存在优秀的拆分。<br>那么，你需要 <strong>从大到小</strong> 输出这个拆分中的每一个数，相邻两个数之间用一个空格隔开。<br>可以证明，在规定了拆分数字的顺序后，该拆分方案是 <strong>唯一</strong> 的。<br>若不存在优秀的拆分，输出 “-1”（不包含双引号）。</p>
<p><strong>数据范围</strong><br>对于 $20\%$ 的数据，$n≤10$。<br>对于另外 $20\%$ 的数据，保证 $n$ 为奇数。<br>对于另外 $20\%$ 的数据，保证 $n$ 为 $2$ 的正整数次幂。<br>对于 $80\%$ 的数据，$n≤1024$。<br>对于 $100\%$ 的数据，$1≤n≤1×10^7$。</p>
<p><strong>输入样例1：</strong></p>
<blockquote>
<p>6</p>
</blockquote>
<p><strong>输出样例1：</strong></p>
<blockquote>
<p>4 2</p>
</blockquote>
<p><strong>样例1解释</strong><br>$6=4+2=2^2+2^1$ 是一个优秀的拆分。</p>
<p>注意，$6=2+2+2$ 不是一个优秀的拆分，因为拆分成的 $3$ 个数不满足每个数互不相同。</p>
<p><strong>输入样例2：</strong></p>
<blockquote>
<p>7</p>
</blockquote>
<p><strong>输出样例2：</strong></p>
<blockquote>
<p>-1</p>
</blockquote>
<hr>
<p>本质是考二进制。一个奇数不可能存在优秀的拆分；偶数一定存在优秀的拆分。偶数的优秀拆分可表示成其二进制数转十进制时，底数2的次幂。<br>如：<br>十进制10的二进制为1010，转化为十进制即 $2^3 + 2^1$ 。那么10的优秀拆分就是 <code>8 2</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;                      <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">23</span>; i &gt;= <span class="number">0</span>; i --) &#123;        <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt;&gt; i &amp; <span class="number">1</span>) &#123;                   <span class="comment">// 3</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, <span class="number">1</span> &lt;&lt; i);          <span class="comment">// 4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>奇数不存在优秀拆分。</li>
<li>题目限制 <code>n &lt;= 1e7</code>，所以n的二进制数最高位1最高可取到第23位（从0开始）。</li>
<li>判断从二进制最低位起第<code>i</code>位是否为1。</li>
<li>输出第i位为1的十进制数字，可以看成是该位右边全为0时的十进制数，等价于将1左移<code>i</code>位。</li>
</ol>
</blockquote>
<p>我觉得本题重点是能想到用二进制来表示数字，另外就是对数字范围的判断。</p>
<p><strong>原题链接：</strong></p>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/2769/" target="_blank" rel="noopener">AcWing 2767.优秀的拆分</a></p>
</blockquote>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 792.高精度减法</title>
    <url>/2020/11/08/AcWing-792-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>高精度减法模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个正整数，计算它们的差，计算结果可能为负数。</p>
<p><strong>输入格式</strong><br>共两行，每行包含一个整数。</p>
<p><strong>输出格式</strong><br>共一行，包含所求的差。</p>
<p><strong>数据范围</strong><br>$1≤$ 整数长度$ ≤10^5$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>32<br>11</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>21</p>
</blockquote>
<hr>
<p>注意这道题是两个正整数相减。<br>如果换成带负数的，进行判断正负之后，要么转化为两个正整数相加，要么依旧是两个正整数相减。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>()) <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != b[i]) <span class="keyword">return</span> a[i] &gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; m.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t += m[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n.<span class="built_in">size</span>()) t -= n[i];</span><br><span class="line">        res.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);                                               <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.back() == <span class="number">0</span>;) res.pop_back();                       <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m, n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )  m.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )  n.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (cmp(m, n)) res = sub(m, n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res = sub(n, m);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">cout</span> &lt;&lt; res[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>此处<code>t</code>有可能被减成了负数（最低可以取到-10，最高可取到9），此时向后一位借10，于是最低取到0；同时由于借10的时候并没有判断正负，所以+10可能会导致结果高于10。也就是说，此时运算过程放入<code>C</code>中的数可能的取值范围是：<code>(0, 19)</code>。这样我对10取模，即可得到正确的放入<code>C</code>中的数了。<br>注意，在把“优化”后的（指借位模10）运算结果放入<code>C</code>时，并没有把结果赋值给<code>t</code>，因为后面需要判断<code>t</code>的正负，以更新下一轮的<code>t</code>取值。如果赋值了，则<code>t</code>必然为正，无法更新进位信息。</li>
<li>注意当A与B前几位部分相等时，C后面会存在’0’，如<code>123 - 120</code>结果类似<code>003</code>。但在结果仅为1位时，不用考虑。</li>
</ol>
</blockquote>
<div class="note primary">
            <h4 id="原题链接："><a href="#原题链接：" class="headerlink" title="原题链接："></a>原题链接：</h4><p><a href="https://www.acwing.com/problem/content/794/" target="_blank" rel="noopener">AcWing 792.高精度减法</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AcWing</tag>
        <tag>高精度</tag>
        <tag>模板题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 791.高精度加法</title>
    <url>/2020/11/08/AcWing-791-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摘要；</strong><br>高精度加法。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个正整数，计算它们的和。</p>
<p><strong>输入格式</strong><br>共两行，每行包含一个整数。</p>
<p><strong>输出格式</strong><br>共一行，包含所求的和。</p>
<p><strong>数据范围</strong><br>$1 ≤$ 整数长度 $≤ 100000$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>12<br>23</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>35</p>
</blockquote>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span>                             <span class="comment">//1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i++)                      <span class="comment">//2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(<span class="number">1</span>);                                                  <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = add(A, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">cout</span> &lt;&lt; C[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><ol>
<li>以数组引用传入参数，可以避免没必要的数组拷贝。</li>
</ol>
</li>
<li><ol start="2">
<li><code>A</code>或<code>B</code>至少有一个没有遍历完，都需要继续计算。</li>
</ol>
</li>
<li><ol start="3">
<li>注意结束之后进位有可能非0.</li>
</ol>
</li>
</ul>
</blockquote>
<p>模板1可以改写成总是模拟以一个更长的数组加长度较小的数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m.<span class="built_in">size</span>() &lt; n.<span class="built_in">size</span>()) <span class="keyword">return</span> add(n, m);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t += m[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n.<span class="built_in">size</span>()) t += n[i];</span><br><span class="line">        res.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) res.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m, n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) m.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) n.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = add(m, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note primary">
            <h4 id="原题链接："><a href="#原题链接：" class="headerlink" title="原题链接："></a>原题链接：</h4><p><a href="https://www.acwing.com/problem/content/description/793/" target="_blank" rel="noopener">AcWing 791.高精度加法</a></p>
          </div>


]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AcWing</tag>
        <tag>高精度</tag>
        <tag>模板题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT主题博客的个性化配置</title>
    <url>/2020/10/31/Hexo%20NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>记录自己使用Hexo-next主题博客过程中的的一些配置。</p>
<a id="more"></a>

<h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><blockquote>
<ul>
<li>在要置顶的文章<code>Front-matter</code>中加入<code>top: true</code></li>
<li>打开：\hexo\themes\next\layout\_macro\post.swig ，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code></li>
<li>在其下方添加代码段：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;### 置顶 ###&#125;</span><br><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">    &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;font color&#x3D;5d2b90&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;### 置顶 ###&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="更改行内代码样式"><a href="#更改行内代码样式" class="headerlink" title="更改行内代码样式"></a>更改行内代码样式</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css</li>
<li>新建文件夹：_custom</li>
<li>打开_custom文件夹，新建文件：custom.styl</li>
<li>打开custom.styl，添加如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code &#123;</span><br><span class="line">    color: #5d2b90;</span><br><span class="line">    background: rgba(245, 240, 250, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果想要更改边距，边框等等可以加上：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code &#123;</span><br><span class="line">    color: #5d2b90;</span><br><span class="line">    margin: 2px;</span><br><span class="line">    border: 1px solid #06a2e4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>打开：\hexo\themes\next\source\css\main.styl</li>
<li>在末尾加上一行：<code>@import &quot;_custom/custom.styl&quot;;</code></li>
</ul>
</blockquote>
<h3 id="侧边栏目录高亮颜色"><a href="#侧边栏目录高亮颜色" class="headerlink" title="侧边栏目录高亮颜色"></a>侧边栏目录高亮颜色</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css\_variables\base.styl</li>
<li>定位到：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Colors</span></span><br><span class="line"><span class="comment">// colors for use across theme.</span></span><br></pre></td></tr></table></figure></li>
<li>在其下方添加颜色：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$purple       &#x3D; #7D26CD;</span><br><span class="line">$purple-bright&#x3D; #a442ff;</span><br><span class="line"> $purple-vs    &#x3D; #5d2b90;</span><br></pre></td></tr></table></figure></li>
<li>定位到：<code>$sidebar-highlight                    =</code>，修改为<code>$purple-vs</code></li>
</ul>
</blockquote>
<h3 id="头像边框宽度"><a href="#头像边框宽度" class="headerlink" title="头像边框宽度"></a>头像边框宽度</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css_variables\base.styl</li>
<li>定位到：<code>$site-author-image-border-width       = 2px;</code></li>
<li>修改为<code>0px</code></li>
</ul>
</blockquote>
<h3 id="文章主体文字行高"><a href="#文章主体文字行高" class="headerlink" title="文章主体文字行高"></a>文章主体文字行高</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css_variables\base.styl</li>
<li>定位到：<code>$line-height-base         = 2;</code></li>
<li>修改为<code>1.6</code></li>
</ul>
</blockquote>
<h3 id="页面加载进度条"><a href="#页面加载进度条" class="headerlink" title="页面加载进度条"></a>页面加载进度条</h3><blockquote>
<ul>
<li>定位到目录<code>cd /hexo/themes/next</code></li>
<li>安装进度条依赖：theme-nexr-pace<br><code>git clone https://github.com/theme-next/theme-next-pace source/lib/pace</code></li>
<li>打开安装目录<code>cd themes/next/source/lib/three</code>，执行更新：<code>git pull</code></li>
<li>打开：\hexo\themes\next_config.yml</li>
<li>定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li>设置成<code>true</code></li>
</ul>
</blockquote>
<h3 id="配置Google-Analytic"><a href="#配置Google-Analytic" class="headerlink" title="配置Google Analytic"></a>配置Google Analytic</h3><p>GoogleAnalytic改版又适逢hexo-NexT主题更新，故配置过程有所变化，然而网上教程大多过时了。现详细记录一下自己配置Google Analytic的过程：</p>
<blockquote>
<ul>
<li>打开<code>https://analytics.google.com/analytics</code>并登陆自己的谷歌账号</li>
<li>根据步骤注册一个Analytics account，并且拿到自己的<code>MEASUREMENT ID</code>。<code>MEASUREMENT ID</code>就是<code>tracking_id</code>。</li>
<li>拿到<code>MEASUREMENT ID</code>之后，定位到目录：\hexo\themes\next\layout_partials\header，创建一个文件<code>header.swig</code>。如果你用了其他主题，大概位置也是这里，但是文件后缀可能不一样，文件名形如<code>header.xxx</code>。可以自行验证，如果打开文件和下方代码不同则不是我们要找的。在新版NexT主题配置过程中，该文件需要我们手动创建。</li>
<li>打开文件，填入一下代码（<code>MEASUREMENT ID</code>换成自己的）：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Global site tag (gtag.js) - Google Analytics --&gt;</span><br><span class="line">&lt;script async src&#x3D;&quot;https:&#x2F;&#x2F;www.googletagmanager.com&#x2F;gtag&#x2F;js?id&#x3D;MEASUREMENT ID&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.dataLayer &#x3D; window.dataLayer || [];</span><br><span class="line">  function gtag()&#123;dataLayer.push(arguments);&#125;</span><br><span class="line">  gtag(&#39;js&#39;, new Date());</span><br><span class="line">  gtag(&#39;config&#39;, &#39;MEASUREMENT ID&#39;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li>打开：\hexo\themes\next\_config.yml ，定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: </span></span><br></pre></td></tr></table></figure></li>
<li>在<code>header</code>后添加刚才创建的文件路径，并且取消本行注释：<code>header: T:\Blog\root\hexo\themes\next\layout\_partials\header\header.swig</code></li>
<li>定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Google Analytics</span></span><br><span class="line"> <span class="attr">google_analytics:</span></span><br><span class="line">   <span class="attr">tracking_id:</span></span><br></pre></td></tr></table></figure></li>
<li>在<code>tracking_id:</code>后填上自己的<code>MEASUREMENT ID</code></li>
<li>部署完毕</li>
</ul>
</blockquote>
<h3 id="修复Pjax导致的图片显示异常"><a href="#修复Pjax导致的图片显示异常" class="headerlink" title="修复Pjax导致的图片显示异常"></a>修复Pjax导致的图片显示异常</h3><p>在官方对Pjax插件的说明中，我们可以看到其明确表示启用Pjax插件必须配合文章中的图片使用绝对路径才能让图片正常显示：<br><a href="https://theme-next.js.org/docs/third-party-services/external-libraries" target="_blank" rel="noopener">https://theme-next.js.org/docs/third-party-services/external-libraries</a><br>“Please use the <strong>absolute path</strong> of the image or Hexo asset_img tag in your posts, <strong>otherwise the images may fail to load during Pjax refresh.</strong>“<br>我们使用<code>hexo-asset-image</code>插件后，执行<code>hexo new &quot;new title&quot;</code>新建文章后，会在文章所在_post目录下同时新建一个与文章同名的目录。当需要插入图片时，只需将图片放入该目录中，并且在文章内引用图片即可。</p>
<blockquote>
<ul>
<li>在使用Pjax之前，我们的引用方式为：<br><code>![picture name in post](new title/image.jpg)</code></li>
<li>使用Pjax后，需要改为绝对路径：<br><code>![picture name in post](image.jpg)</code></li>
</ul>
</blockquote>
<h3 id="设置点击头像回到主页"><a href="#设置点击头像回到主页" class="headerlink" title="设置点击头像回到主页"></a>设置点击头像回到主页</h3><blockquote>
<ul>
<li>打开hexo\themes\next\layout_partials\sidebar\site-overview.swig</li>
<li>定位到: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img class&#x3D;&quot;site-author-image&quot; itemprop&#x3D;&quot;image&quot; alt&#x3D;&quot;&#123;&#123; author &#125;&#125;&quot;</span><br><span class="line">  src&#x3D;&quot;&#123;&#123; url_for(theme.avatar.url) &#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li>更改为:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">  &lt;img class&#x3D;&quot;site-author-image&quot; itemprop&#x3D;&quot;image&quot; alt&#x3D;&quot;&#123;&#123; author &#125;&#125;&quot;</span><br><span class="line">    src&#x3D;&quot;&#123;&#123; url_for(theme.avatar.url) &#125;&#125;&quot;&gt;</span><br><span class="line">&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="更改标题悬浮颜色"><a href="#更改标题悬浮颜色" class="headerlink" title="更改标题悬浮颜色"></a>更改标题悬浮颜色</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css_common\components\post\post-header.styl</li>
<li>定位到：<code>.posts-expand .post-title-link {</code>，在其下方：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;:hover::before &#123;</span><br><span class="line">  transform: scaleX(1);</span><br><span class="line">  visibility: visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
下面添加：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;:hover&#123;</span><br><span class="line">   color:$purple-vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里的颜色<code>$purple-vs</code>在\hexo\themes\next\source\css\_variables\base.styl定义。</li>
</ul>
</blockquote>
<h3 id="更改超链接悬浮颜色"><a href="#更改超链接悬浮颜色" class="headerlink" title="更改超链接悬浮颜色"></a>更改超链接悬浮颜色</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css\_variables\base.styl</li>
<li>定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">Global</span> <span class="string">link</span> <span class="string">color.</span></span><br><span class="line"><span class="string">$link-color</span>                   <span class="string">=</span> <span class="string">$black-light;</span></span><br><span class="line"><span class="string">$link-color-dark</span>              <span class="string">=</span> <span class="string">$grey-light;</span></span><br><span class="line"><span class="string">$link-hover-color</span>             <span class="string">=</span> <span class="string">$black-deep;</span></span><br></pre></td></tr></table></figure></li>
<li>将<code>$link-hover-color</code>值更改为<code>$purpl-vs</code></li>
</ul>
</blockquote>
<h3 id="更改导航悬浮颜色"><a href="#更改导航悬浮颜色" class="headerlink" title="更改导航悬浮颜色"></a>更改导航悬浮颜色</h3><blockquote>
<ul>
<li>打开：..\hexo\themes\next\source\css\_variables\base.styl</li>
<li>定位到：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$sidebar-nav-color                    &#x3D; $grey-dim;</span><br><span class="line">$sidebar-nav-hover-color              &#x3D; $whitesmoke;</span><br></pre></td></tr></table></figure></li>
<li>更改<code>sidebar-nav-hover-color</code>的值为<code>purple-vs</code></li>
</ul>
</blockquote>
<h3 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a>自定义字体</h3><p>今天，我给自己的博客换上了 <strong>衬线（serif)字体</strong>，没想到效果这么好。<br>中文字体：Noto Serif SC (思源宋体)<br>英文字体：Maitree (跟宋体绝配)<br>要想中英文字体同时更改，需要在两个地方设置。首先设置全局字体为Maitree，再单独修改中文字体为思源宋体。<br>步骤：<br><strong>修改全局英文字体：</strong></p>
<blockquote>
<ul>
<li>打开：\hexo\themes\next\_config.yml ，定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li>将<code>enable: false</code>改为<code>true</code>。</li>
<li>定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">family:</span> <span class="string">Lato</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>将<code>family: Lato</code>改为<code>Maitree</code>。</li>
</ul>
</blockquote>
<p><strong>修改中文字体：</strong></p>
<blockquote>
<ul>
<li>打开：..\hexo\themes\next\source\css\_variables\base.styl</li>
<li>定位到：<br><code>$font-family-chinese      = &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;;</code></li>
<li>修改为：<code>&quot;Noto Serif SC&quot;;</code></li>
<li>打开：..\hexo\themes\next\layout\_partials\header\header.swig</li>
<li>文末添加：<br><code>&lt;link href=&quot;https://fonts.googleapis.com/css2?family=Noto+Serif+SC&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt;</code></li>
<li>打开：..\hexo\themes\next\_config.yml ，定位到：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br></pre></td></tr></table></figure></li>
<li>head行修改为：</li>
<li><code>head: ..\hexo\themes\next\layout\\_partials\header\header.swig</code></li>
</ul>
</blockquote>
<h3 id="版权声明引用样式更改"><a href="#版权声明引用样式更改" class="headerlink" title="版权声明引用样式更改"></a>版权声明引用样式更改</h3><blockquote>
<ul>
<li>打开：\hexo\themes\next\source\css\_common\components\post\post-copyright.styl</li>
<li>修改颜色从<code>$red</code>为<code>$purple-vs</code>，其中，<code>$purple-vs</code>在<br>\hexo\themes\next\source\css\_variables\base.styl中定义。</li>
</ul>
</blockquote>
<h3 id="引用Note颜色更改"><a href="#引用Note颜色更改" class="headerlink" title="引用Note颜色更改"></a>引用Note颜色更改</h3><p>在Markdown中使用Note时：</p>
<div class="note primary">
            <p>whatever</p>
          </div>
<p>会在文章中插入块引用。<br><strong>更改引用边框颜色：</strong></p>
<blockquote>
<ul>
<li>打开：..\hexo\themes\next\source\css\_variables\base.styl</li>
<li>定位到：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Primary</span><br><span class="line">$note-primary-border        &#x3D; #6f42c1;</span><br></pre></td></tr></table></figure></li>
<li>更改颜色值为：<code>#5d2b90</code></li>
</ul>
</blockquote>
<p><strong>更改引用背景色：</strong></p>
<blockquote>
<ul>
<li>在上文基础上更改<code>$note-primary-bg</code>值为: <code>var(--card-bg-color);</code><br>该颜色为版权声明块背景色，这样可让二者相互适配。</li>
</ul>
</blockquote>
<h3 id="更改分割线样式"><a href="#更改分割线样式" class="headerlink" title="更改分割线样式"></a>更改分割线样式</h3><blockquote>
<ul>
<li>打开：..\hexo\themes\next\source\css\_common\scaffolding\base.styl</li>
<li>定位到：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hr &#123;</span><br><span class="line">  background-image: repeating-linear-gradient(-45deg, $grey-lighter, $grey-lighter 4px, transparent 4px, transparent 8px);</span><br></pre></td></tr></table></figure></li>
<li>修改为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background-image: linear-gradient(0deg, $purple-vs, $purple-vs 1px, transparent 1px, transparent 1px);&#96;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="更改Tabs选项卡样式"><a href="#更改Tabs选项卡样式" class="headerlink" title="更改Tabs选项卡样式"></a>更改Tabs选项卡样式</h3><blockquote>
<ul>
<li>更改上边缘颜色为紫色</li>
<li>打开：..\hexo\themes\next\source\css_common\scaffolding\tags\tabs.styl</li>
<li>定位到：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">border-top: 3px solid $orange;</span><br></pre></td></tr></table></figure></li>
<li>修改为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">border-top: 1px solid $purple-vs;</span><br></pre></td></tr></table></figure></li>
<li>更改选项卡高度</li>
<li>定位到<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">      border-bottom: initial;</span><br><span class="line">      display: block;</span><br><span class="line">      line-height: 1.8;</span><br></pre></td></tr></table></figure></li>
<li>更改<code>line-height: 1.8;</code>为<code>line-height: 1.4;</code></li>
</ul>
</blockquote>
<h3 id="文章末尾版权声明url问题记录"><a href="#文章末尾版权声明url问题记录" class="headerlink" title="文章末尾版权声明url问题记录"></a>文章末尾版权声明url问题记录</h3><p>在HeXo站点配置文件_config.yml下如果将 <code>url</code> 设置成github page的域名类似 xxx.github.io，那么文章末尾自动生成的版权声明会出现url拼接异常。<br>这个时候只需要将url设置成自定义域名即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="comment"># url: eetoa.github.io</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://accepted.org.cn</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 793.高精度乘法</title>
    <url>/2020/11/09/AcWing-793-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>高精度乘法模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个正整数A和B，请你计算A * B的值。</p>
<p><strong>输入格式</strong><br>共两行，第一行包含整数A，第二行包含整数B。</p>
<p><strong>输出格式</strong><br>共一行，包含A * B的值。</p>
<p><strong>数据范围</strong><br>$1≤A$ 的长度 $≤100000$,<br>$0≤B≤10000$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>2<br>3</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>6</p>
</blockquote>
<hr>
<p>注意这道题是两个正整数，一个超长位数乘一个短位数，在进行高精度乘法运算过程中，我们习惯将短位数和超长位的每一位进行乘法运算。<br>如果换成负数，本质还是一样的，无非就是多一次正负判断。<br>对于最终进位的处理，有两种方式：</p>
<h3 id="方法一：进位依次对十取模放进res数组"><a href="#方法一：进位依次对十取模放进res数组" class="headerlink" title="方法一：进位依次对十取模放进res数组"></a>方法一：进位依次对十取模放进res数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.<span class="built_in">size</span>() || t; i ++ )                       <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; m.<span class="built_in">size</span>()) t += m[i] * b;</span><br><span class="line">        res.push_back(t % <span class="number">10</span>);                                      <span class="comment">// 2</span></span><br><span class="line">        t /= <span class="number">10</span>;                                                    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.back() == <span class="number">0</span>;) res.pop_back();      <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) m.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res = mul(m, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i  -- ) <span class="built_in">cout</span> &lt;&lt; res[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>注意1处条件，当<code>m</code>没有遍历完的时候，需要一直和<code>n</code>相乘，更新进位<code>t</code>。当乘完的时候，依然进入处理进位<code>t</code>，只不过此时不需要和<code>n</code>相乘，而是直接模10获得最高位数。</li>
<li>放入slot中的数一直都是对10取模。</li>
<li>去除数组尾部（结果头部）零。</li>
</ol>
</blockquote>
<h3 id="方法二：进位直接放入res数组"><a href="#方法二：进位直接放入res数组" class="headerlink" title="方法二：进位直接放入res数组"></a>方法二：进位直接放入res数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t = m[i] * n + t;</span><br><span class="line">        res.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) res.push_back(t);</span><br><span class="line">    <span class="keyword">for</span> (; res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.back() == <span class="number">0</span>;) res.pop_back();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) m.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res = mul(m, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i  -- ) <span class="built_in">cout</span> &lt;&lt; res[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 在处理最终进位<code>t</code>的时候，方法一是对<code>t</code>再进入循环处理，这时候如果<code>t &lt; 10</code>的话，只循环一次，但是如果<code>t &gt;= 10</code>的话，需要反复进入循环，依次取模，除10.</p>
<div class="note primary">
            <h4 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h4><p><a href="https://www.acwing.com/problem/content/795/" target="_blank" rel="noopener">AcWing 793.高精度乘法</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AcWing</tag>
        <tag>高精度</tag>
        <tag>模板题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 794.高精度除法</title>
    <url>/2020/11/09/AcWing-794-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>高精度除法模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个非负整数A，B，请你计算 A / B的商和余数。</p>
<p><strong>输入格式</strong><br>共两行，第一行包含整数A，第二行包含整数B。</p>
<p><strong>输出格式</strong><br>共两行，第一行输出所求的商，第二行输出所求余数。</p>
<p><strong>数据范围</strong><br>$1≤A$ 的长度 $≤100000$,<br>$1≤B≤10000$<br>$B$ 一定不为0</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>7<br>2</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3<br>1</p>
</blockquote>
<hr>
<p>不考虑负数情况，因为负数除法可以转化为两个正数相除。<br>和高精度加减乘不一样的是，高精度除法是从大整数高位开始的。在复习了小学二年级下册的相关内容后，我觉得算法基本上就是模拟除法竖式。<br>高精度加计算过程会产生进位，减计算过程会产生借位，乘计算过程会产生进位，而高精度除法计算过程会产生余数。<br>余数作为下一位的高位需要乘10进行新一轮的除法运算。<br>以下为我写的代码，和模板可能有略微区别。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;                                                         <span class="comment">// 1  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];                                             <span class="comment">// 2</span></span><br><span class="line">        res.push_back(r / b);                                          <span class="comment">// 3</span></span><br><span class="line">        r %= b;                                                        <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());                                   <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">for</span> (; res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.back() == <span class="number">0</span>;) res.pop_back();</span><br><span class="line">    b = r;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); i ++ ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res = div(A, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">cout</span> &lt;&lt; res[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>初始化余数<code>r</code>aka <code>remain</code>。</li>
<li>对于被除数<code>A</code>的每一位，需要将上一位除法运算产生的余数作为当前数的高位乘10加上当前数。</li>
<li>用当前数作为被除数和除数<code>b</code>进行除法运算，放到结果槽中。</li>
<li>将余数保留给下一位。</li>
<li>首位可能产生0，所以我们将结果数组反转再去除结尾0.</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/796/" target="_blank" rel="noopener">AcWing 794.高精度除法</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AcWing</tag>
        <tag>高精度</tag>
        <tag>模板题</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 800.数组元素的目标和</title>
    <url>/2020/11/11/AcWing-800-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道双指针题目。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个升序排序的有序数组A和B，以及一个目标值x。数组下标从0开始。<br>请你求出满足A[i] + B[j] = x的数对(i, j)。</p>
<p>数据保证有唯一解。</p>
<p><strong>输入格式</strong><br>第一行包含三个整数n，m，x，分别表示A的长度，B的长度以及目标值x。<br>第二行包含n个整数，表示数组A。<br>第三行包含m个整数，表示数组B。</p>
<p><strong>输出格式</strong><br>共一行，包含两个整数 i 和 j。</p>
<p><strong>数据范围</strong><br>数组长度不超过100000。<br>同一数组内元素各不相同。<br>$1≤$数组元素$≤10^9$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>4 5 6<br>1 2 4 7<br>3 4 6 8 9</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>1 1</p>
</blockquote>
<hr>
<h3 id="解法一：双指针"><a href="#解法一：双指针" class="headerlink" title="解法一：双指针"></a>解法一：双指针</h3><p>类似夹逼准则。充分利用两个数组都是递增的特性。<br>维护两个指针，指针i从数组1的低位向高位遍历，指针j从数组2的高位向低位遍历，一直向正确的数值逼近。<br>j先向左移动，直到找到一个数，使得与i对应的数之和小于目标值，此时排除掉j右侧所有数，正确的i和j应该分别分布在i的右侧和j的左侧。<br>i再向右移动，直到找到一个数，使得与j对应的数之和小于目标值，此时排除掉i左侧所有数，正确的i和j应该分布在i的右侧和j的左侧。<br>A数组：<code>i____________________________________</code><br>B数组：<code>______________________________&lt;-j</code><br>A数组：<code>i____________________________________</code><br>B数组：<code>____________________j_____被排除_____</code><br>A数组：<code>i-&gt;____________________________________</code><br>B数组：<code>____________________j_____被排除_____</code><br>A数组：<code>____被排除____i____________________________</code><br>B数组：<code>____________________j_____被排除_____</code><br>重复上述过程，直到找到正确的i和j。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, x;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] &gt; x) j -- ;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] == x) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度： <strong><em>O(N)</em></strong></p>
<h3 id="解法二：二分查找"><a href="#解法二：二分查找" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h3><p>对于数组1中的每个数，通过目标数计算出应该存在于数组2中的值，再用二分查找的方式在数组2中查找。<br>该方法只利用了一个数组的单调性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; l &lt; r;) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[mid] &gt;= t) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b[l] != t) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = x - a[i];</span><br><span class="line">        <span class="comment">// finds t in b</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">find</span>(t, m);</span><br><span class="line">        <span class="keyword">if</span> (j != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：<strong><em>O(NLogN)</em></strong></p>
<div class="note primary">
            <h4 id="原题链接："><a href="#原题链接：" class="headerlink" title="原题链接："></a>原题链接：</h4><p><a href="https://www.acwing.com/problem/content/description/802/" target="_blank" rel="noopener">AcWing 800.数组元素的目标和</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构模板</title>
    <url>/2020/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>[暂停更新]详尽地记录了各种数据结构模板，以及一些个人理解。</p>
<a id="more"></a>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="何为单链表"><a href="#何为单链表" class="headerlink" title="何为单链表"></a>何为单链表</h3><p>首先什么是链表呢，链表是一堆离散的结点，每个结点存了两个值，一个表示结点的数值，一个是next指针，它指向了下一个结点的位置。链表是一个递归的数据结构（俄罗斯套娃），如果给我们一个链表的头结点，我们可以遍历整个链表。可以认为链表某结点的next指针指向了其后面整个链表。<br>一个链表结点可以形象地看成：<br>[value]<br>[next ]<br>用数组模拟链表，一定要理解其本质。</p>
<h3 id="数组模拟链表的本质"><a href="#数组模拟链表的本质" class="headerlink" title="数组模拟链表的本质"></a>数组模拟链表的本质</h3><p>我们用一个数组A来存储数值，一个数组B来存储指针。一个链表结点分别由同一下标的两个数组元素构成。因为是用数组模拟链表，所以结点的指针用数组下标表示。<br>从0开始遍历两个数组，0代表第0次插入操作，每一次向链表中新插入数值，下标后移一位，相当于new一个新的结点。但是当删除操作时，下标不会移动。也就是说，删除结点时，结点依然在数组中，只是链表不会指向它。<br>另外，需要一个下标来表示整个链表的头结点，注意，头结点不一定在0位置（可能会在头结点前面插入新的结点）。<br>为什么要有头结点下标呢？这样可以很方便地对整个链表遍历，也很方便地在头结点出进行插入和删除操作。</p>
<h3 id="单链表模板"><a href="#单链表模板" class="headerlink" title="单链表模板"></a>单链表模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note primary">
            <p><strong>题目链接：</strong> <a href="https://fingerdance.plus/2020/11/12/AcWing-826-单链表/" target="_blank" rel="noopener">Acwing 826.单链表</a></p>
          </div>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h2 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h2><h2 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h2><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>和双指针思想类似，单调栈也是利用已知的某种性质，对暴力方法进行优化。</p>
<h2 id="单调队列（滑动窗口）"><a href="#单调队列（滑动窗口）" class="headerlink" title="单调队列（滑动窗口）"></a>单调队列（滑动窗口）</h2>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>堆</tag>
        <tag>链表</tag>
        <tag>栈</tag>
        <tag>单调栈</tag>
        <tag>算法模板</tag>
        <tag>AcWing</tag>
        <tag>字符串</tag>
        <tag>单链表</tag>
        <tag>双链表</tag>
        <tag>队列</tag>
        <tag>循环队列</tag>
        <tag>单调队列</tag>
        <tag>滑动窗口</tag>
        <tag>KMP</tag>
        <tag>Trie树</tag>
        <tag>并查集</tag>
        <tag>一般哈希</tag>
        <tag>字符串哈希</tag>
        <tag>C++ STL</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 826.单链表</title>
    <url>/2020/11/12/AcWing-826-%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>用数组模拟静态链表</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个单链表，链表初始为空，支持三种操作：<br>(1) 向链表头插入一个数；<br>(2) 删除第k个插入的数后面的数；<br>(3) 在第k个插入的数后插入一个数<br>现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。</p>
<p><strong>注意：</strong> 题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。</p>
<p><strong>输入格式</strong><br>第一行包含整数M，表示操作次数。<br>接下来M行，每行包含一个操作命令，操作命令可能为以下几种：<br>(1) “H x”，表示向链表头插入一个数x。<br>(2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。<br>(3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。</p>
<p><strong>输出格式</strong><br>共一行，将整个链表从头到尾输出。</p>
<p><strong>数据范围</strong><br>$1≤M≤100000$<br>所有操作保证合法。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>10<br>H 9<br>I 1 1<br>D 1<br>D 0<br>H 6<br>I 3 6<br>I 4 5<br>I 4 5<br>I 3 4<br>D 6</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>6 4 6 5</p>
</blockquote>
<hr>
<h3 id="何为链表"><a href="#何为链表" class="headerlink" title="何为链表"></a>何为链表</h3><p>首先什么是链表呢，链表是一堆离散的结点，每个结点存了两个值，一个表示结点的数值，一个是next指针，它指向了下一个结点的位置。链表是一个递归的数据结构（俄罗斯套娃），如果给我们一个链表的头结点，我们可以遍历整个链表。可以认为链表某结点的next指针指向了其后面整个链表。<br>一个链表结点可以形象地看成：<br>[value]<br>[next ]<br>用数组模拟链表，一定要理解其本质。</p>
<h3 id="数组模拟链表的本质"><a href="#数组模拟链表的本质" class="headerlink" title="数组模拟链表的本质"></a>数组模拟链表的本质</h3><p>我们用一个数组A来存储数值，一个数组B来存储指针。一个链表结点分别由同一下标的两个数组元素构成。因为是用数组模拟链表，所以结点的指针用数组下标表示。<br>从0开始遍历两个数组，0代表第0次插入操作，每一次向链表中新插入数值，下标后移一位，相当于new一个新的结点。但是当删除操作时，下标不会移动。也就是说，删除结点时，结点依然在数组中，只是链表不会指向它。<br>另外，需要一个下标来表示整个链表的头结点，注意，头结点不一定在0位置（可能会在头结点前面插入新的结点）。<br>为什么要有头结点下标呢？这样可以很方便地对整个链表遍历，也很方便地在头结点出进行插入和删除操作。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p><strong>向链表头插入一个数：</strong> 即更新头结点。在值域数组新的下标处放入插入的数的值，插入的结点指向了头结点位置，数组下标后移一位方便下次操作。<br><strong>删除第k个输入的数后面的数：</strong> 当k为0时，删除头结点，只需将head移动到head指向的结点；k不为0时，删除第k次插入的结点后面的结点，因为题目中描述“第k次插入”是从1开始计算的，所以此处需要删除下标为k-1的结点后面的结点。相当于是链表从k-1结点跳过它后面的结点，指向它后面的后面的结点。<br><strong>在第k个输入的数后面插入一个数：</strong> 题目说明此处k大于0。只需在值域数组新的下标处放入新插入的数的值，在指针域数组新的下标处放入下标为k-1的结点指向的下一个结点下标，再把下标为k-1的结点指向新的下标。另外，数组下标后移一位方便下次插入操作。</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx;                                             <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;                                                          <span class="comment">// 2</span></span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到头结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx ++ ;                         <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到下标是k的点后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;                       <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];                                                  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'H'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'D'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (!k) head = ne[head];                                    <span class="comment">// 6</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k - <span class="number">1</span>);                                         <span class="comment">// 7</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            add(k - <span class="number">1</span>, x);                                              <span class="comment">// 8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) <span class="built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="string">' '</span>;         <span class="comment">// 9</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><code>e[N]</code> 和 <code>ne[N]</code> 数组分别为链表结点的值域数组和指针域数组， <code>head</code> 为链表头结点下标， <code>idx</code> 为两个数组共用的游标，每当需要往链表中插入值时， <code>idx</code> 后移一位，相当于 <code>new</code> 一个新结点。</li>
<li><code>head</code>初始化为-1，表示初始状态链表头结点为<code>null</code>；<code>idx</code>初始化为0，表示将在两个数组的起始位置添加结点。因为题目的第「<code>k</code>」个数指的是从 <code>1</code> 起 第 <code>k</code> 个操作数，所以如果我们 <code>idx</code> 初始化为 <code>0</code> ，那么 <code>k</code> 和数组下标的对应关系是 <code>k - 1 == idx</code> 。接着我们注意到算法在使用 <code>k</code> 时是直接当数组下标用的，那是因为在 <code>7</code> <code>8</code> 处调用函数时，参数已经做了修正（<code>k - 1</code>）。当然可以让 <code>idx</code> 初始化为 <code>1</code> ，那么 <code>k</code> 和 <code>idx</code> 完全对应，可以直接使用，且调用函数时不需要修正。</li>
<li><code>new</code>一个新的结点，让结点的<code>next</code>指针指向<code>head</code>，游标后移。</li>
<li><code>new</code>一个新的结点，让结点的<code>next</code>指针指向下标<code>k</code>的下一位，游标后移。</li>
<li>跳过下标为<code>k</code>的结点。</li>
<li>注意到题干要求当<code>k</code>为0的情况。</li>
<li>注意题干的第<code>k</code>个结点是从1开始计数的，我们算法实现的<code>k</code>是下标<code>k</code>。</li>
<li>同上。</li>
<li><strong>链表的遍历：</strong> 从头结点下标开始<code>i = head</code>，到<code>null</code>结点结束<code>i == -1</code>。因为第一个操作必然是更新头结点（否则其他操作没法进行），接着将头结点指向 <code>-1(null)</code> ，即第一步必然是 <code>head -&gt; null</code> ，随后所有操作都在 <code>head</code> 和 <code>null</code> 之间进行。那么在所有操作结束之后，遍历链表，一定是以 <code>null</code> 结束。</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/828/" target="_blank" rel="noopener">Acwing 826.单链表</a></p>
          </div>

]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>AcWing</tag>
        <tag>单链表</tag>
        <tag>静态链表</tag>
      </tags>
  </entry>
  <entry>
    <title>ACWing 827.双链表</title>
    <url>/2020/11/13/ACWing-827-%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>数组模拟双链表模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个双链表，双链表初始为空，支持5种操作：<br>(1) 在最左侧插入一个数；<br>(2) 在最右侧插入一个数；<br>(3) 将第k个插入的数删除；<br>(4) 在第k个插入的数左侧插入一个数；<br>(5) 在第k个插入的数右侧插入一个数<br>现在要对该链表进行M次操作，进行完所有操作后，从左到右输出整个链表。</p>
<p><strong>注意：</strong> 题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。</p>
<p><strong>输入格式</strong><br>第一行包含整数M，表示操作次数。<br>接下来M行，每行包含一个操作命令，操作命令可能为以下几种：<br>(1) “L x”，表示在链表的最左端插入数x。<br>(2) “R x”，表示在链表的最右端插入数x。<br>(3) “D k”，表示将第k个插入的数删除。<br>(4) “IL k x”，表示在第k个插入的数左侧插入一个数。<br>(5) “IR k x”，表示在第k个插入的数右侧插入一个数。</p>
<p><strong>输出格式</strong><br>共一行，将整个链表从左到右输出。</p>
<p><strong>数据范围</strong><br>$1≤M≤100000$<br>所有操作保证合法。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>10<br>R 7<br>D 1<br>L 3<br>IL 2 10<br>D 3<br>IL 2 7<br>L 8<br>R 9<br>IL 4 7<br>IR 2 2</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>8 7 7 3 2 9</p>
</blockquote>
<hr>
<h3 id="数组模拟双链表的本质"><a href="#数组模拟双链表的本质" class="headerlink" title="数组模拟双链表的本质"></a>数组模拟双链表的本质</h3><p>双链表包含一个<code>head</code>结点一个<code>tail</code>结点（即使它是一个空链表，可以把<code>head</code>和<code>tail</code>看成是两个哨兵结点）。这两个结点可以看成是始终固定不动的。从双链表初始化起，到进行各种操作后形成最终链表，所有结点的增加和删除等操作均在<code>head</code>和<code>tail</code>中间进行。<br>对于双链表中的每个结点，我们用三个数组同一下标的元素表示。其中，包含一个结点值，一个前置指针（指向了结点前一个结点对应的数组下标），一个后置指针（指向了结点后一个结点对应的数组下标）。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为双链表的每个结点可以访问到其前后结点，所以对于这道题的每一个「插入」操作，都可以由一个方法实现。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"L"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            insert(<span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"R"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            insert(l[<span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"D"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"IL"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert(l[k + <span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert(k + <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) <span class="built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/829/" target="_blank" rel="noopener">Acwing 827.单链表</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>AcWing</tag>
        <tag>双链表</tag>
        <tag>静态链表</tag>
      </tags>
  </entry>
  <entry>
    <title>【AcWing算法基础】第二讲-数据结构-单调栈 AcWing 830. 单调栈</title>
    <url>/2020/11/14/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E6%A0%88-AcWing-830-%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道经典的单调栈模板题。</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 $-1$。</p>
<p><strong>输入格式</strong><br>第一行包含整数 $N$，表示数列长度。<br>第二行包含 $N$ 个整数，表示整数数列。</p>
<p><strong>输出格式</strong><br>共一行，包含 $N$ 个整数，其中第 $i$ 个数表示第 $i$ 个数的左边第一个比它小的数，如果不存在则输出 $-1$。</p>
<p><strong>数据范围</strong></p>
<ul>
<li>$1≤N≤10^5$ </li>
<li>$1≤$ 数列中元素 $≤10^9$</li>
</ul>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>5<br>3 4 2 7 5</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>-1 3 -1 2 2</p>
</blockquote>
<hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和双指针思想类似，我们先想一想暴力算法。可以使用两层循环，外层遍历整个数组，对于每一个数，内层循环向左寻找第一个小于这个数的数。<br>接着我们利用单调栈对暴力算法进行优化，我们可以在外层循环的过程中，维护一个元素大小单调递增的栈。对于原数组的每一个元素，我们将其与栈顶元素进行比较，如果比栈顶元素大，那么栈顶元素就符合要求，另外要将当前数组元素入栈，此时栈内元素保持了递增。<br>否则将栈顶元素弹出，依次比较栈中所有元素，直到找出第一个比当前数组元素小的。由于栈内元素是递增的，所以比较次数一定是最少的，这就实现了优化。在将栈顶元素弹出的过程，栈顶指针是向左移动的，在这个过程中，栈一直在被破坏、被削减，但是我们不必在意，因为之前的栈内元素已经帮助我们找到了之前数组元素的目标值了，我们将栈顶元素弹出，直到找到或者栈为空，此时的栈将保持维护栈的递增特性，继续为我们当前及以后的数组元素服务。<br>真是个美妙的思路。</p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><blockquote>
<ol>
<li>Q: 为什么要保持栈内元素大小的单调递增特性？<br>A: 由于栈内元素是递增的，所以比较次数一定是最少的，这就实现了优化。</li>
<li>Q: 如何保持栈内元素大小的递增性？<br>A: 在依次出栈比较栈顶元素和当前数组元素大小的时候，如果栈顶元素小，那么找到目标值，将当前数组元素入栈，这样保持了栈内元素大小的递增性；如果栈顶元素大，那么栈顶指针左移，直到找到目标值，再将当前数组元素入栈，这样就保持了栈内元素大小的递增性。我们不必在意这个过程破坏了栈的结构，因为之前的数已经找到之前数组元素对应的目标值了。</li>
<li>Q: 为什么栈顶元素若比当前数小则一定是左边最近的？<br>A: 因为栈内元素是按照原数组顺序递增排序的，那么栈顶如果比当前元素小，则一定是最近的。</li>
</ol>
</blockquote>
<p>注意，维护栈内元素的递增，并非是将栈内元素排序，排序是打乱了原来元素的先后顺序，而我们必须要保证栈内元素的先后顺序不变。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (; n --;) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (; tt &amp;&amp; stk[tt] &gt;= x; --tt) ;      <span class="comment">// 1</span></span><br><span class="line">                                                <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (!tt) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">" "</span>;             </span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; stk[tt] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        stk[++ tt] = x;                         <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<blockquote>
<ol>
<li>比较栈顶元素和当前元素，栈为空时不必比较。</li>
<li>此时找到目标值，或者栈为空。</li>
<li>入栈保持栈的递增。</li>
</ol>
</blockquote>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>对于这种需要维护一个性质的问题，通常可以这样思考：先假设有这样一个性质，再考虑如何构造和维护这个性质。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/832/" target="_blank" rel="noopener">AcWing 830. 单调栈</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>AcWing</category>
        <category>算法基础课</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>单调栈</tag>
        <tag>AcWing</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 828.模拟栈</title>
    <url>/2020/11/13/AcWing-828-%E6%A8%A1%E6%8B%9F%E6%A0%88/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>数组模拟栈模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个栈，栈初始为空，支持四种操作：</p>
<p>(1) “push x” – 向栈顶插入一个数x；<br>(2) “pop” – 从栈顶弹出一个数；<br>(3) “empty” – 判断栈是否为空；<br>(4) “query” – 查询栈顶元素。</p>
<p>现在要对栈进行M个操作，其中的每个操作3和操作4都要输出相应的结果。</p>
<p><strong>输入格式</strong><br>第一行包含整数M，表示操作次数。<br>接下来M行，每行包含一个操作命令，操作命令为”push x”，”pop”，”empty”，”query”中的一种。</p>
<p><strong>输出格式</strong><br>对于每个”empty”和”query”操作都要输出一个查询结果，每个结果占一行。<br>其中，”empty”操作的查询结果为“YES”或“NO”，”query”操作的查询结果为一个整数，表示栈顶元素的值。</p>
<p><strong>数据范围</strong><br>$1≤M≤100000$,<br>$1≤x≤10^9$<br>所有操作保证合法。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>10<br>push 5<br>query<br>push 6<br>pop<br>query<br>pop<br>empty<br>push 4<br>query<br>empty</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>5<br>5<br>YES<br>4<br>NO</p>
</blockquote>
<hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>维护一个数组和一个指针，数组存储所有入栈的数，指针指向栈顶元素。<br>入栈：指针右移，将数放入新的位置。<br>出栈：指针左移一位。<br>获取栈顶元素：直接返回指针指向的数、<br>判空：如果指针&gt;=0即非空。</p>
<p>以上为数组模拟栈的基本操作，可见数组模拟栈是非常简单的。当然还可以进行很多魔改。比如当前出栈是不返回任何结果的，但是我们可以让它返回出栈的元素；以及各种边界条件判断等等。用C++ STL的栈能实现的，用数组都可以实现，而用数组可以实现更多STL栈所实现不了的。</p>
<p><strong>在算法竞赛中，由于数据量往往很大，用STL容器（包括链表，hashmap等）会很慢。</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> stk[N], tt;                         <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stk[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tt--;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tt &gt;= <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stk[tt];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    tt = <span class="number">-1</span>;                            <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (; n --;) &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"push"</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"pop"</span>) &#123;</span><br><span class="line">            pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"empty"</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (empty() ? <span class="string">"NO"</span> : <span class="string">"YES"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// query</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><code>tt</code>为栈顶指针。</li>
<li>让栈从数组下标为0处放入数据，因为<code>tt</code>是栈顶指针，在<code>push</code>的时候必须先向右移动一位，所以这里初始化为 <code>-1</code> 。当然也可以让<code>tt</code>初始化为  <code>0</code> ，这样从数组下标1处放入数据，在判空的时候可以 <code>tt ? &quot;NO&quot; : &quot;YES&quot;</code> ，看个人习惯吧。</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/830/" target="_blank" rel="noopener">828.模拟栈</a></p>
          </div>




]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>AcWing</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 820.模拟队列</title>
    <url>/2020/11/15/AcWing-820-%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>数组模拟队列模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个队列，队列初始为空，支持四种操作：</p>
<p>(1) “push x” – 向队尾插入一个数x；<br>(2) “pop” – 从队头弹出一个数；<br>(3) “empty” – 判断队列是否为空；<br>(4) “query” – 查询队头元素。<br>现在要对队列进行M个操作，其中的每个操作3和操作4都要输出相应的结果。</p>
<p><strong>输入格式</strong><br>第一行包含整数M，表示操作次数。<br>接下来M行，每行包含一个操作命令，操作命令为”push x”，”pop”，”empty”，”query”中的一种。</p>
<p><strong>输出格式</strong><br>对于每个”empty”和”query”操作都要输出一个查询结果，每个结果占一行。<br>其中，”empty”操作的查询结果为“YES”或“NO”，”query”操作的查询结果为一个整数，表示队头元素的值。</p>
<p><strong>数据范围</strong><br>$ 1≤M≤100000 $,<br>$ 1≤x≤109 $,<br>所有操作保证合法。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>10<br>push 6<br>empty<br>query<br>pop<br>empty<br>push 3<br>push 4<br>pop<br>query<br>push 6</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>NO<br>6<br>YES<br>4</p>
</blockquote>
<hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>维护一个数组，用于存放队列中的数；维护一个头指针，一个尾指针，分别用于指向队列的头部和尾部。我们在尾部放入元素，在头部取出元素。当头指针位置在尾指针左侧意味着队列非空，可以初始化头指针和尾指针分别为0和-1.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[hh];                               </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tt &lt; hh;                                         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q[++ tt] = x;                                               </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;                                              <span class="comment">// 1         </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (; m--;) &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"push"</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"pop"</span>) &#123;</span><br><span class="line">            hh ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"empty"</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (empty() ? <span class="string">"YES"</span> : <span class="string">"NO"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>初始化头指针和尾指针，值不一定非得是<code>0,-1</code>。当我们初始化为<code>0,-1</code>时，头指针在尾指针右边，表明当前队列为空。为什么初始化 <code>hh</code> 要在 <code>tt</code> 右边呢？一般来说，因为考虑队列仅有一个值的情况，此时必须要让 <code>hh</code> 和 <code>tt</code> 指向同一个值（重叠），所以初始化 <code>tt</code> 要在 <code>hh</code> 左边偏移一位，这样我在第一次 <code>push</code> 的时候, <code>tt++</code> ，和 <code>hh</code> 刚好重叠。也正因为如此，可以用 <code>hh</code> 与 <code>tt</code> 的相对位置来判空。</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong><a href="https://www.acwing.com/problem/content/831/" target="_blank" rel="noopener">AcWing 820.模拟队列</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AcWing</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>【AcWing算法基础】第二讲-单调队列-滑动窗口 AcWing 154. 滑动窗口</title>
    <url>/2020/11/16/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-AcWing-154-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>单调队列的模板题，滑动窗口经典应用。</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个大小为 $n≤10^6$ 的数组。<br>有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。<br>您只能在窗口中看到k个数字。<br>每次滑动窗口向右移动一个位置。<br>以下是一个例子：<br>该数组为[1 3 -1 -3 5 3 6 7]，k为3。</p>
<table>
<thead>
<tr>
<th>窗口位置</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>[1 3 -1] -3 5 3 6 7</td>
<td>-1</td>
<td>3</td>
</tr>
<tr>
<td>1 [3 -1 -3] 5 3 6 7</td>
<td>-3</td>
<td>3</td>
</tr>
<tr>
<td>1 3 [-1 -3 5] 3 6 7</td>
<td>-3</td>
<td>5</td>
</tr>
<tr>
<td>1 3 -1 [-3 5 3] 6 7</td>
<td>-3</td>
<td>5</td>
</tr>
<tr>
<td>1 3 -1 -3 [5 3 6] 7</td>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>1 3 -1 -3 5 [3 6 7]</td>
<td>3</td>
<td>7</td>
</tr>
</tbody></table>
<p>您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p>
<p><strong>输入格式</strong><br>输入包含两行。<br>第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。<br>第二行有n个整数，代表数组的具体数值。<br>同行数据之间用空格隔开。</p>
<p><strong>输出格式</strong><br>输出包含两个。<br>第一行输出，从左至右，每个位置滑动窗口中的最小值。<br>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>8 3<br>1 3 -1 -3 5 3 6 7</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>-1 -3 -3 -3 3 3<br>3 3 5 5 6 7</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="comment">// 求每个窗口最小值</span></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 判断队头是否已经滑出窗口，如果已经滑出了窗口，队列从hh处弹出一个数</span></span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++ ;</span><br><span class="line">        <span class="comment">// 在i加入到队尾之前，先维护队列的单调递增性</span></span><br><span class="line">        <span class="comment">// 如果a[i]比队尾对应值小的话，那么不能加入队列，否则队列会递减，此时队尾向左移动，直到在队列中找到一个值使得a[i]比它大（或者找完队列也没有找到）。那么这个时候再将i入队的话，对应的值就会单调递增了。</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ;</span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line">        <span class="comment">// 因为i表示窗口末端或者说队尾，而它又是从0开始的，那么在窗口完全进入数组之前，不需要输出最值。</span></span><br><span class="line">        <span class="comment">// 即：i对应的窗口左端为i - k + 1，当i - k + 1 &lt; 0时，是不需要输出最小值的。</span></span><br><span class="line">        <span class="comment">// 但是由于需要从i = 0起开始维护队列的单调性，所以之前过程不能省略。</span></span><br><span class="line">        <span class="comment">// 我们怎么能知道此时队列头对应的数一定是最小的呢？（当队列数量小于k的时候）</span></span><br><span class="line">        <span class="comment">// 因为不管队列长度是刚好等于窗口长度，还是小于窗口长度，最左边的数一定是最小的。妙啊！</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]); <span class="comment">// 因为队列内部元素对应数组汇中的值是单调递增的，所以可以在O                                        // (1)的时间复杂度内找到最小值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求每个窗口最大值</span></span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt -- ;</span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>对于这种需要维护一个性质的问题，通常可以这样思考：先假设有这样一个性质，再考虑如何构造和维护这个性质。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/156/" target="_blank" rel="noopener">AcWing 154. 滑动窗口</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AcWing</tag>
        <tag>队列</tag>
        <tag>单调队列</tag>
        <tag>滑动窗口</tag>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 831.KMP字符串</title>
    <url>/2020/11/17/AcWing-831-KMP%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>闪耀着人类智慧之光的——KMP算法。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p> 给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。<br>模板串P在模式串S中多次作为子串出现。<br>求出模板串P在模式串S中所有出现的位置的起始下标。</p>
<p><strong>输入格式</strong><br>第一行输入整数N，表示字符串P的长度。<br>第二行输入字符串P。<br>第三行输入整数M，表示字符串S的长度。<br>第四行输入字符串S。</p>
<p><strong>输出格式</strong><br>共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。</p>
<p><strong>数据范围</strong><br>$1≤N≤10^5$, $1≤M≤10^6$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>3<br>aba<br>5<br>ababa</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>0 2</p>
</blockquote>
<hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>模式串S<code>______Sa__________N______________</code><br>模板串P<code>######Pa__________N</code><br>假设当 <code>S</code> 和 <code>P</code> 从 <code>a</code> 点开始匹配时，到 <code>N</code> 点恰好发现一个字符不匹配，暴力做法我们是让 <code>P</code> 向右偏移一位，从头开始和 <code>S</code> 一一比对。但是存在一些字符是之前已经比对匹配过的，我们可以跳过它们以达到优化目的。<br>我们现在的目标就变成了： <strong>如何利用已经比对匹配过的字符已达到优化目的？</strong><br>设想如果我们能找到这样一个平移量 <code>x</code> 使得当我们把 <code>P</code> 串向右移动 <code>x</code> 位时：<br>模式串S<code>______Sa___x________N______________</code><br>模板串P<code>######Pa___x________N</code><br>模板串P<code>##########Px________N_____</code>（移动x位后的）<br>恰好使得在 <code>P</code> 串和 <code>S</code> 串中从 <code>x</code> 点到上次出现不同字符的 <code>N</code> 点中所有数相同，那么如果发现了这个 <code>x</code> 值，就可以从这里开始让两串匹配，从而完成优化。<br>即 <code>P</code> 串移动一个 <code>x</code> 使得 <code>P</code> 串的某一前缀与 <code>S</code> 串的后缀完全相等，在移动前， <code>S</code> 串的后缀与 <code>P</code> 串后缀已经比较过，完全相等。那么问题就转化成，能否找到这样一个 <code>x</code> 使得，在 <code>P</code> 串内部， <code>P</code> 串的前缀与后缀完全相等。 <code>x</code> 和前后缀的关系是： <code>x + 前缀或后缀 == Pa_N</code> 。（这里的前后缀是相对 <code>Sa_N</code> 和 <code>Pa_N</code> 而言）。<br>以上叙述可形象的看成：<br>模板串P<code>|___x___|_______suf_______|</code><br>模板串P<code>########|_______pre_______|___x___|</code><br>其中， <code>suf == pre</code> 。<br>当我们找到了这个 <code>x</code> 还远远不够，因为可能存在多个这样的 <code>x</code> ，为了使优化效果最好，我们尽可能地希望这个 <code>x</code> 越小越好（ <code>x</code> 最小可取到 <code>1</code> ，因为后面已经发生不匹配情况，如果取 <code>0</code> 的话造成矛盾）,当 <code>x</code> 取到 <code>1</code> 的时候，事实就是 <code>P</code> 串向后平移一位，恰好可以跳过从此处到上次不匹配的地方所有数，接着在上一次不匹配的地方又发生了不匹配的情况？</p>
<p><strong>next数组：</strong><br>计算next数组的时候，next[j]的值是在p串中，寻找一个值，使得以j为终点的某一段后缀与以这个值为终点的前缀完全相等，并且后缀与前缀要尽可能地长。举例：<br>i: 1 2 3 4 5 6 7 8 9<br>s: a b a b a b c b d<br>p: a b a b a b a b<br>p: # # a b a b a b a b<br>此时，i == 7, j + 1 == 7, j == 6;<br>next[j]的值，应该为让以j为终点的后缀a b a b与以这个值为终点的前缀a b a b相等，这时next[j] = 4.</p>
<p>对于p串，next数组的值为：<br>idx: 1 2 3 4 5 6 7 8<br>nex: 0 0 1 2 3 4 5 6<br>其中，当idx分别取1和2时，即j对应停留在1和2时，next值找不到满足条件的值，取0是为了退到起点让下一位i ++之后，和j + 1也就是 j == 1作比较。<br>idx == 3时，以下标3为后缀的a与以1为后缀的a相等。next[3] = 1;<br>idx == 4时，以下标4为后缀的a b与以2为后缀的a b相等。next[4] = 2;<br>idx == 5时，以下标5为后缀a b a与以3为后缀的a b a相等。next[5] = 3;<br>idx == 6时，以下标6为后缀a b a b与以4为后缀的a b a b相等。next[6] = 4;<br>idx == 7时，以下标7为后缀a b a b a与以5为后缀的a b a b a相等。next[7] = 5;<br>idx == 8时，以下标8为后缀a b a b a b与以6为后缀的a b a b a b相等。next[8] = 6;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="keyword">char</span> s[M], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;                        <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )                   <span class="comment">// 2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];            <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;                        <span class="comment">// 4</span></span><br><span class="line">        ne[i] = j;                                          <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )                   <span class="comment">// 6</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];            <span class="comment">// 7</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;                        <span class="comment">// 8</span></span><br><span class="line">        <span class="keyword">if</span> (j == n)                                         <span class="comment">// 9</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, i - n);                           <span class="comment">// 10</span></span><br><span class="line">            j = ne[j];                                      <span class="comment">// 11</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li></li>
</ol>
</blockquote>
<p>###<br>待更新。</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AcWing</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>【AcWing算法基础】第一讲-基础算法-前缀和与差分 AcWing 795. 前缀和</title>
    <url>/2020/11/10/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86-AcWing-795-%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>前缀和模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个长度为 $n$ 的整数序列。<br>接下来再输入 $m$ 个询问，每个询问输入一对 $l$, $r$。<br>对于每个询问，输出原序列中从第 $l$ 个数到第 $r$ 个数的和。</p>
<p><strong>输入格式</strong><br>第一行包含两个整数 $n$ 和 $m$。<br>第二行包含 $n$ 个整数，表示整数数列。<br>接下来 $m$ 行，每行包含两个整数 $l$ 和 $r$，表示一个询问的区间范围。</p>
<p><strong>输出格式</strong><br>共 $m$ 行，每行输出一个询问的结果。</p>
<p><strong>数据范围</strong><br>$ 1≤l≤r≤n $,<br>$1≤n$, $m≤100000$,<br>$−1000≤$ 数列中元素的值 $≤1000$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>5 3<br>2 1 3 6 4<br>1 2<br>1 3<br>2 4</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3<br>6<br>10</p>
</blockquote>
<hr>
<p>此题考查前缀和数组的构造。对于一个给定数组<code>alls[N]</code>，其前缀和数组<code>s[N]</code>对应着对于<code>alls[N]</code>的每一个元素，其前缀所有元素（包括这一位）之和。<br>前缀和数组的应用一般伴随着一些查询操作，一个查询操作就是给定一个区间范围，让你求该范围内数的和。<br>另外，注意构造前缀和数组是从下标1开始构造，整体数目不变。相当于是数组下标向右偏移一位。这是因为构造前缀和数组的每一位需要依赖其前一位。当构造第1位时，需要依赖第0位。</p>
<div class="tabs" id="g_tab"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> alls[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">cin</span> &gt;&gt; alls[i];                  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">int</span> s[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;                                <span class="comment">// 2</span></span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + alls[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; m -- ;) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;          </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;                            <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<blockquote>
<ol>
<li>从下标1开始读取数组，整体向右偏移一位方便查询。</li>
<li>从下标1开始构建前缀和数组。</li>
<li>查询时，<code>s[r] - s[l]</code>多减了一个<code>alls[l]</code>，所以要<code>s[r] - s[l - 1]</code>。</li>
</ol>
</blockquote>
<p>下面来思考一下预处理前缀和数组的时候，为什么 <code>i</code> 从 <code>1</code> 开始，前缀和数组第 <code>0</code> 位留空。</p>
<p>首先我们假设前缀和数组就是从第 <code>0</code> 位开始，即 <code>presum[i]</code> 对应原数组 $[0,i]$ 位元素的和。会发生什么呢？<br>假设求从 <code>0</code> 开始计算的第 <code>4</code> 位到第 <code>5</code> 位子数组和，那么使用这样一个前缀和数组可得：<br><code>int res = presum[5] - presum[4 - 1];</code><br>似乎没有问题，好，那我现在求第 <code>0</code> 位到第 <code>3</code> 位子数组的和：<br><code>int res = presum[3] - presum[0 - 1];</code><br>数组下标出现负数，为了避免这种情况，只能多一次判断，不方便。</p>
<p>另外，在生成前缀和数组时，递推公式为：<code>presum[i] = presum[i - 1] + nums[i]</code>.<br>问题是，这个递推公式无法适配所有情况。即，当 <code>i</code> 取 <code>0</code> 时，出现异常。<br>为了避免这个情况，只能把 <code>presum[0]</code> 拿出来预设为 <code>nums[0]</code> ，从数组第 <code>1</code> 项接着按照递推公式计算。不方便。</p>
<p>那么，为了方便地避免以上情况，我们决定将前缀和数组相对原数组向右偏移一位，用 <code>presum[1]</code> 表示原数组第 <code>0</code> 项， <code>presum[2]</code> 表示原数组第 <code>[0,1]</code> 项之和，将 <code>presum[i]</code> 表示为数组中 $[0,i-1]$ 所有数之和。</p>
<p>那么，如果求原数组从零计第 <code>l</code> 项到 <code>r</code> 项子数组之和，那么<br><code>int res = presum[r + 1] - presum[l + 1 - 1];</code><br>因为 <code>presum[r]</code> 表示的是 $[0, r-1]$ 项之和， <code>presum[l]</code> 表示 $[0,l-1]$ 项之和。<br>另外，如果求原数组从1计算第 <code>l</code> 项到 <code>r</code> 项子数组之和，可以直接：<br><code>int res = presum[r] - presum[l - 1];</code></p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/797/" target="_blank" rel="noopener">AcWing 795. 前缀和</a></p>
          </div>

]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>AcWing</category>
        <category>算法基础课</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>前缀和</tag>
        <tag>AcWing</tag>
      </tags>
  </entry>
  <entry>
    <title>Thousands of cars form lines to collect food in Texas [CNN]</title>
    <url>/2020/11/16/Thousands-of-cars-form-lines-to-collect-food-in-Texas-CNN/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>CNN news</p>
<a id="more"></a>
<hr>
<p>(CNN)Thousands of people lined up for <strong>groceries</strong> at a food bank distribution event in Dallas, Texas, this weekend, with organizers saying the Covid-19 <strong>pandemic</strong> has increased need in the city.</p>
<blockquote>
<p>groceries杂货; pan’demic大流行; </p>
</blockquote>
<p>North Texas Food Bank (NTFB) distributed more than 600,000 pounds of food for about 25,000 people on Saturday, according to spokeswoman Anna Kuruan. There were 7,280 turkeys distributed to families, Kuruan told CNN.</p>
<p>Photos provided by NTFB show thousands of cars lined up for NTFB’s Drive-Thru Mobile Pantry at Fair Park. Kuruan said the need for food “has certainly increased” with the pandemic, with Texas last week becoming the first US state to report 1 million cases of coronavirus.</p>
<p>“Forty percent of the folks coming through our partners doors are doing so for the first time,” she said.</p>
<p>“I see blessings coming to us cause we all struggling. And I appreciate North Texas helping us out,” Dallas resident Samantha Woods told CNN affiliate KTVT as she waited in her vehicle.</p>
<p>“It really is amazing and I thank God that I was able to get in the line this morning.”</p>
<p>In another car, one woman told the station she had been struggling: “I haven’t been working since December. I can’t find a job, they cut off my unemployment – it’s a big deal. It’s a real big deal.”</p>
<blockquote>
<p>unemployment失业; </p>
</blockquote>
<p>NTFB President Trisha Cunningham said she is proud of her team and the community “for providing some hope and care during these extraordinary times.”</p>
<blockquote>
<p>extraordinary特殊的，非凡的; </p>
</blockquote>
<p>“It was quite a humbling scene to see so many in need,” she told CNN.</p>
<blockquote>
<p>humbling沮丧;</p>
</blockquote>
<p>NTFB has several mobile pantry events scheduled throughout the week.</p>
<blockquote>
<p>pantry储藏室;</p>
</blockquote>
<div class="note primary">
            <p><strong>OriginalLink:</strong> <a href="https://us.cnn.com/2020/11/15/us/dallas-texas-food-bank-coronavirus/index.html" target="_blank" rel="noopener">Thousands of cars form lines to collect food in Texas</a></p>
          </div>]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>News</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 5606.具有给定数值的最小字符串 [第216场周赛]</title>
    <url>/2020/11/22/LeetCode-5606-%E5%85%B7%E6%9C%89%E7%BB%99%E5%AE%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%AC%AC216%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>力扣第216场周赛第二题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>小写字符</strong> 的 <strong>数值</strong> 是它在字母表中的位置（从 <code>1</code> 开始），因此 <code>a</code> 的数值为 <code>1</code> ，<code>b</code> 的数值为 <code>2</code> ，<code>c</code> 的数值为 <code>3</code> ，以此类推。<br>字符串由若干小写字符组成，字符串的数值 为各字符的数值之和。例如，字符串 <code>&quot;abe&quot;</code> 的数值等于 <code>1 + 2 + 5 = 8</code> 。<br>给你两个整数 <code>n</code> 和 <code>k</code> 。返回 <strong>长度</strong> 等于 <code>n</code> 且 <strong>数值</strong> 等于 <code>k</code> 的 <strong>字典序最小</strong> 的字符串。<br>注意，如果字符串 <code>x</code> 在字典排序中位于 <code>y</code> 之前，就认为 <code>x</code> 字典序比 <code>y</code> 小，有以下两种情况：</p>
<ul>
<li><code>x</code> 是 <code>y</code> 的一个前缀；</li>
<li>如果 <code>i</code> 是 <code>x[i] != y[i]</code> 的第一个位置，且 <code>x[i]</code> 在字母表中的位置比 <code>y[i]</code> 靠前。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：n = 3, k = 27<br>输出：”aay”<br>解释：字符串的数值为 1 + 1 + 25 = 27，它是数值满足要求且长度等于 3 字典序最小的字符串。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：n = 5, k = 73<br>输出：”aaszz”</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= n &lt;= 10^5$</li>
<li>$n &lt;= k &lt;= 26 * n$</li>
</ul>
<hr>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>一共 <code>n</code> 位，我们从第 <code>1</code> 位起，依次按字母表顺序尝试字母是否符合要求。<br>由题可知，<code>n</code> 位数值和的范围是：$n &lt;= k &lt;= 26 * n$，即 <code>n</code> 位的数值和最小取到 <code>n</code> ，这是 <code>n</code> 个 <code>a</code> 的情况；最大取到 <code>26 * n</code>，这是 <code>n</code> 个 <code>z</code> 的情况。<br>一个字母符合要求当且仅当使用了它之后，剩余的数值要在后面所有位的数值和规定的范围内。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getSmallestString</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">1</span> ; i &lt;= n; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k - sum - j &gt;= n - i  &amp;&amp; k - sum - j &lt;= <span class="number">26</span> * (n - i)) &#123;</span><br><span class="line">                    res += ((<span class="keyword">char</span>)((<span class="keyword">int</span>)<span class="string">'a'</span> + j - <span class="number">1</span>));</span><br><span class="line">                    sum += j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>模拟</tag>
        <tag>竞赛</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Health</title>
    <url>/2020/11/23/Health/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>About Health</p>
<a id="more"></a>
<p>从今天起，注意身体，保持健康。</p>
<h3 id="肾脏早期损害指标"><a href="#肾脏早期损害指标" class="headerlink" title="肾脏早期损害指标"></a>肾脏早期损害指标</h3><p><strong>肾小球率过滤</strong> 一般都是用内生肌酐清除率代替的，检查方便，经济（血和尿同时检测），但是和真实的GFR还是有差距的，一般人到了四十岁之后，本身GFR是会每年下降的，但是对于有肾小球肾炎、高血压、糖尿病的患者GFR的下降速度比正常人就快了，其实肾内科最主要的目的就是尽可能的减慢这个衰减，要想彻底阻拦他，目前是没有好办法的，因为到了尿毒症期，也就是GFR小于10的时候，就需要血液透析了（对于急性肾损伤的患者不予讨论），<u>所以这个指标对于疾病早期的诊断而言意义可能不是很大，因为肾脏有强大的代偿能力，你看到就算只有一个肾的人也能活的好好的，早期肾脏损伤的时候GFR并不一定有变化，</u>而且对于糖尿病肾病而言，初期GFR可能还会增高。</p>
<p><strong>微球蛋白</strong>，包括a1和β2，血和尿中的意义不太一样，血中的话炎症、肿瘤、系统性疾病都会高，而对于尿液而言，<u>这类的升高可能代表肾小管重吸收功能的损伤</u>，NAG是小管上皮细胞含量多，尿中NAG的增高提示小管上皮细胞的损伤，当然也会影响到了重吸收功能。免疫球蛋白则是大分子蛋白，肾脏科中选择性尿蛋白和非选择性尿蛋白的区分，就是前者是IgG和白蛋白同时在尿中出现，后者则是仅仅有白蛋白，前者的意义是说明肾小球分子屏障已经损伤，后者可能是小球电荷屏障损伤，前者的病情较后者更重。其实还有纤维蛋白降解产物之类的指标，也是表示肾脏高凝及重吸收障碍的。至于24小时尿蛋白定量和微量白蛋白，都是针对肾脏病小球损伤后小便尿蛋白到底有多少的一个定量检测。</p>
<p>所以题主说题主家人如果有高血压、糖尿病的病史，担心累及肾脏而最终导致肾功能不全，其实最最根本的就是控制好原发病，也就是说高血压和糖尿病，他们本身就会对全身多个系统器官造成损伤，需要的是一个综合的治疗。初期检测太多的那些肾脏指标，每次去复诊都做一套又麻烦，性价比又低，所以门诊常规的肾功能、尿常规做一个筛选性质的，发现有问题，再做深入的检查才是遵循了适合的诊疗过程，所以定期随访肾功能、尿常规是有意义的，而进一步的检查等到发现了问题再查好了，你不怕麻烦，那也随你。门诊上很多病人一查肾功能肌酐一千多，尿蛋白4+的，都是没有控制原发病，没有定期随访的，真到了肌酐增高、GFR下降、大量尿蛋白，说到底，那时候查什么指标都是徒劳，肾脏损伤是不可逆的。</p>
<p><em>参考</em></p>
<blockquote>
<p>作者：肖信<br>链接：<a href="https://www.zhihu.com/question/28962085/answer/42803946" target="_blank" rel="noopener">https://www.zhihu.com/question/28962085/answer/42803946</a></p>
</blockquote>
<p><strong>β2微球蛋白</strong><br>1、β2—微球蛋白水平是反映肾小球滤过功能的灵敏指标<br>　　 (1) β2—微球蛋白在体内产生速率恒定，其血浆中含量不受年龄、性别、机体肌肉组织多少等因素的影响；而且β2—微球蛋白相对分子量小，可自由通过肾小球，且仅由肾脏排泄，因此，测定血浆中β2—微球蛋白水平比检测血清肌酐水平用于评价肾功能更加灵敏，β2—微球蛋白可作为反映糖尿病和高血压肾损害的早期指标。(2)血浆中β2—微球蛋白水平升高，可反映肾小球滤过功能受损或滤过负荷增加的情况，而尿液中β2—微球蛋白含量增高，则提示肾小管损害或滤过负荷增加；若血浆中β2—微球蛋白水平升高而尿液中β2—微球蛋白含量正常，则主要由肾小球滤过功能下降所致，常见于急慢性肾炎、肾功能衰竭等；若血浆中β2—微球蛋白含量正常而尿液中β2—微球蛋白含量升高，则主要由肾小管重吸收功能受损所致，多见于先天性近曲小管功能缺陷、科尼综合征、慢性镉中毒、Wilson病、肾移植排斥反应等；若血浆和尿液中β2—微球蛋白含量均升高，则主要由体内某些部位产生β2—微球蛋白过多或肾小球和肾小管均受到损伤所致。<br>　　2、β2—微球蛋白水平是反映肾小管重吸收功能的灵敏指标<br>　　 (1)肾小球滤过率是估价肾功能的一个重要指标，而由肾小球滤过的β2—微球蛋白，约99．9%在近端肾小管被重吸收，并在此全部被分解成氨基酸，若肾小管重吸收功能受损伤，则进入尿液中的β2—微球蛋白必然增多，故尿液中β2—微球蛋白测定是诊断肾小管疾病较灵敏且特异的方法。(2)急慢性肾衰竭患者尿液中β2—微球蛋白含量升高明显，最高可最达40 mg/L，尿液中有如此高水平的β2—微球蛋白，不能单纯解释为滤过负荷增加，其表明了肾小管必然遭受了严重的损害。(3)测定血浆及尿液中β2—微球蛋白含量，对肾脏疾病的鉴别诊断、病情估计及预后判断都能提供有价值的数据。 [1]<br><em>参考</em></p>
<blockquote>
<p>百度百科<br><a href="https://baike.baidu.com/item/%E5%BE%AE%E7%90%83%E8%9B%8B%E7%99%BD/5597230?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%BE%AE%E7%90%83%E8%9B%8B%E7%99%BD/5597230?fr=aladdin</a></p>
</blockquote>
<h3 id="生活习惯"><a href="#生活习惯" class="headerlink" title="生活习惯"></a>生活习惯</h3><p>保持良好生活习惯，减少伤害肾脏的一切行为<br>肾病患者的各项指标经过治疗得到稳定后，一定要保持良好的作息习惯。<br>生活上面——不要通宵熬夜，避免过度抽烟和饮酒，以及剧烈的运动等，要爱惜肾脏，避免复发。<br>饮食上面——注意低盐、低蛋白、低钾、低磷、低脂的饮食原则，食盐摄入量不应超过3克，可以保护血压和蛋白尿的稳定，并同时减少肾功能的负担。<br>情绪上面——保持良好的心态很重要，心情平和，对病情恢复有帮助，要相信自己，通过治疗和调理，是一定可以恢复的。</p>
<h3 id="24-h尿蛋白和尿NAG与尿蛋白-肌酐比值及尿NAG-肌酐比值的相关性研究"><a href="#24-h尿蛋白和尿NAG与尿蛋白-肌酐比值及尿NAG-肌酐比值的相关性研究" class="headerlink" title="24 h尿蛋白和尿NAG与尿蛋白/肌酐比值及尿NAG/肌酐比值的相关性研究"></a>24 h尿蛋白和尿NAG与尿蛋白/肌酐比值及尿NAG/肌酐比值的相关性研究</h3><p>邵天波, 郭翀, 杨兰辉, 石洪琼, 段勇<br>摘要<br>关键词: 总蛋白; 白蛋白; N-乙酰-β-D-氨基葡萄糖苷酶; 肌酐; 尿液<br>中图分类号:R446.1 文献标志码:A 文章编号:1673-8640(2010)05-0385-02<br>Abstract<br>Keyword:<br>尿蛋白和尿N-乙酰-β -D-氨基葡萄糖苷酶(NAG)的检测对指导肾脏疾病的诊断、治疗、疗效评价和预后判断都具有重要意义。长期以来, 24 h尿蛋白的测定是尿蛋白定量的“ 金标准” 。然而对于24 h尿样本, 也常是采用混匀后对部分样本进行检测完成的, 因此留尿后若提取样本时未充分摇匀或尿液浓缩或稀释等均可影响尿蛋白含量。本研究对81例不同肾脏疾病肾功能损伤患者的尿液样本进行24 h尿微量总蛋白(mTP)、尿微量白蛋白(mAlb)、尿NAG和尿肌酐(Cr)定量检测, 分别计算mTP/Cr比值、mAlb/Cr比值、NAG/Cr比值, 探讨他们之间的相关性。</p>
<p><strong>材料和方法</strong><br>一、研究对象<br>患者均为昆明医学院第一附属医院肾内科、糖尿病科的住院患者, 年龄15~77岁。其中各类肾炎及肾病综合征患者55例, 糖尿病肾病患者26例, 共收集尿液样本81份。</p>
<p>二、方法</p>
<ol>
<li>尿液样本采集 选择清洁容器收集24 h尿液, 记录24 h总尿量并将收集的尿液混匀后取4~5 mL送检。</li>
</ol>
<p>2.仪器、试剂和方法 OLYMPUS AU5400全自动生化分析仪。尿液总蛋白液体试剂盒(邻邦苯三酚红/钼酸盐法)由德赛诊断系统(上海)有限公司提供; 尿mAlb试剂(免疫散射比浊法)由芬兰Orion诊断公司提供; NAG试剂(比色法)由金斯尔北京九强生物技术有限公司提供。</p>
<p>三、项目及计算<br>对尿液样本进行24 h尿mTP、mAlb、NAG和Cr定量检测, 分别计算mTP/Cr比值、mAlb/Cr比值、NAG/Cr比值, 并将所得比值与24 h尿mTP、mAlb及NAG定量结果进行比对。</p>
<p>四、统计学方法<br>数据处理采用SPSS 软件进行秩和检验, 检验数据采用为中位数(四分位间距)表示。</p>
<p><strong>结 果</strong><br>24 h尿Cr为0.83(0.63<del>1.08)g/24 h。24 h尿mTP为185.0(40.0</del>987.5)mg/24 h, mTP/Cr比值为154.2(53.5<del>1 348.8)mg/gCr(Z=-2.945, P=0.003); 相关方程Y=0.856X-19.162, r=0.973。 24 h尿mAlb为29.1(8.0</del>197.2)mg/24 h, mAlb/Cr比值为60.1(14.8<del>376.2)mg/gCr(Z=-6.811, P=0.000); 相关方程为Y=0.326X+30.897, r=0.884。24 h尿NAG为20.3(8.837.9)U/24 h, NAG/Cr比值为21.6(11.0</del>47.3)U/gCr(Z=-2.708, P=0.007); 相关方程为Y=0.631X+7.994, r=0.718。</p>
<p><strong>讨 论</strong><br>糖尿病肾病的早期是治疗的关键时期, 通过加强治疗可以延缓糖尿病肾病的发展, 部分病例甚至可以逆转糖尿病肾病的病理改变[1]。但糖尿病肾病早期无明显临床症状, 尿常规、肾功能检查正常, 致使不少患者在出现蛋白尿、肾功能异常时才发现, 因此糖尿病肾病的早期诊断具有重要的意义。</p>
<p>尿mAlb是反映肾小球滤过功能的主要指标。正常情况下, 肾小球滤过膜存在电荷选择性屏障, 在静电同性排斥作用下, 绝大多数的mAlb 不能通过滤过膜。而在糖尿病肾病早期, 由于肾小球滤过膜负电荷的乙酰硫酸肝素、唾液酸等成分减少, 使肾小球滤过膜的电荷选择性降低, 并干扰了蛋白多糖与细胞外基底间亲和力, 致使肾小球滤过膜上滤孔孔径增大以及肾小球滤过膜富含带负电荷的结构成分改变, 从而导致mAlb 在尿中排出增多[2]。因此mAlb对判断肾小球的受损程度有重要价值, 由于其在糖尿病刚开始并发肾损伤时就存在, 所以是用于筛选早期糖尿病肾病的主要指标[3]。</p>
<p>尿NAG 活性测定作为一种新的敏感性较高的无损伤的肾功能试验, 已用于多种泌尿系统疾病的辅助诊断、病情及疗效观察。NAG为高分子糖蛋白, 是来自肾近曲小管溶酶体内的酸性水解酶, 不能由肾小球滤过, 在尿中相对稳定。当肾近曲小管细胞受损时尿NAG 活性明显升高, 且早于尿蛋白及肾功能异常的变化, 是反映肾小管功能的灵敏指标[4, 5]。</p>
<p>本研究结果显示, 24 h尿mTP与mTP/Cr比值、mAlb与mAlb/Cr比值、NAG与NAG/Cr比值的r分别为0.973、0.884和0.718, 三者均呈良好的正相关性。因此, 24 h尿mTP/Cr比值、mAlb/Cr比值和NAG/Cr比值可为肾脏疾病、糖尿病肾病的正确判断提供实验室依据。</p>
<p>The authors have declared that no competing interests exist.</p>
<p><em>参考文献</em> </p>
<blockquote>
<p>[1]    Mogensen CE, Damsgaard EM, Froland A, et al. Microal-buminuria in non-insulin-dependent diabetes[J]. Clin Nephrol, 1992, 38(Suppl 1): S28-S39. [本文引用:1] [JCR: 1.288]<br>[2]    张晓青, 宗成国, 栾旭华, 等. 尿mAlb/Cr、NAG、LAP 检测对早期糖尿病肾病的诊断价值[J]. 中国现代医学杂志, 2009, 19(1): 122-124. [本文引用:1]<br>[3]    胡芳, 王学斌, 饶锦秀. 糖尿病早期肾损伤的实验诊断[J]. 中华医学杂志, 2007, 44(1): 46-47. [本文引用:1]<br>[4]    王艳萍, 苏晓林, 王禹, 等. NAG及β2-微球蛋白联合检测对糖尿病肾病早期诊断的意义[J]. 中国医科大学学报, 2004, 33(1): 93-94. [本文引用:1]<br>[5]    D’Amico G, Bazzi C. Urinary protein and enzyme excre-tion as markers of tubular damage[J] . Curr Opin Nephrol Hypertens, 2003, 12(6): 639-643. [本文引用:1]<br>来源：<a href="http://www.shjyyx.com/article/2010/1673-8640-25-5-385.html" target="_blank" rel="noopener">http://www.shjyyx.com/article/2010/1673-8640-25-5-385.html</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>LeetCode 316. 去除重复字母</title>
    <url>/2020/12/02/LeetCode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道贪心题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 $s$ ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。<br>注意：该题与 <a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters" target="_blank" rel="noopener">LeetCode 1081. 不同字符的最小子序列</a> 相同</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：s = “bcabc”<br>输出：”abc”</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：s = “cbacdcbc”<br>输出：”acdb”</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= s.length &lt;= 10^4$</li>
<li>$s$ 由小写英文字母组成</li>
</ul>
<hr>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>首先将每个字符最后出现的位置记录下来，维护一个答案字符串。对于原字符串的每一个字符，判断答案字符串的最后一个字符是否大于它。如果大于它，而且这个字符在后面出现过，那么这个字符就不是最优的，要剔除。如果小于，则直接放入答案字符串。</p>
<p>如何证明方法的正确性？<br>现设想全部字符不重复，那么因为答案需要维护原字符之间的相对位置，那么答案就是原字符串。<br>如果其中的某些字符出现重复，那么当一个字符在之后的地方出现过，那么该字符在前面就是可被替换的。<br>现在考虑如果一个字符在之后也出现了，那么什么时候它可以被替换？<br>那就是它后方出现了一个比它小的新字符，那么现在需要作出决策，要么替换前方的在后面重复出现的字符，要么直接加在后面。<br>显然，替换掉属于最优解，因为只有这样整体字典序最小，且后面可以使用重复字符补上，不会改变字符之间的相对位置。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * author: yxc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> stk;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; ins;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; last;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) last[s[i]] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ins[s[i]]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (; stk.<span class="built_in">size</span>() &amp;&amp; stk.back() &gt; s[i] &amp;&amp; last[stk.back()] &gt; i;) &#123;</span><br><span class="line">                ins[stk.back()] = <span class="literal">false</span>;</span><br><span class="line">                stk.pop_back();</span><br><span class="line">            &#125; </span><br><span class="line">            stk += s[i];</span><br><span class="line">            ins[s[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-27 23:35:39</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">int</span> last[N], st[N];</span><br><span class="line">    <span class="built_in">string</span> stk;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            last[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st[s[i]]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (; stk.<span class="built_in">size</span>() &amp;&amp; s[i] &lt; stk.back() &amp;&amp; last[stk.back()] &gt; i;) &#123;  <span class="comment">// 如果栈非空，且当前字符小于栈顶字符，且栈顶字符在当前字符之后出现过，那么用当前字符替换掉栈顶字符将必然更优</span></span><br><span class="line">                st[stk.back()] = <span class="number">0</span>;</span><br><span class="line">                stk.pop_back();</span><br><span class="line">            &#125; </span><br><span class="line">            stk += s[i];        <span class="comment">// 此时栈要么被弹出一些元素，要么是不满足上面的条件，但是两种都需要将当前元素入栈。</span></span><br><span class="line">            st[s[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">LeetCode 316. 去除重复字母</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>栈</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 5607.生成平衡数组的方案数 [第216场周赛]</title>
    <url>/2020/11/22/LeetCode-5607-%E7%94%9F%E6%88%90%E5%B9%B3%E8%A1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0-%E7%AC%AC216%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>力扣第216场周赛第三题，考查前缀和及动态规划。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 nums 。你需要选择 恰好 一个下标（下标从 0 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。</p>
<p>比方说，如果 <code>nums = [6,1,7,4,1]</code> ，那么：</p>
<p>选择删除下标 <code>1</code> ，剩下的数组为 <code>nums = [6,7,4,1]</code> 。<br>选择删除下标 <code>2</code> ，剩下的数组为 <code>nums = [6,1,4,1]</code> 。<br>选择删除下标 <code>4</code> ，剩下的数组为 <code>nums = [6,1,7,4]</code> 。<br>如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 平衡数组 。</p>
<p>请你返回删除操作后，剩下的数组 <code>nums</code> 是 平衡数组 的 方案数 。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums = [2,1,6,4]<br>输出：1<br>解释：<br>删除下标 0 ：[1,6,4] -&gt; 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。<br>删除下标 1 ：[2,6,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。<br>删除下标 2 ：[2,1,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。<br>删除下标 3 ：[2,1,6] -&gt; 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。<br>只有一种让剩余数组成为平衡数组的方案。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums = [1,1,1]<br>输出：3<br>解释：你可以删除任意元素，剩余数组都是平衡数组。</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：nums = [1,2,3]<br>输出：0<br>解释：不管删除哪个元素，剩下数组都不是平衡数组。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= nums.length &lt;= 10^5$</li>
<li>$1 &lt;= nums[i] &lt;= 10^4$</li>
</ul>
<hr>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>依次抽出数组每一个数，然后判断抽出之后，数组是不是平衡数组。<br>关键在于怎么判断数组是不是平衡的。暴力的做法是每次抽取之后，计算一下抽取之后的奇数和及偶数和。然而题目给出数据范围是$1 &lt;= nums.length &lt;= 10^5$，复杂度要控制在 <strong><em>O(N)</em></strong> 或者 <strong><em>O(NLogN)</em></strong>，所以暴力行不通。<br>这里涉及到求和，自然而然想到构造前缀和数组，构造前缀和数组需要 <strong><em>O(N)</em></strong> 的复杂度，而查询只需 <strong><em>O(1)</em></strong>。这道题需要分别计算奇数和及偶数和，所以要分别构造奇偶前缀和。<br>仔细观察题目，抽取数字后，该数字前面的所有数字奇偶下标不变，后面的所有数字下标奇偶互换。那么抽取之后数组的奇数和就是该数前面所有奇数和加上后面所有偶数和；对应的，偶数和就是该数前面所有偶数加上后面所有奇数和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToMakeFair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();                                <span class="comment">// 1</span></span><br><span class="line">        vector&lt;int&gt; ps1(n + 2), ps2(n + 2);                 // 2</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + <span class="number">1</span>; i ++ ) &#123;                <span class="comment">// 3</span></span><br><span class="line">            ps1[i] = ps1[i <span class="number">-1</span>], ps2[i] = ps2[i <span class="number">-1</span>];         <span class="comment">// 4 从上一位继承</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>) ps1[i] += nums[i - <span class="number">2</span>];               <span class="comment">// 5 nums下标从0开始，求前缀和这里要-1</span></span><br><span class="line">            <span class="keyword">else</span> ps2[i] += nums[i - <span class="number">2</span>];                     <span class="comment">// 6 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;                                    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;                     <span class="comment">// 7</span></span><br><span class="line">            <span class="keyword">int</span> odd, even, p = i + <span class="number">2</span>;                       <span class="comment">// 8</span></span><br><span class="line">            odd = ps1[p - <span class="number">1</span>] + ps2[n + <span class="number">1</span>] - ps2[p];         <span class="comment">// 9</span></span><br><span class="line">            even = ps2[p - <span class="number">1</span>] + ps1[n + <span class="number">1</span>] - ps1[p];        <span class="comment">// 10</span></span><br><span class="line">            <span class="keyword">if</span> (odd == even) res ++;                        <span class="comment">// 11</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>review after today</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>前缀和</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>【AcWing算法基础】第四讲-数学知识-质数 AcWing 868. 筛质数</title>
    <url>/2020/12/03/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86-%E8%B4%A8%E6%95%B0-AcWing-868-%E7%AD%9B%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>常见质数筛法。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个正整数 $n$，请你求出 $1$∼$n$ 中质数的个数。</p>
<p><strong>输入格式</strong><br>共一行，包含整数 $n$。</p>
<p><strong>输出格式</strong><br>共一行，包含一个整数，表示 $1$∼$n$ 中质数的个数。</p>
<p><strong>数据范围</strong><br>$1≤n≤10^6$</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>8</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>4</p>
</blockquote>
<hr>
<h3 id="朴素筛"><a href="#朴素筛" class="headerlink" title="朴素筛"></a>朴素筛</h3><p>从2开始枚举，依次将当前数的倍数（$2 * i, 3 * i, 4 * i … n$）标记为「非质数」，剩余的数就一定是质数。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> pr[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) pr[++cnt] = i;              <span class="comment">// we consider i is a prime num if i wasn't get sieved</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j+=i)       <span class="comment">// sieves all the multiple nums of i</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h3><p>从2开始枚举，依次仅将质数的倍数标记为「非质数」，剩余的数一定是质数。</p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> pr[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            pr[++cnt] = i;                          <span class="comment">// we consider i is a prime num if i wasn't get sieved   </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j+=i)       <span class="comment">// sieves all the multiple nums of i when i is a prime num</span></span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>待更新。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/870/" target="_blank" rel="noopener">AcWing 868. 筛质数</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>AcWing</category>
        <category>算法基础课</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
        <tag>AcWing</tag>
        <tag>质数</tag>
        <tag>素数</tag>
        <tag>朴素筛</tag>
        <tag>埃氏筛</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 493.翻转对</title>
    <url>/2020/11/29/LeetCode-493-%E7%BF%BB%E8%BD%AC%E5%AF%B9/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>归并排序模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 <code>nums</code> ，如果 <code>i &lt; j</code> 且 <code>nums[i] &gt; 2*nums[j]</code> 我们就将 <code>(i, j)</code> 称作一个重要翻转对。<br>你需要返回给定数组中的重要翻转对的数量。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: [1,3,2,3,1]<br>输出: 2</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: [2,4,3,5,1]<br>输出: 3</p>
</blockquote>
<p><strong>注意:</strong></p>
<ol>
<li>给定数组的长度不会超过$50000$。</li>
<li>输入数组中的所有数字都在32位整数的表示范围内。</li>
</ol>
<hr>
<h3 id="归并思想"><a href="#归并思想" class="headerlink" title="归并思想"></a>归并思想</h3><p>这道题和 <code>AcWing</code> 归并排序模板题<a href="https://www.acwing.com/problem/content/790/" target="_blank" rel="noopener">AcWing 788.逆序对的数量</a>非常类似，都是利用区间的单调性对pair的比较进行优化。<br>递归地划分整个数组区间。从最小两个数（或一个数）开始「归」或者叫回溯，在回溯过程中对数组当前的两个区间进行排序，维护它们的单调性，为上一层做准备。同时，在这个过程中另行维护两个指针 <code>i</code>, <code>j</code> , 分别处理两个片段。判断条件<code>nums[i] &gt; 2*nums[j]</code>。如果当前<code>nums[i] &gt; 2*nums[j]</code>，由于此时 <code>i</code> 所在区间是单调递增的，所以从 <code>i</code> 到区间结束的地方所有的数都满足这个条件；反之，移动 <code>i</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;                                                              <span class="comment">// 1</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.<span class="built_in">size</span>() + <span class="number">10</span>)</span></span>;</span><br><span class="line">        helper(nums, tmp, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        helper(nums, tmp, l, mid), helper(nums, tmp, mid + <span class="number">1</span>, r);                   <span class="comment">// 2</span></span><br><span class="line">        <span class="comment">// backtrack</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;                                                     <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= r;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; (<span class="keyword">long</span> <span class="keyword">long</span>) <span class="number">2</span> * nums[j]) &#123;                                <span class="comment">// 4</span></span><br><span class="line">                res += mid - i + <span class="number">1</span>;                                                 <span class="comment">// 5</span></span><br><span class="line">                j ++;                                                                   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i ++;                                                               <span class="comment">// 6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort                                                                     // 7</span></span><br><span class="line">        i = l, j = mid + <span class="number">1</span>;                                             </span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= r;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) tmp[t ++] = nums[j ++];</span><br><span class="line">            <span class="keyword">else</span> tmp[t ++] = nums[i ++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid;) tmp[t ++] = nums[i ++];</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= r;) tmp[t ++] = nums[j ++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l, t = <span class="number">0</span>; i &lt;= r;) nums[i ++] = tmp[t ++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>因为题目给出数组长度不超过$50000$，所以有$49999!$个对数，显然结果最大超过 <code>int</code> 类型范围。</li>
<li>像二叉树遍历一样递归地将原数组一分为二。</li>
<li>维护两个指针分别处理两个片段。</li>
<li>因为 <code>2 * nums[j]</code> 可能会超出 <code>int</code> 类型最大可取值，所以需要强制转换成<code>long long</code>。</li>
<li>如果满足条件，那么由于片段内数组数字是单调递增的，所以从 <code>i</code> 起到片段结束都满足条件。接着移动j，因为j++后对应的数组数字增加，所以需要从 <code>i</code> 起和 <code>j</code> 重新比较。</li>
<li>不满足条件的话，移动 <code>i</code> ，看增加之后是否满足条件。</li>
<li>将两个片段作为一个整体排序，这个整体将作为回溯到上一层的一个片段。</li>
</ol>
</blockquote>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>等我学会之后再来完成。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/reverse-pairs/" target="_blank" rel="noopener">LeetCode 493.翻转对 [Reverse Pairs]</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>归并排序</tag>
        <tag>树状数组</tag>
        <tag>lowbit</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 118. 杨辉三角</title>
    <url>/2020/12/06/LeetCode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>简单模拟，简洁为上。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个非负整数 $numRows$，生成杨辉三角的前 $numRows$ 行。<br>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 5<br>输出:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p>
</blockquote>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;                </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i ++ ) &#123;                               <span class="comment">// 1</span></span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(i + <span class="number">1</span>)</span></span>;                                         <span class="comment">// 2</span></span><br><span class="line">            row[<span class="number">0</span>] = row[i] = <span class="number">1</span>;                                            <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++ ) &#123;                                 </span><br><span class="line">                row[j] = res[i - <span class="number">1</span>][j - <span class="number">1</span>] + res[i - <span class="number">1</span>][j];                 <span class="comment">// 4</span></span><br><span class="line">            &#125;           </span><br><span class="line">            res.push_back(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>依次处理每一行。</li>
<li>对于某一行，该行下标从 <code>0</code> 到 <code>i</code> ，故总数为 <code>i + 1</code>。</li>
<li>每一行的行首行末均为 <code>1</code> ，事先处理好它们。</li>
<li>根据上一行计算该行，其中，第 <code>0</code> 行和第 <code>1</code> 行因为仅包含行首行末，故不用处理，直接跳过。</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">LeetCode 118. 杨辉三角</a></p>
          </div>


]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 318.最大单词长度乘积</title>
    <url>/2020/12/02/LeetCode-318-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>位运算记录字符串中字符。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: [“abcw”,”baz”,”foo”,”bar”,”xtfn”,”abcdef”]<br>输出: 16<br>解释: 这两个单词为 “abcw”, “xtfn”。</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: [“a”,”ab”,”abc”,”d”,”cd”,”bcd”,”abcd”]<br>输出: 4<br>解释: 这两个单词为 “ab”, “cd”。</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入: [“a”,”aa”,”aaa”,”aaaa”]<br>输出: 0<br>解释: 不存在这样的两个单词。</p>
</blockquote>
<hr>
<p>这道题的关键在于判断两个字符串有无公共字符。可以想到的方法有哈希集合，计数数组，以及位运算。</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>这道题的字符串中仅有26个字母，可以用位运算方法记录下字符串中出现的字符。<br>对于一个字符，我们计算出它和 <code>a</code> 的偏移，将 <code>1</code> 左移这个偏移量，那么得到的二进制数就记录下了当前字符。那么，如何记录整个字符串的所有字符呢？<br>维护一个二进制数 <code>s</code> , 对于字符串中的每一个字符，用上述方法计算出对应的二进制数后，与 <code>s</code> 进行或运算，将每个字符相对 <code>a</code> 的偏移量累加地记录到 <code>s</code> 中。<br>判断两个字符串有无公共字符时，就可以直接让对应下标的二进制数进行与运算，为 <code>0</code> 则无公共字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state;                                                                              </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">word</span> : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : <span class="keyword">word</span>) &#123;</span><br><span class="line">                s |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            state.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i ++) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.<span class="built_in">size</span>(); j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((state[i] &amp; state[j]) == <span class="number">0</span>) mx = <span class="built_in">max</span>(mx, (<span class="keyword">int</span>) (words[i].<span class="built_in">size</span>() * words[j].<span class="built_in">size</span>()));     <span class="comment">// 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>注意在 <code>C++</code> 中 <code>string.size()</code> 返回值为 <code>unsinged long</code>。</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/" target="_blank" rel="noopener">LeetCode 318.最大单词长度乘积（Maximum Product of Word Lengths）</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>21天影响力倍增的人际沟通术学习笔记</title>
    <url>/2020/12/04/21%E5%A4%A9%E5%BD%B1%E5%93%8D%E5%8A%9B%E5%80%8D%E5%A2%9E%E7%9A%84%E4%BA%BA%E9%99%85%E6%B2%9F%E9%80%9A%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>课程《21天影响力倍增的人际沟通术》学习笔记。</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>人际关系</tag>
        <tag>情商</tag>
        <tag>沟通</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 659.分割数组为连续子序列</title>
    <url>/2020/12/04/LeetCode-659-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E4%B8%BA%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>利用了贪心的思想。（需要review）</p>
<a id="more"></a>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个按升序排序的整数数组 <code>num</code>（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。<br>如果可以完成上述分割，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入: [1,2,3,3,4,5]<br>输出: True<br>解释:<br>你可以分割出这样两个连续子序列 :<br>1, 2, 3<br>3, 4, 5</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入: [1,2,3,3,4,4,5,5]<br>输出: True<br>解释:<br>你可以分割出这样两个连续子序列 :<br>1, 2, 3, 4, 5<br>3, 4, 5</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入: [1,2,3,4,4,5]<br>输出: False</p>
</blockquote>
<p><strong>提示：</strong></p>
<ol>
<li>输入的数组长度范围为 [1, 10000]</li>
</ol>
<hr>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>设想一个数组元素 <code>x</code> ，我们有两种选择，一是将 <code>x</code> 放到在以 <code>x - 1</code> 结尾的子序列中，二是新建一个以 <code>x</code> 开头的新序列。由于题干说明子序列长度至少为3，利用贪心的思想，我们尽可能地将 <code>x</code> 放到以 <code>x - 1</code> 结尾的序列中去，除非该序列不存在。那么当该序列不存在时，我们不得已新建一个序列，同时判断有没有 <code>x + 1</code> 和 <code>x + 2</code> 存在于 <code>x</code> 后面的数组中。如果都有，那么这个新序列将被建立，并且以 <code>x + 2</code> 结尾，如果不存在那么整个数组将无法分割。<br>就这样，我们遍历整个数组，对于每一个数 <code>x</code>， 要么加入到以 <code>x - 1</code> 结尾的序列中，要么新建一个新序列并判断 <code>x + 1</code> 和 <code>x + 2</code> 有无剩余。所有的新序列都从长度为3开始，只要出现不满足初始化新序列的情况，直接 <code>return false</code> ，否则遍历完数组均无不满足新序列成立的情况，<code>return true</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; remain;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; endcount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            remain[x] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remain[x] &gt; <span class="number">0</span>) &#123;                                        <span class="comment">// 1</span></span><br><span class="line">                <span class="keyword">if</span> (endcount[x - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    remain[x] --;</span><br><span class="line">                    endcount[x - <span class="number">1</span>] --;</span><br><span class="line">                    endcount[x] ++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (remain[x + <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; remain[x + <span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        remain[x] --;</span><br><span class="line">                        remain[x + <span class="number">1</span>] --;</span><br><span class="line">                        remain[x + <span class="number">2</span>] --;</span><br><span class="line">                        endcount[x + <span class="number">2</span>] ++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>因为之前在建立序列时，可能用到了 <code>x</code> ，所以在遍历到 <code>x</code> 时，剩余数量可能不会大于等于1；</li>
</ol>
</blockquote>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/" target="_blank" rel="noopener">LeetCode 659.分割数组为连续子序列</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏逆向】基于FOV的通用 world-to-screen 方法</title>
    <url>/2021/01/24/%E3%80%90%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E3%80%91%E5%9F%BA%E4%BA%8EFOV%E7%9A%84%E9%80%9A%E7%94%A8-world-to-screen-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>暂未测试</p>
<a id="more"></a>]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>游戏逆向</tag>
        <tag>World-to-Screen</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1230. K倍区间</title>
    <url>/2021/02/04/AcWing-1230-K%E5%80%8D%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>巧妙利用前缀和思想。本题来自第八届蓝桥杯省赛C++B组,第八届蓝桥杯省赛JAVAB组。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个长度为 $N$ 的数列，$A_1,A_2,…A_N$，如果其中一段连续的子序列 $A_i,A_{i+1},…A_j$ 之和是 $K$ 的倍数，我们就称这个区间 $[i,j]$ 是 $K$ 倍区间。</p>
<p>你能求出数列中总共有多少个 $K$ 倍区间吗？</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 $N$ 和 $K$。<br>以下 $N$ 行每行包含一个整数 $A_i$。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，代表 $K$ 倍区间的数目。</p>
<p><strong>数据范围</strong></p>
<ul>
<li>$1≤N,K≤100000$</li>
<li>$1≤Ai≤100000$</li>
</ul>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>5 2<br>1<br>2<br>3<br>4<br>5</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>6</p>
</blockquote>
<hr>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>首先预处理出前缀和数组，再考虑暴力做法。枚举每一段区间，计算一次区间和，判断是否为 $k$ 的倍数。<br>这样，复杂度为 $O(N^2)$, 数据范围 $1≤N,K≤100000$ ，复杂度高达 $10^{10}$. 必然TLE。</p>
<p>那么复杂度至少要求低于 $O(NlogN)$。</p>
<p>统计以 $i$ 结尾的子数组的和是否为 $k$ 的倍数，共有长度从 $1$~$i$ 共 $i$ 种情况：</p>
<table>
<thead>
<tr>
<th align="left">长度</th>
<th align="left">子数组的和</th>
<th align="left">对k取余数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$1$</td>
<td align="left">$s[i - 1] - s[i]$</td>
<td align="left">$(s[i] - s[i - 1]) \bmod k$</td>
</tr>
<tr>
<td align="left">$2$</td>
<td align="left">$s[i - 2] - s[i]$</td>
<td align="left">$(s[i] - s[i - 2]) \bmod k$</td>
</tr>
<tr>
<td align="left">$3$</td>
<td align="left">$s[i - 3] - s[i]$</td>
<td align="left">$(s[i] - s[i - 3]) \bmod k$</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">$i-1$</td>
<td align="left">$s[1] - s[i]$</td>
<td align="left">$(s[i] - s[1]) \bmod k$</td>
</tr>
<tr>
<td align="left">$i$</td>
<td align="left">$s[0] - s[i]$</td>
<td align="left">$(s[i] - s[0]) \bmod k$</td>
</tr>
</tbody></table>
<p>其中，若子数组的和对 $k$ 取余数为零，则认为该子数组满足条件。<br>对于以 $i$ 结尾长度为 $len$ 的子数组的和：<br>$s[i] - s[i - len]$，如果 $s[i] - s[i - len] \bmod k = 0$，那么有：<br>$s[i] \bmod k = s[i - len] \bmod k$.</p>
<p>那么我们可以遍历前缀和数组，统计以每一位结尾的子数组的和模 $k$ 的数量，如果重复，则之前存在过一个子数组它的和与以当前数结尾的子数组的和模 $k$ 相等。即二者之差模 $k$ 为 $0$，即这个区间是一个 $k$ 倍区间。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int64_t</span> a[N], s[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prefix sum</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int64_t</span> res = <span class="number">0</span>;</span><br><span class="line">    cnt[<span class="number">0</span>]++;                       <span class="comment">// s[0] % k，对应s[0]~s[i]长度为i的子区间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res += cnt[s[i] % k];       <span class="comment">// 如果以当前i结尾的子连续数组对k的余数&gt;0，即之前出现过相同的余数，那么当前的s[i] % k 必然和之前的某个值相同。</span></span><br><span class="line">        cnt[s[i] % k] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>注意前缀和数组中的值最高可以取到 $10^5 \times 10^5 = 10^{10}$，会爆 <code>int</code>。故使用 <code>long long</code> 来存。<br>另外，最高会产生 $\frac{(N + 1) \times N}{2}$ 个 $k$ 倍子数组。大概等于 $\frac{10^{10}}{2}$，也会爆 <code>int</code>，故答案也需要 <code>long long</code> 来存。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/1232/" target="_blank" rel="noopener">AcWing 1230. K倍区间</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>AcWing</category>
        <category>2021寒假每日一题提高组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计数数组</tag>
        <tag>前缀和</tag>
        <tag>AcWing</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>【AcWing算法基础】第一讲-基础算法-二分 AcWing 789. 数的范围</title>
    <url>/2021/02/07/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86-AcWing-789-%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>二分查找模板题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个按照升序排列的长度为 $n$ 的整数数组，以及 $q$ 个查询。<br>对于每个查询，返回一个元素 $k$ 的起始位置和终止位置（位置从 $0$ 开始计数）。<br>如果数组中不存在该元素，则返回 “$-1 -1$”。</p>
<p><strong>输入格式</strong><br>第一行包含整数 $n$ 和 $q$，表示数组长度和询问个数。<br>第二行包含 $n$ 个整数（均在 $[1,10000]$ 范围内），表示完整数组。<br>接下来 $q$ 行，每行包含一个整数 $k$，表示一个询问元素。</p>
<p><strong>输出格式</strong><br>共 $q$ 行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br>如果数组中不存在该元素，则返回“$-1 -1$”。</p>
<p><strong>数据范围</strong></p>
<ul>
<li>$ 1≤n≤100000 $</li>
<li>$ 1≤q≤10000 $</li>
<li>$ 1≤k≤10000 $</li>
</ul>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>6 3<br>1 2 2 3 3 4<br>3<br>4<br>5</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3 4<br>5 5<br>-1 -1</p>
</blockquote>
<hr>
<p>一段升序数组，找到某数字的左右边界。比如对于 $[1, 2, 2, 3, 3, 4]$, 找到 $2$ 的左右边界。</p>
<p>那么要想找到左边界，它的左边满足条件 $nums[i] &lt; 2$，右边满足条件 $nums[i] &gt;= 2$.<br>按照这个规则去二分查找，则一定只能找到左边界而不会找到右边界去。</p>
<p>要想找到右边界，它的左边满足条件 $nums[i] &lt;= 2$, 右边满足条件 $nums[i] &gt; 2$.<br>那么按照这一规则去二分查找，找到的一定是右边界而非左边界。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n, q, a[N], qry;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; q--;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; qry;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[mid] &lt; qry) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[lo] == qry) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; lo &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            </span><br><span class="line">            lo = <span class="number">0</span>, hi = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; lo &lt; hi;) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = lo + hi + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (a[mid] &gt; qry) hi = mid - <span class="number">1</span>;     <span class="comment">// 注意如果出现 mid - 1的情况，则上面mid 需要 lo + hi + 1操作。这是进过严格验证的。</span></span><br><span class="line">                <span class="keyword">else</span> lo = mid;</span><br><span class="line">            &#125;            </span><br><span class="line"></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; hi &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/problem/content/791/" target="_blank" rel="noopener">AcWing 789. 数的范围</a></p>
          </div>

]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>AcWing</category>
        <category>算法基础课</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找</tag>
        <tag>AcWing</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 39. 数组中出现次数超过一半的数字</title>
    <url>/2021/02/08/%E5%89%91%E6%8C%87Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>摩尔投票法解决众数问题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例1</strong></p>
<blockquote>
<p>输入: [1,2,3,2,2,2,5,4,2]<br>输出: 2</p>
</blockquote>
<p><strong>限制：</strong></p>
<ul>
<li>$1 &lt;= 数组长度 &lt;= 50000$</li>
</ul>
<p>注意：本题与主站 169 题相同：<a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">LeetCode 169. 多数元素</a></p>
<hr>
<h3 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h3><p>摩尔投票法维护一个候选人对象<code>major</code>和一个计票对象<code>cnt</code>；<br>在遍历数组过程中定义三种状态：</p>
<blockquote>
<p>重置状态：当计票对象<code>cnt</code>为0时，当前数字设为候选人<code>major</code>；<br>加权状态: 当<code>major</code>与当前数字相等时，<code>cnt++</code>;<br>对抗状态：当<code>major</code>与当前数字不同时，<code>cnt--</code>;</p>
</blockquote>
<p>最终得到一个<code>major</code>和<code>cnt</code>，当确定原数组中存在超过一半的相同数（众数）时，<code>major</code>即为该众数；当不确定是否存在众数时，需要判断<code>major</code>是否为众数。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-26 18:55:47</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> major = nums[<span class="number">0</span>];        <span class="comment">// 初始化候选人为数组第一个数</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;                <span class="comment">// 初始化计票变量，因为已经指派一个候选人，所以计票初始化为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cnt) &#123;             <span class="comment">// 重置状态。如果计票为0，说明之前已经出现了对抗状态，到达了计票数0的下边界。需要重新指派候选人。</span></span><br><span class="line">                major = nums[i];</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">if</span> (major == nums[i])   <span class="comment">// 加权状态。</span></span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">else</span>                    <span class="comment">// 对抗状态。</span></span><br><span class="line">                cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> major;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指Offer 39. 数组中出现次数超过一半的数字</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指Offer</tag>
        <tag>摩尔投票法</tag>
        <tag>众数</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏逆向】聊一聊Funtion Hook/Detour</title>
    <url>/2020/12/14/%E3%80%90%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E3%80%91%E8%81%8A%E4%B8%80%E8%81%8AFuntion-Hook-Detour/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>聊一聊游戏外挂开发中常用的HOOK技术。</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* toHook: the memory address where we place the jmp</span></span><br><span class="line"><span class="comment">* ourFunct: the memory address where we place our function</span></span><br><span class="line"><span class="comment">* len: the numbers of bytes used by the instruction you're overwritting(typically 5 but deppending what we overwrrite it maybe more)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Hook</span><span class="params">(<span class="keyword">void</span> * toHook, <span class="keyword">void</span> * ourFunct, <span class="keyword">int</span> len)</span> </span>&#123;                        </span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">5</span>) &#123;                                                          <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD curProtection;</span><br><span class="line">    VirtualProtect(toHook, len, PAGE_EXECUTE_READWRITE, &amp;curProtection);    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(toHook, <span class="number">0x90</span>, len);                                              <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    DWORD relativeAddress = ((DWORD)ourFunct - (DWORD)toHook) - <span class="number">5</span>;          <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    *(BYTE*)toHook = <span class="number">0xE9</span>;                                                  <span class="comment">// 5</span></span><br><span class="line">    *(DWORD*)((DWORD)toHook + <span class="number">1</span>) = relativeAddress;</span><br><span class="line"></span><br><span class="line">    DWORD temp;                                         </span><br><span class="line">    VirtualProtect(toHook, len, curProtection, &amp;temp);                      <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD jmpBackAddy;</span><br><span class="line"><span class="keyword">void</span> __declspec(naked) outFunct() &#123;                                         <span class="comment">// 7</span></span><br><span class="line">    _asm &#123;                                                                  <span class="comment">// 8</span></span><br><span class="line">        add ecx, ecx                                                        <span class="comment">// 9</span></span><br><span class="line">		mov edx, [ebp - <span class="number">8</span>]                                                  <span class="comment">// 10</span></span><br><span class="line">        jmp[jmpBackAddy]                                                    <span class="comment">// 11</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">MainThread</span><span class="params">(LPVOID param)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* the assembly lines where we are going to hook is looks like this :</span></span><br><span class="line"><span class="comment">		2B 4D 08      subecx, [ebp + 08]</span></span><br><span class="line"><span class="comment">		8B 55 F8      movedx, [ebp - 08]</span></span><br><span class="line"><span class="comment">		89 0A         mov[edx], ecx</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">int</span> hookLength = <span class="number">6</span>;	<span class="comment">//There are 3 bytes(&lt; 5) in the first line, the hook funtion contains at least 1 `jmp` instrution(5 bytes) </span></span><br><span class="line">						<span class="comment">// so that the offset length should be at least 5. But if we are using 5, we can only override the first line</span></span><br><span class="line">						<span class="comment">// and part of second line.</span></span><br><span class="line">	DWORD hookAddress = <span class="number">0x8d2768</span>;	<span class="comment">// signature if this address: 2B 4D 08 8B 55 F8</span></span><br><span class="line">	jmpBackAddy = hookAddress + hookLength;</span><br><span class="line"></span><br><span class="line">	Hook((<span class="keyword">void</span>*)hookAddress, ourFunct, hookLength);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (GetAsyncKeyState(VK_ESCAPE)) <span class="keyword">break</span>;</span><br><span class="line">		Sleep(<span class="number">50</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FreeLibraryAndExitThread((HMODULE)param, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (dwReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        CreateThread(<span class="number">0</span>, <span class="number">0</span>, MainThread, hModule, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>We check the length to be at least 5 bytes because this is the smallest relative jmp in x86. The instructions you will be destroying by overwriting will be at least 5 bytes. In a word, we have at least a <code>jmp</code> opcode at that address, and the <code>jmp</code> opcode is going to be at least 5 bytes;</li>
<li>We use VirtualProtect to take permissions of the memory we are overwriting.</li>
<li>We set the memory we’re ovewriting with 0x90 which is the NOP (no operationg) instruction, this is not 100% necessary but is a nice failsafe measure. While you’re debugging it’s also nice to watch the 0x90 get written so you know you’re doing the right thing in the right spot. We NOP the entire instruction by giving it the len argument.</li>
<li>Then we calculate the relative address between the destination and src address by subtracting them, we subtract len. The result of this calculation is the relative offset from the last byte we overwrote to the address of our function we are jumping to. Keep in mind, we are using a relative jump, not an absolute jump so this must be calculated at runtime.</li>
<li>Then we write 0xE9(byte code) which is the relative jmp instruction, then we add 1 byte(0xE9) so we can write the relative offset.</li>
<li>Then we use VirtualProtect to reset the page permissions to what they were before we modified them.</li>
<li>You have to execute your code inside a declspec naked function, you must preserve the registers and the stack so you don’t corrupt the stack of registers and you must execute the stolen bytes. Then you have to jump back to the src+len address.<br>The <code>__declspec(naked)</code> indicates that the function is going to be no epilogue and prologue. And we can write assembly code in it.</li>
<li>The <code>_asm</code> indicates no other assembly code but ours.</li>
<li>This line is our own code, which replaces the original one (<code>subecx, [ebp + 08]</code>) to <strong>add</strong> whole health value while pressing SPACE button;</li>
<li>The <code>hookLength</code> we are using(6) overrides the second assembly line although we don’t need to override to execute our code so that we have to re-write it;</li>
<li>After </li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>游戏逆向</tag>
        <tag>HOOK</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 03. 数组中重复的数字</title>
    <url>/2021/02/22/%E5%89%91%E6%8C%87Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>常见判重方法。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>找出数组中重复的数字。</p>
<p>在一个长度为 $n$ 的数组 $nums$ 里的所有数字都在 $0～n-1$ 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>[2, 3, 1, 0, 2, 5, 3]<br><strong>输出：</strong><br>2 或 3 </p>
</blockquote>
<p><strong>限制：</strong><br>$ 2 &lt;= n &lt;= 100000 $</p>
<hr>
<p>本题考查判重方法。</p>
<h3 id="方法一：计数数组"><a href="#方法一：计数数组" class="headerlink" title="方法一：计数数组"></a>方法一：计数数组</h3><p>维护一个计数数组，根据题意长度为 <code>n</code> 的数组每个数范围在 $[0, n-1]$ ，那么数组长度可以设置成大于等于 <code>n-1</code> 。<br>遍历数组，依次向计数数组中插入数字。对于当前数字 <code>x</code> , 在下标为 <code>x</code> 的位置数字增加 <code>1</code> 。如果当前值大于 <code>1</code>，则出现重复。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 48 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 23.3 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line">        cnt = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++cnt[n] &gt; <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 46.3 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cnt;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        len = nums.length;</span><br><span class="line">        cnt = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++cnt[n] &gt; <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h3 id="方法二：哈希集合"><a href="#方法二：哈希集合" class="headerlink" title="方法二：哈希集合"></a>方法二：哈希集合</h3><p>向哈希集合中插入每个数，如果插入失败，则出现重复。</p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li><li class="tab"><a href="#g_tab1-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 56 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 26.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">set</span>.insert(n).second) &#123;</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 5 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 48.6 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(n)) <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="方法三：哈希表"><a href="#方法三：哈希表" class="headerlink" title="方法三：哈希表"></a>方法三：哈希表</h3><p>维护一个哈希表，依次将每个数插入，但是，在插入之前先检查是否存在。</p>
<div class="tabs" id="g_tab2"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab2-1">C++</a></li><li class="tab"><a href="#g_tab2-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab2-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 48 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 26.9 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[n]) <span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">else</span> hash[n] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab2-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 9 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 47.4 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Boolean&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.get(n) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                hash.put(n, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hash.get(n)) &#123;</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hash.put(n, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指Offer 03. 数组中重复的数字</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
        <tag>计数数组</tag>
        <tag>剑指Offer</tag>
        <tag>哈希集合</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏逆向】找ViewMatrix的一般方法</title>
    <url>/2021/01/19/%E3%80%90%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E3%80%91%E6%89%BEViewMatrix%E7%9A%84%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>总结了找游戏ViewMatrix的一般性方法。</p>
<a id="more"></a>

<h3 id="ViewMatrix结构："><a href="#ViewMatrix结构：" class="headerlink" title="ViewMatrix结构："></a>ViewMatrix结构：</h3><blockquote>
<p>它分为四行或四列.<br>四行中，第一行为Left(X)轴，第二行为Up(Y)轴，第三行为Forward(Z)轴，第四行为Translation(用于计算).</p>
</blockquote>
<h3 id="ViewMatrix的特性（row-major）"><a href="#ViewMatrix的特性（row-major）" class="headerlink" title="ViewMatrix的特性（row major）"></a>ViewMatrix的特性（row major）</h3><blockquote>
<ol start="0">
<li>pitch和yaw变化时, 矩阵中前三行绝大部分数字一定发生变化；反之一定不变。</li>
<li>前三行每个数字均在[-2, 2]之间</li>
<li>第三行每个数字均在[-1, 1]之间</li>
<li>第四行数字较大</li>
<li>当pitch在[-90, 90]范围内变化时，对应第三行（Forward行）某个数字在[-1, 1]范围内变化，他们具有良好的正相关性。</li>
<li>如果pitch变化，yaw保持不变，则第三行部分数字变化，前两行部分数字不变；反之，如果pitch保持不变，yaw发生变化，则第三行部分数字不变，前两行部分数字变化。</li>
<li>视角变小时（机瞄），第一行第一个数字的绝对值增大。</li>
<li>前三行后两位数字相同，矩阵中存在一个为0的数。（GTA5和Assault Cube已验证）</li>
</ol>
</blockquote>
<h3 id="ViewMatrix的特性（column-major）"><a href="#ViewMatrix的特性（column-major）" class="headerlink" title="ViewMatrix的特性（column major）"></a>ViewMatrix的特性（column major）</h3><blockquote>
<ol start="0">
<li>pitch和yaw变化时, 矩阵中前三列绝大部分数字一定发生变化；反之一定不变。</li>
<li>前三列每个数字均在[-2, 2]之间</li>
<li>第三列每个数字均在[-1, 1]之间</li>
<li>第四列数字较大</li>
<li>当pitch在[-90, 90]范围内变化时，对应第三列（Forward列）某个数字在[-1, 1]范围内变化，他们具有良好的正相关性。</li>
<li>如果pitch变化，yaw保持不变，则第三列部分数字变化，前两列部分数字不变；反之，如果pitch保持不变，yaw发生变化，则第三列部分数字不变，前两列部分数字变化。</li>
<li>视角变小时（机瞄），第一列第一个数字的绝对值增大。</li>
<li>前三列后两位数字相同，矩阵中存在一个为0的数。（GTA5和Assault Cube已验证）</li>
</ol>
</blockquote>
<h3 id="综合特性-row-and-column-major"><a href="#综合特性-row-and-column-major" class="headerlink" title="综合特性(row and column major)"></a>综合特性(row and column major)</h3><blockquote>
<p>存在一个恒定为零的数字。当矩阵为row major时，这个零在第3行第1列（matrix[2][0] = 0.f）;当矩阵为column major时，零在第1行第3列（matrix[0][2] = 0.f）。<br>存在一个数字，当视角垂直水平面90度向上时，恒定为1；向下时恒定为-1；这个数字在第3行第3列的位置。（matrix[2][2] = x）.<br>第4行或第4列较大。</p>
</blockquote>
<h3 id="利用以上特性搜索ViewMatrix地址"><a href="#利用以上特性搜索ViewMatrix地址" class="headerlink" title="利用以上特性搜索ViewMatrix地址"></a>利用以上特性搜索ViewMatrix地址</h3><p>一般利用第4条特性，配合pitch的变化搜索第三行特定数字。注意这种方法搜到的数字并非matrix首位，需要在浏览内存区域时，先对齐数组，判断数组首位。</p>
<blockquote>
<ul>
<li>搜索unknow initial value</li>
<li>改变pitch和yaw，搜索changed value</li>
<li>搜索value between -1 and 1</li>
<li>不断增加和减少pitch，分别搜索increased value和decreased value</li>
<li>将结果控制在几千个以内，删除非静态地址，在静态地址中进一步筛选。</li>
<li>注意到静态地址是分成一个个内存段的，对于每一个段，选择段首地址和段尾地址，浏览内存区域。</li>
<li>一般来说，view matrix存在在静态地址中跨度较大的段中。</li>
</ul>
</blockquote>
<p>或者直接搜索矩阵第一个数字</p>
<blockquote>
<ul>
<li>搜索unknow initial value</li>
<li>改变pitch和yaw，搜索changed value</li>
<li>搜索value between -2 and 2</li>
<li>改变pitch和yaw，搜索changed value</li>
<li>保持pitch和yaw不变，搜索unchanged value</li>
<li>剩下和上面一致。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>游戏逆向</tag>
        <tag>World-to-Screen</tag>
        <tag>ViewMatrix</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 04. 二维数组中的查找</title>
    <url>/2021/02/23/%E5%89%91%E6%8C%87Offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>巧妙利用递增特性线性查找目标值。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个 $n * m$ 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>示例:</strong></p>
<p>现有矩阵 <code>matrix</code> 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>给定 <code>target = 5</code>，返回 <code>true</code>。</p>
<p>给定 <code>target = 20</code>，返回 <code>false</code>。</p>
<p><strong>限制：</strong></p>
<p>$ 0 &lt;= n &lt;= 1000 $,</p>
<p>$ 0 &lt;= m &lt;= 1000 $</p>
<hr>
<h3 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h3><p>从右上角开始，如果当前数比目标值小，则排除当前行；如果比目标值大，则排除当前列。</p>
<div class="tabs" id="g_tab-0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab-0-1">C++</a></li><li class="tab"><a href="#g_tab-0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab-0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 28 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 12.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!R) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> C = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>, c = C - <span class="number">1</span>; r &lt; R &amp;&amp; c &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = matrix[r][c];</span><br><span class="line">            <span class="keyword">if</span> (cur == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; target) r++;</span><br><span class="line">            <span class="keyword">else</span> c--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab-0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 44.5 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (R == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> C = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>, c = C - <span class="number">1</span>; r &lt; R &amp;&amp; c &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = matrix[r][c];</span><br><span class="line">            <span class="keyword">if</span> (cur == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; target) r++;</span><br><span class="line">            <span class="keyword">else</span> c--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">剑指Offer 04. 二维数组中的查找</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>剑指Offer</tag>
        <tag>线性搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 07. 重建二叉树</title>
    <url>/2021/02/23/%E5%89%91%E6%8C%87Offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>根据二叉树的前序遍历结果和中序遍历结果重建二叉树，一道非常好的题目。</p>
<a id="more"></a>


<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<blockquote>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p>
</blockquote>
<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br>$ 0 &lt;= 节点个数 &lt;= 5000 $</p>
<p><strong>树的定义：</strong></p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></div></div>
<hr>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>构建二叉树的一般作法是：<strong>先构建根节点，再递归构建根节点的左右孩子节点。</strong></p>
<p>首先设二叉树共有 $n + m + 1$ 个节点，其中根节点的左子树共有 $n$ 个节点，右子树共有 $m$ 个节点。</p>
<p>前序遍历数组的第一个数一定是二叉树的根节点值，从第二个数开始到第$n$个数结束，为结点数为$n$的左子树的所有节点值；从第$n+1$个数开始，到第$n+m$个数结束，为结点数为$m$的右子树所有节点值。</p>
<p>中序遍历数组的第$0$个数开始，到第$n-1$个数结束，为结点数为$n$的左子树的所有节点值；第$n$个数为整个二叉树的根节点值；从第$n+1$个数开始，到 $n + m$ 个数结束，为结点数为$m$的右子树所有节点值。</p>
<p>根据前序遍历数组，我们必然得知根节点值，由于二叉树的每个节点值不同，可以根据根节点值在中序数组中找到其位置，将中序数组一分为二。那么左半边全是左子树节点值，右半边为右子树节点值。根据这一信息计算出左右子树长度。</p>
<p>回到前序数组中，可以注意到第一个节点值为根节点，第二个结点为左子树根节点。我们发现左子树的根节点永远在根节点右边偏移一位的位置。同时可以根据根节点加上左子树长度的偏移找到右子树根节点。</p>
<p>至此，我们完成了一个：构建根节点，构建根节点左孩子节点，构建根节点右孩子节点的过程。<br>此后，可以递归地完成整个二叉树的构建。</p>
<p>在构建过程中，可以维护一个指针对 <code>l</code> <code>r</code> 分别在两个遍历序列中指向树的节点范围起始边界和结束边界。在递归构建过程中，分别缩小这两个指针指向的范围以达到构建子树的目的。</p>
<p>在中序遍历数组中，左子树的左边界始终对应当前树的左边界，左子树的右边界始终对应当树根节点位置左边一位；<br>右子树的右边界始终对应当前树的右边界，右子树的左边界始终对应当前树根节点位置右边一位。</p>
<p>在前序遍历数组中，左子树的左边界对应左子树根节点位置，当左子树的左边界大于左子树的右边界，则该分支结束；<br>右子树的左边界可以根据左子树长度计算得到，右子树左边界大于右边界，则该分支结束。</p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li><li class="tab"><a href="#g_tab1-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 20 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 24.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        len = inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            hash[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(preorder, inorder, <span class="number">0</span>, len - <span class="number">1</span>, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> lp, <span class="keyword">int</span> rp, <span class="keyword">int</span> li, <span class="keyword">int</span> ri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lp &gt; rp) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// build root</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[lp]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> inIndexRoot = hash[preorder[lp]];</span><br><span class="line">        <span class="comment">// length of left/right sub-tree</span></span><br><span class="line">        <span class="keyword">int</span> llen = inIndexRoot - li;</span><br><span class="line">        <span class="keyword">int</span> rlen = ri - inIndexRoot;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build left/right sub-tree</span></span><br><span class="line">        root-&gt;left = helper(preorder, inorder, lp + <span class="number">1</span>, lp + <span class="number">1</span> + llen - <span class="number">1</span>, li, inIndexRoot - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = helper(preorder, inorder, lp + llen + <span class="number">1</span>, lp + llen + <span class="number">1</span> + rlen - <span class="number">1</span>, inIndexRoot + <span class="number">1</span>, ri); </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 2 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 38.6 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        len = preorder.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            hash.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, inorder, <span class="number">0</span>, len - <span class="number">1</span>, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> lp, <span class="keyword">int</span> rp, <span class="keyword">int</span> lin, <span class="keyword">int</span> rin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lp &gt; rp) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[lp];</span><br><span class="line">        <span class="keyword">int</span> rootIndexIn = hash.get(rootVal);</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> llen = rootIndexIn - lin;</span><br><span class="line">        <span class="keyword">int</span> rlen = rin - rootIndexIn;</span><br><span class="line"></span><br><span class="line">        root.left = helper(preorder, inorder, lp + <span class="number">1</span>, lp + <span class="number">1</span> + llen - <span class="number">1</span>, lin, rootIndexIn - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(preorder, inorder, lp + <span class="number">1</span> + llen, rp, rootIndexIn + <span class="number">1</span>, rin);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/comments/" target="_blank" rel="noopener">剑指Offer 07. 重建二叉树</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 06. 从尾到头打印链表</title>
    <url>/2021/02/23/%E5%89%91%E6%8C%87Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>考察链表遍历，递归一波带走。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong> head = [1,3,2]<br><strong>输出：</strong> [2,3,1]</p>
</blockquote>
<p><strong>限制：</strong></p>
<p>$ 0 &lt;= 链表长度 &lt;= 10000 $</p>
<p><strong>链表定义：</strong></p>
<div class="tabs" id="g_tab-0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab-0-1">C++</a></li><li class="tab"><a href="#g_tab-0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab-0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab-0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></div></div>

<hr>
<h3 id="递归（系统栈）"><a href="#递归（系统栈）" class="headerlink" title="递归（系统栈）"></a>递归（系统栈）</h3><p>递归遍历链表，“归（回溯）”的时候输出节点值。</p>
<div class="tabs" id="g_tab1-0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-0-1">C++</a></li><li class="tab"><a href="#g_tab1-0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 8 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 9 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        dfs(head);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span>;</span><br><span class="line">        dfs(head-&gt;next);</span><br><span class="line">        res.push_back(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 39.4 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(head);</span><br><span class="line"></span><br><span class="line">        len = list.size();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(head.next);</span><br><span class="line">        list.add(head.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>利用栈的特性。注意Java语言中的栈结构一般用LinkedList.<br><code>LinkedList&lt;Integer&gt; stk = new LinkedList&lt;&gt;();</code><br>涉及到的方法有：<br><code>addLast()</code>对应 <code>push</code>, <code>removeLast()</code>对应 <code>pop</code>, <code>size()</code>.</p>
<div class="tabs" id="g_tab2-0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab2-0-1">C++</a></li><li class="tab"><a href="#g_tab2-0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab2-0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 4 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 8.7 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (; head; head = head-&gt;next) &#123;</span><br><span class="line">            stk.push(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; !stk.empty(); stk.pop()) &#123;</span><br><span class="line">            res.push_back(stk.top());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab2-0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 39.3 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; stk = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; head != <span class="keyword">null</span>; head = head.next) &#123;</span><br><span class="line">            stk.addLast(head.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = stk.size();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res[i] = stk.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h3><p>当你忘了STL或者java的sdk api中的栈怎么用的时候，就模拟栈吧。</p>
<div class="tabs" id="g_tab3-0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab3-0-1">C++</a></li><li class="tab"><a href="#g_tab3-0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab3-0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 8 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 8.5 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> stk[<span class="number">10010</span>], tt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (; head; head = head-&gt;next) &#123;</span><br><span class="line">            stk[++tt] = head-&gt;val;      <span class="comment">// push</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; tt;) &#123;</span><br><span class="line">            res.push_back(stk[tt--]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab3-0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 38.4 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] stk = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10010</span>];</span><br><span class="line">        <span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; head != <span class="keyword">null</span>; head = head.next) &#123;</span><br><span class="line">            stk[++tt] = head.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[tt];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; tt &gt; <span class="number">0</span>; i++, tt--) &#123;</span><br><span class="line">            res[i] = stk[tt];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">剑指Offer 06. 从尾到头打印链表</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 09. 用两个栈实现队列</title>
    <url>/2021/02/25/%E5%89%91%E6%8C%87Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>用两个栈模拟队列，栈结构入门题，很蛋疼的设计。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br><strong>输出：</strong> [null,null,3,-1]</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br><strong>输出：</strong> [null,-1,null,null,5,2]</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<ul>
<li>$1 &lt;= values &lt;= 10000$</li>
<li>最多会对 <code>appendTail</code>、<code>deleteHead</code> 进行 $10000$ 次调用</li>
</ul>
</blockquote>
<hr>
<p>用两个栈模拟队列，一个放的是正序序列，一个是倒序序列。分别用作队列的插入队尾和删除队首操作。</p>
<div class="tabs" id="g_tab"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab-1">C++</a></li><li class="tab"><a href="#g_tab-2">C++</a></li><li class="tab"><a href="#g_tab-3">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-24 21:08:04</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line">    <span class="keyword">int</span> stk1[N], stk2[N];</span><br><span class="line">    <span class="keyword">int</span> tt1, tt2;</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        tt1 = <span class="number">0</span>;</span><br><span class="line">        tt2 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stk1[++tt1] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tt2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tt1) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">// dump</span></span><br><span class="line">                <span class="keyword">for</span> (; tt1; --tt1) &#123;</span><br><span class="line">                    stk2[++tt2] = stk1[tt1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk2[tt2--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 364 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 101.2 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stkTail;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stkHead;</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stkTail.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stkHead.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stkTail.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; !stkTail.empty(); stkTail.pop()) stkHead.push(stkTail.top());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = stkHead.top();</span><br><span class="line">        stkHead.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab-3"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 53 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 47.3 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; stk1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; stk2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stk2.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stk1.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk2.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; stk2.size() != <span class="number">0</span>; ) stk1.addLast(stk2.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk1.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指Offer 09. 用两个栈实现队列</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 05. 替换空格</title>
    <url>/2021/02/23/%E5%89%91%E6%8C%87Offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>简单语法题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong> s = “We are happy.”<br><strong>输出：</strong> “We%20are%20happy.”</p>
</blockquote>
<p><strong>限制：</strong></p>
<p>$ 0 &lt;= s 的长度 &lt;= 10000 $</p>
<hr>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>注意Java语言char数组转String的方法，利用String构造函数：<br><code>String​(char[] value, int offset, int count)</code><br>可以实现将char数组中部分元素转换成String。<br>其中，<code>offset</code> 为数组起始位置便宜位置，<code>count</code> 为长度。<br>如果把char数组整体转换成String，可以：<br><code>String.valueOf(chararray)</code></p>
<div class="tabs" id="g_tab"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab-1">C++</a></li><li class="tab"><a href="#g_tab-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 6.1 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) res += <span class="string">"%20"</span>;</span><br><span class="line">            <span class="keyword">else</span> res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 36.3 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] cc = &#123;<span class="string">'%'</span>, <span class="string">'2'</span>, <span class="string">'0'</span>&#125;; </span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[len * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) ch[u++] = cc[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ch[u++] = s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch, <span class="number">0</span>, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">剑指Offer 05. 替换空格</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 154. 寻找旋转排序数组中的最小值 II</title>
    <url>/2021/02/26/LeetCode-154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-II/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>二分查找经典应用，当数组中包含重复数字时，事情发生了变化。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>请找出其中最小的元素。</p>
<p>注意数组中可能存在重复的元素。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入:</strong> [1,3,5]<br><strong>输出:</strong> 1</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入:</strong> [2,2,2,0,1]<br><strong>输出:</strong> 0</p>
</blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">LeetCode 153. 寻找旋转排序数组中的最小值</a> 的延伸题目。</li>
<li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li>
</ul>
<hr>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>这道题和 <a href="https://eetoa.github.io/2021/02/26/LeetCode-153-寻找旋转排序数组中的最小值/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a> 的区别就在于折叠数组中可能存在重复。</p>
<p>什么时候会产生影响呢？那就是当折叠点在原数组中某一数字相同段内时，折叠之后，数组首尾相同。那么，如果 <code>mid</code> 更新到与数组首尾相同的数字时，我们无法利用二分查找所依赖的 <strong>性质</strong> 确定 <code>mid</code> 是在左半边还是右半边。</p>
<p>那么，解题思路就是：</p>
<ul>
<li>先特判非单调递减情况，排除原数组折叠点在数组下标范围外的情况。</li>
<li>再特判折叠数组首尾相同的情况，方法是移动右指针向左直到和左端点不同为止。那么此时又有两种情况：</li>
</ul>
<ol>
<li>右半边全为与左端点相同的数字，那么此时右指针移到了左半边， <code>nums[hi] &gt; nums[0]</code></li>
<li>右半边不全是与左端点相同的数字，那么此时右指针依然在右半边， <code>nums[hi] &lt; nums[0]</code></li>
</ol>
<ul>
<li>对于以上情况1，直接返回数组首即可；而对于情况2，需要按照传统二分查找，找到右半边的左边界。详情请参考： <strong><a href="https://eetoa.github.io/2021/02/26/LeetCode-153-寻找旋转排序数组中的最小值/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a></strong></li>
</ul>
<p>另外可以想一下，如果折叠数组数组完全相同，也就是最坏的情况，会怎么样。<br>那必然是最终右指针左移时与左指针相遇，进行一次常规二分直接得出答案。当然也可以在进入常规二分之前特判一下，都无所谓。<br>最坏的情况下，复杂度为 $O(N)$，平均的情况下，复杂度为 $O(logn)$.</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 4 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 11.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判非递减情况（折叠点不在原数组下标范围内）</span></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判折叠点在重复数字中的情况（折叠后数组首尾相同）</span></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi &amp;&amp; nums[hi] == nums[<span class="number">0</span>]; hi--); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时存在两种情况，一是右半边还有数字，二是右半边无数字</span></span><br><span class="line">        <span class="comment">// 如果是右半边有数字，那么右半边递增，全部数字小于num[0];</span></span><br><span class="line">        <span class="comment">// 如果右半边没有数字，也就是说hi到了左半边，直接返回nums[0];</span></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[<span class="number">0</span>]) <span class="keyword">return</span> nums[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常规情况，和153题解法一致</span></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 38.3 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = len - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi &amp;&amp; nums[lo] == nums[hi]; hi--);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">LeetCode 154. 寻找旋转排序数组中的最小值 II</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot和SSM在开发中的区别</title>
    <url>/2021/02/24/Spring-Boot%E5%92%8CSSM%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>详细阐述Spring Boot和SSM的区别。</p>
<a id="more"></a>

<p><strong>写在前面：</strong><br>Spring Boot没有颠覆Java EE开发，但是我的回答会颠覆你对Spring Boot的认知。本篇为转载，出处链接在文章末。</p>
<h3 id="我们先说说Spring-Boot和SSM本质上的区别"><a href="#我们先说说Spring-Boot和SSM本质上的区别" class="headerlink" title="我们先说说Spring Boot和SSM本质上的区别"></a>我们先说说Spring Boot和SSM本质上的区别</h3><p>SSM是什么？是三个臭皮匠(裨将)，Spring IoC、Spring MVC、Mybatis的组合。SSM限定死了你只能开发Java Web应用，而且MVC框架必须用Spring MVC，持久层必须用Mybatis，无他！我说的是SSM包含这些啊，没说你不能在这三个基础上自己加其他框架和库上去。</p>
<p>Spring Boot呢？诸葛亮。有了诸葛亮，你用兵的可选方案更多，不管用哪几员将军，出师更顺利。Spring Boot没有和任何MVC框架绑定！没有和任何持久层框架绑定！没有和任何其他业务领域的框架绑定！</p>
<p>你开发Web应用可以用Spring Boot。用spring-boot-starter-web就帮你配置好了Spring MVC。你不想用Spring MVC了，换成Spring WebFLux(用spring-boot-starter-webflux)写响应式Web应用可以吗？当然可以，而且这个是Spring 5主推的新Web框架。</p>
<p>你不开发Web应用，只实现纯粹的数据层业务，开发Spring Cloud Stream和Task也可以。</p>
<p>数据持久层，你可以用Spring Data项目下的任何子项目(JPA\JDBC\MongoDB\Redis\LDAP\Cassandra\Couchbase\Noe4J\Hadoop\Elasticsearch….)，当然用非Spring官方支持的Mybatis也可以。只要用上对应技术或框架的spring-boot-starter-xxx就可以了。</p>
<p><strong>但是必须要知道，Spring Boot提供的只是这些starters，这些Starter依赖了(maven dependence)对应的框架或技术，但不包含对应的技术或框架本身！</strong></p>
<p>这就是很多人用“全家桶”这个词来比喻Spring Boot的错误之处。肯德基麦当劳的全家桶里面包含了鸡腿、鸡翅、鸡块，这些东西都是包含在里面的，而且是不可选择的。你吃的完是这些，吃不完也是这些。你喜欢吃其中几样，也可能不喜欢吃其中几样。但是Spring Boot不是啊，Spring Boot没有包含Spring MVC，没有包含Mybatis，只有他们对应的starters。</p>
<p>一个更恰当的比喻是，Spring MVC、Spring Data、Websocket这东西对应电脑硬件的显卡、声卡、硬盘、网卡。Spring Boot提供的Starters对应这些硬件的驱动。只要你在主板上插上了这些硬件，Spring Boot提供的对应驱动就能让能让你享受到即插即用(Plug &amp; Play)的体验。Spring Boot提供的是驱动，没有包含显卡、声卡这些硬件本身，这些驱动能够让你DIY的电脑顺畅的引导(boot)并运行起来。</p>
<p>很多Java服务器端的常见第三方框架，Spring Boot都能用Convention over Configuration的方式帮你默认配置好。</p>
<p>具体支持什么看这里：<br><a href="https://link.zhihu.com/?target=https%3A//docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/%23using-boot-starter">Spring Boot Reference Guide</a></p>
<p>上面官方文档的列表只给出了Spring Boot官方提供的starters，其他第三方自己提供(例如Mybatis的starter)的没有包含在这个列表里。</p>
<p>前几天<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 改版了，也可以去看看：</p>
<p><img src="0x0.jpg" alt="0x0"></p>
<p>红框里的Dependency是空的，没有限制你必须用哪一个，Web都是可选的。而且你输入Web，会有Spring MVC和Spring WebFlux让你选。</p>
<p><img src="0x1.jpg" alt="0x1"></p>
<p>上图下拉列表中，第一个Web就是Spring MVC，第二个Reactive Web就是Spring WebFLux。本文后面我们还会讲到。</p>
<p>关于<a href="http://start.spring.io，" target="_blank" rel="noopener">http://start.spring.io，</a> 也就是Spring Initializr，看我回答的另外一个问题，非常简单：<br><a href="https://www.zhihu.com/question/49941226/answer/619799264" target="_blank" rel="noopener">spring mvc+hibernate+spring开发框架搭建？</a></p>
<p>其他答案提到的：配置方便(也就是我上面说的Convention over Configuration)只是表象，其实CoC一直都是Spring贯彻的理念，只是Spring Boot又把它提高到了一个新的高度。</p>
<p>Spring Boot的最核心理念就体现在名字上，Spring就不说啦，那Boot是啥意思啊？<br>Boot是引导启动的意思，Windows安装启动的过程不就需要引导盘(boot disk或bootable usb)吗？</p>
<p>类似的，前端有一个Bootstrap，也是这个意思，让你快速搭建前端UI。上面提到的那个Spring Initializr，打开页面，看左上角，写的什么？Spring Initializr <strong>Bootstrap</strong> your application。</p>
<p><img src="0x2.jpg" alt="0x2"></p>
<p>如果一家公司一直用SSH/SSM，用了若干年了，经历了大大小小几个项目，基本上配置都已经好了，早就形成了自己的一套默认配置。国内大多数中小公司，新项目的启动就是把上一个项目Copy过来改！还需要用啥Spring Boot？在这种情况下，三个臭皮匠就顶上诸葛亮了！</p>
<p>但是如果你的新项目需要用到以前没整合过的技术呢？比如数据库要用MongoDB了，也许还用到Redis，可能还需要用Spring Security，估计还要上Kafka消息队列，还可能要用Websockets。你的项目怎么才能平稳、顺利、快速启动？手动配置这些东西可能就要花不少时间，而且还不一定配置的好。</p>
<p>明白我上面说的那些，很多问题都没必要问了。例如我回答过的这些问题：<br><a href="https://www.zhihu.com/question/303235503/answer/537538561" target="_blank" rel="noopener">可以不学spring其他，直接学spring boot吗？</a><br><a href="https://www.zhihu.com/question/64671972/answer/568318031" target="_blank" rel="noopener">spring boot与spring mvc的区别是什么？</a><br><a href="https://www.zhihu.com/question/314112286/answer/613357345" target="_blank" rel="noopener">熟悉使用Springboot，还有必要学习SpringMVC么？</a></p>
<p>这个问题下原来赞数最多回答推荐的那本书我没看过，但是之前就知道这本书。我看到副标题–<strong>Java EE开发的颠覆者</strong>，就误导了入门读者，传递了错误观念，仅仅是为了自己的销量。</p>
<p>这个问题下有人不是比喻Spring Boot和SSM之间是自动挡和手动挡的关系吗？有点像。但我还是更喜欢我在这个回答里的比喻：<br><a href="https://www.zhihu.com/question/49649311/answer/364216794" target="_blank" rel="noopener">哪些企业或项目在用Spring boot,或者它会在多大程度上替代Spring?</a></p>
<p>从马车到汽车是交通出行的颠覆，从燃油车到纯电动车是能源利用的颠覆，从人工驾驶到AI智是驾驶方式的颠覆。但，只是给传统汽车改成自动挡、加装一键启停、无钥匙进入、自动跟车、车道偏离预警，我觉得不算颠覆。</p>
<p><strong>这个”颠覆“给人的感觉就是：Spring MVC不用学了，Spring其他都不用学了，Spring Boot颠覆了他们的，取代他们的，包含了他们以前所有的功能。</strong> 然后就误导出了上面那些问题。</p>
<h3 id="我们再看看这个问题下其他答案"><a href="#我们再看看这个问题下其他答案" class="headerlink" title="我们再看看这个问题下其他答案"></a>我们再看看这个问题下其他答案</h3><p><strong>回答1：两个一样的，只不过是springboot省去了很多配置</strong><br>怎么可能一样呢？如果一样，大部分公司都没必要迁移到Spring Boot。因为上面说了，只要做了几个项目，基本也就把SSM配置的差不多了。每个项目都Copy套用就可以了。</p>
<p><strong>回答2：Spring Boot 就像一个脚手架一样 能让你快速的搭建项目 他不是替代SSM的 至于返回什么 完全看前端需求和文档规定吧</strong><br>Spring Boot就像一个脚手架，但绝对不是一个脚手架。什么是脚手架？我们都见过，就是建筑工地盖楼房的时候外面那一层钢管搭建的架子，还有一层绿网，就是方便构建楼房。但是楼房竣工以后，脚手架是要被拆掉的，不会作为物业的一部分交给业主。软件开发中的脚手架也是类似的，帮助快速搭建项目，而脚手架不会作为最终交付成果的一部分。你用了Spring Boot，那么Spring Boot以及其他starter的jar都会最终进入你打包编译的jar里，作为你成果的一部分。</p>
<p>那么Spring体系当中，有没有真正的脚手架呢？有的，就是答案上面截图的<a href="http://start.spring.io，它叫做Spring" target="_blank" rel="noopener">http://start.spring.io，它叫做Spring</a> Initializr Bootstrap your application，<strong>就是通过页面上的操作，很快帮你生成搭建好一个初始化好的Spring Boot应用。但是Spring Initializr自己不会进入你最后打包的jar，Spring Initializr是Spring Boot应用的一个简单脚手架工具。</strong></p>
<p>怎么又是一个“简单”的脚手架工具了？因为还有Spring Boot Cli啊。Cli是Command Line Interface的缩写，就是命令行工具。Spring Boot Cli通过命令行交互的方式提供了脚手架功能，你可以用它初始化一个Spring Boot项目，也可以用它完成打包jar的工作。</p>
<blockquote>
<p>The <code>init</code> command lets you create a new project by using<br><a href="start.spring.io">start.spring.io</a> without leaving the shell<br>–Spring Boot 文档</p>
</blockquote>
<p>例如运行spring init：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ spring init --dependencies=web,data-jpa my-project</span><br><span class="line">Using service at https://start.spring.io</span><br><span class="line">Project extracted to <span class="string">'/Users/developer/example/my-project'</span></span><br></pre></td></tr></table></figure>
<p>就完成了在<a href="http://start.spring.io" target="_blank" rel="noopener">start.spring.io</a>中创建项目的工作。</p>
<p>Spring Boot不是替代SSM的，这个是对的。因为答案上面解释过了，Spring Boot没有和任何Web MVC绑定，没有和任何数据持久化绑定。Spring Boot自己根本无法完成SSM能完成的工作，需要其他starter作为桥梁，自动帮你配置好对应的框架才行。</p>
<p><strong>回答3：springboot采用约定大于配置的方式，简化了大量的xml配置，真正做到了开箱即用。减少了web开发的难度</strong><br>Spring Boot是采用约定大于配置(就是Convention over Configuration)，简化了大量的XML配置。难道在Spring Boot出来以前Spring Framework或者其他Spring体系下的框架就没有采用CoC吗？就没有提倡用Java Annotation来简化配置吗？ CoC一直就是Spring所倡导的，只是Spring Boot更进一步发扬光大了！</p>
<p>真正做到开箱即用？没有吧，那还需要Spring Initializr干嘛？或者还需要手动配置POM干嘛？还是要做一定定制化的。如果论开箱即用(Out of Box)，我答案里说的传统公司的流程才是开箱即用。新项目Copy老项目就算开箱了，直接上去改就算开始用了。</p>
<p><strong>回答4：SSM：面相XML编程。SpringBoot：面相注解编程</strong><br>Spring Boot出现以前，Spring Framework已经在推荐Java Annotation的配置方式了，在所有的文档里都会同时介绍注解和XML两种配置方式，并且优先介绍注解的方式。</p>
<p><strong>回答5：ssm是自己买家具装修。spring boot是全屋定制</strong><br>SSM不是自己买家具，而是住酒店，酒店房间里的东西就这些，没得换。你只能自己带一些小件日用品。SSM这家酒店你不喜欢，那就换SSH那家去。Spring Boot是全屋定制，这个形容不错。而且家具种类齐全，品种多样。你只要下单就可以，包送货、包安装调试。</p>
<p><strong>回答6：没有区别，springboot 只是提供了一套默认配置，用于原型的快速开发。</strong><br>怎么可能没区别，就不多说了。用于原型快速开发这句话存在严重片面理解。快速开发没问题，但绝对不是只限于开发原型。</p>
<p>Spring Boot文档开章明义就讲了：</p>
<blockquote>
<p>Spring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run.</p>
</blockquote>
<p>怎么是Production-grade(产品级)呢？</p>
<p>Spring Boot文档第V章，专门讲了这些，指的是Actuator，用来监控和控制Spring Boot应用。包括Loggers，Metrics，Auditing，HTTP Tracing，Process Monitoring等等产品环境下需要的一套机制。</p>
<p><strong>回答7：区别就是配置方式不一样，对于实现业务逻辑来说没有任何区别。</strong><br>区别不仅仅是配置方式不一样，实现业务逻辑更是大有不同！用SSM开发应用，大多数公司的技术栈还在使用JSP，很少采用前后端分离的。而Spring Boot倡导前后端分离的开发，Spring Boot的应用只向前端提供RESTful API。下面一节会重点说这个。</p>
<p>不再逐一分析了。为什么要批判这些回答？因为这些回答代表的观念不仅仅出现在这个问题下的回答里，其他Spring Boot相关的问题下面都能见到这些观点层出不穷。</p>
<h3 id="我们再说说题主在问题描述中表达的困惑"><a href="#我们再说说题主在问题描述中表达的困惑" class="headerlink" title="我们再说说题主在问题描述中表达的困惑"></a>我们再说说题主在问题描述中表达的困惑</h3><blockquote>
<p>原来使用ssm开发，后来公司用springboot，虽然一直在用但除了springboot简化构建项目以外，还有个别的几个不一样的注解，<strong>其他的都感觉差不多</strong>，有人看到一个框架说:<strong>他虽然使用spring boot构建了项目，但是里面开发还是用的ssm</strong>，因为他使用了ModelAndView，那么问题来了，那spring boot中又是返回什么呢？</p>
</blockquote>
<p>问题描述中的这段话充分体现了软件开发上的一些根本性的问题。</p>
<p>软件开发，首先是思想行为，其次才是编码。想明白想通了，处处顺风顺水。想不通，觉得别扭，开发也束手束脚。</p>
<p>当了解学习一个新技术新框架新工具的时候，首先要了解其思想。它新在哪里？它提倡了什么理念？它想引导开发者向哪里发展？难道以前的同类技术不行了吗？</p>
<p>这个问题是关于Spring的，也就是关于Java 服务器端技术的，那咱们就举个Java的例子。大家学Java，都知道一本书叫《Thinking In Java》吧？中文叫《Java编程思想》好像是。</p>
<p>Java新手，特别是以前熟悉过程语言的人，首先要理解面向对象的思想，才能用好面向对象的语言。否则你就是用面向过程的语言写着面向过程的程序。你用来用去，就会问自己，和我以前用的那个语言到底有啥区别呢？</p>
<p>不仅仅是编程语言和框架，学习说话语言也是一样。任何人学外语都不会像用自己母语那么自然，关键就是没有用对方语言的思维去组织语言！背再多单词，记再多语法，没有转变到那门语言的思维方式上，就很难说出地道的外语。</p>
<p>生活中也是一样的。这个问题下有用手动挡车和自动挡车来类比Spring Boot和SSM。假如一个人以前开了十几年手动挡汽车，然后换了一部手自一体的，他一开始也不习惯。用自动挡模式驾驶，他的手也会不自觉的去摸档把。最后他把车切换成手动模式才觉得稍微习惯一点。</p>
<p>在日常开发中，经常会见到一种人，他们学习新框架总是要把自己对以前旧框架的认识和经验往上套。<strong>套不上就会骂这个东西真难用，套上了就会问到底有啥区别为什么要折腾，这就是底层程序员的通病。</strong></p>
<p>那么Spring Boot和SSM相比，除了之前说过的那些区别，在Web开发上引入了什么新思想？打算把开发者引导到什么方向上去呢？其中重要的一点就是：<strong>抛弃服务器端模板，用REST API和前端配合，做到前后端分离的开发。</strong></p>
<p>看我回答过的两个问题：<br><a href="https://www.zhihu.com/question/306193181/answer/556626638" target="_blank" rel="noopener">Java Web 开发使用 jsp 页面是否已经落后了？是的话现在流行用什么？</a><br><a href="https://www.zhihu.com/question/309604430/answer/579400528" target="_blank" rel="noopener">spring cloud怎么传递参数到同个项目的jsp？</a></p>
<p>别人的问题和文章：<br><a href="https://www.zhihu.com/question/61385975" target="_blank" rel="noopener">为什么spring boot不能很好的支持jsp？</a><br><a href="https://zhuanlan.zhihu.com/p/33155755" target="_blank" rel="noopener">启蛰：12.Spring Boot之开启JSP支持</a></p>
<p>总之，Spring Boot开发JSP有一些限制！如果要开发JSP，还要做额外的配置，这不就和Spring Boot减少配置让项目快速启动开发的理念背道而离了吗？不仅仅是限制JSP，而是现在前后端分离的开发就是大势所趋。因为前端越来越专业越来越复杂了，从语言到框架到开发工具已经完全和服务器端不同了，服务器端包含JSP在内的模板语言越来越没有用了。</p>
<p>上面并没有说明确。如果对Spring Framework有最新了解的话，就会知道所谓的“Spring Boot对JSP有一些限制”指的是Spring Boot 结合 Spring MVC的情况下，也就是用spring-boot-starter-web这个Starter的时候。</p>
<p>Spring Boot开发Web应用难道可以不用Spring MVC，还能用其他框架？当然啊，我在回答的第一部分，讲Spring Boot和SSM本质区别的时候就提到了。我们还可以让Spring Boot用spring-boot-starter-webflux这个Starter，用上Spring 5最新提供的Spring WebFlux！关于WebFlux，可以看我另外一个回答：<br><a href="https://www.zhihu.com/question/294282002/answer/521229241" target="_blank" rel="noopener">Spring MVC 过时了吗？</a></p>
<p>我们再次看一下Spring官网<a href="http://spring.io" target="_blank" rel="noopener">spring.io</a>的一副大图(我上面这个回答也用了这幅图)：</p>
<p><img src="0x3.jpg" alt="0x3"></p>
<p>右侧是传统的Spring MVC，是基于Servlet API的，也就是说至少还支持JSP，只是有一些限制。而左侧是Spring 5最新推出的Spring WebFlux，完全不支持JSP！</p>
<p>看一下Spring Boot文档里分别是怎么说的：</p>
<p>Spring Boot结合Spring MVC部分：<br><img src="0x4.jpg" alt="0x4"><br>正式支持的列表里没有JSP，至少提了一下JSP有限制。</p>
<blockquote>
<p>If possible, JSPs should be avoided.<br>如果可能的话，最好别用JSP。</p>
</blockquote>
<p>Spring Boot结合Spring WebFlux部分：<br><img src="0x5.jpg" alt="0x5"><br>根本不支持JSP</p>
<p>压根没提到JSP。</p>
<h3 id="再多谈一些"><a href="#再多谈一些" class="headerlink" title="再多谈一些"></a>再多谈一些</h3><p>我们再看看Spring官网<a href="http://Spring.io" target="_blank" rel="noopener">Spring.io</a>首页最大最醒目的一幅图。<br><img src="0x6.jpg" alt="0x6"></p>
<p><strong>Your App</strong><br>你的App？难道不是用Spring Boot开发的吗？对。指的是Desktop App、Web App、Mobile App，当然Mobile App也可能是Hybrid或H5开发的。灰色的Your App不是Spring Boot开发的，右侧绿色那三个块块才是。</p>
<p>总之他们都是独立运行在客户端的，他们不是用Spring Boot开发出来的！他们都会向服务器端Spring Boot发送API请求。其中Web App就是我们现在用前端框架写的SPA(Single Page Application)，不是JSP，也不是其他任何服务器端模板语言(FreeMarker、Thymeleaf)！ JSP是服务器端生成HTML，不是客户端技术，而是Java Server Page，是 <strong>Page</strong> ，写不出 <strong>APP</strong>。</p>
<p><strong>第一个方块</strong><br>Spring Boot，Build Anything。为啥是Build Anything？按照绝大多数人的理解，Build Web不就完了吗？就好像我现在正在回答的这个问题大多数其他答主片面肤浅理解的那样，Spring Boot和SSM好像没啥区别啊，都是开发Java Web的，只是配置更方便。</p>
<p>Anything，在我回答的第一部分就已经解释过了。Spring Boot没有必须用Spring MVC，可以不用，也可以换成Spring WebFlux。也可以结合其他专用框架开发应用，都不一定要用Web。</p>
<p><strong>第二个方块</strong><br>Spring Cloud，就是基于Spring Boot的。<br>我们看Spring官网<a href="http://spring.io" target="_blank" rel="noopener">spring.io</a>首页的另一副大图：</p>
<p><img src="0x7.jpg" alt="0x7"></p>
<p>注意最左侧灰色的IoT、Mobile、Browser，同样是之前我们引用的三个方块图里最左侧的“Your App”，右侧绿色的才是Spring Cloud架构里的组成部分。IoT是Internet of Things，物联网。</p>
<p>Spring Cloud架构里面包含的的Service Registry、Service Configuration Center、API Gateway、每一个MicroService，都是基于Spring Boot的应用。</p>
<p>特别是每一个MicroService，不会再用模板引擎，当然也不会用JSP。因为所有前端的API请求都发给API Gateway，Gateway再转发给某个微服务。</p>
<p>我们看看Spring Cloud文档里怎么说的：</p>
<blockquote>
<p>Many of those features are covered by <a href="https://link.zhihu.com/?target=https%3A//projects.spring.io/spring-boot">Spring Boot</a>, on which Spring Cloud builds.Spring Boot has an opinionated view of how to build an application with Spring. For instance, it has conventional locations for common configuration files and has endpoints for common management and monitoring tasks. Spring Cloud builds on top of that and adds a few features that probably all components in a system would use or occasionally need.</p>
</blockquote>
<p>比如我们写一个Spring Cloud Config Server：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们写一个Spring Cloud Eureka Service Registry:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们写一个Spring Cloud Zuul Proxy(Gateway):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(GatewayApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我们写一个微服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHelloApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(SayHelloApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/greeting"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Access /greeting"</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; greetings = Arrays.asList(<span class="string">"Hi there"</span>, <span class="string">"Greetings"</span>, <span class="string">"Salutations"</span>);</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> randomNum = rand.nextInt(greetings.size());</span><br><span class="line">    <span class="keyword">return</span> greetings.get(randomNum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Access /"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hi!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(SayHelloApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些都要用到 <strong>@SpringBootApplication</strong></p>
<p>如果MicroService也包含JSP，就产生了这个问题：<br><a href="https://www.zhihu.com/question/309604430/answer/579400528" target="_blank" rel="noopener">spring cloud怎么传递参数到同个项目的jsp？</a></p>
<p>这个问题的提出，就是我上文说过的：在日常开发中，经常会见到一种人，他们学习新框架总是要把自己对以前旧框架的认识和经验往上套。套不上就会骂这个东西真难用，<strong>套上了就会问到底有啥区别为什么要折腾，这就是底层程序员的通病。</strong></p>
<p><strong>第三个方块</strong><br>Spring Cloud DataFlow。我们可以写Stream和Task，做数据的抽取、分析、转换等等，他们同样是Spring Boot的应用！这也是Anything包含的，而SSM没这些！</p>
<p>比如我们写一个Task:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTask</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(MyTask<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样是一个 <strong>@SpringBootApplication</strong></p>
<h3 id="谈一些更深入的问题"><a href="#谈一些更深入的问题" class="headerlink" title="谈一些更深入的问题"></a>谈一些更深入的问题</h3><p>这个问题，我之所以花了将近两天时间去写答案，然后不断补充和修订，不仅仅是因为问题本身。而是这个问题以及问题下的答案充分反映了国内程序员的一些通病，一些根源性的问题。</p>
<p>这些问题及我的观点，也是我从去年开始在知乎回答问题到现在，一年时间里不断纠正、提倡、引导的。</p>
<h3 id="思想要跟上变化"><a href="#思想要跟上变化" class="headerlink" title="思想要跟上变化"></a>思想要跟上变化</h3><p><strong>软件开发，首先是思想活动，其次才是敲代码。</strong> 这句话不知道在我的知乎回答里出现了多少遍了，上面的回答内容中也有所体现。</p>
<p>做软件开发不可避免的遇到新语言、新技术、新框架、新工具的出现。当遇到新东西的时候，必须要问自己：为什么会出现这个东西，以前我开发的好好地，为啥冒出这么个东西来。</p>
<p>我以前用Struts，现在出来个Spring MVC，Spring这帮人是傻吗？<br>我现在用Java，Java太强大了，怎么又出来个Kotlin，JetBrains这帮人是活腻了吗？他们想取代Java？<br>我一直在用JSP，怎么最近几年前端那么火爆？不就是写个页面吗？jQuery不是很好用？那些React、VUE出来干嘛？<br>我以前用SSM，现在出来个Spring Boot，怎么又搞一个新”框架”啊？这个“框架”感觉就是比SSM配置起来方便点，怎么就这么火呢，做Java服务器端的无人不吹Spring Boot？</p>
<p>整个IT产业到目前还属于朝阳产业。软件开发和编程到现在还处于起步阶段，尤其是国内的程序员都是软件开发行业的第一代人，几乎没有自己的父母就是程序员的。软件开发技术就像婴儿，每天一个变化，千万不要用一成不变的眼光看待它。</p>
<p>所以，新产业就会有新需求，就会有新思想不断涌现去满足那些新需求。当原有技术无法支撑新的思想，就必定涌现出新的东西。</p>
<p>如果有人觉得Struts1还能满足需要，只是需要稍加优化，那就出现Struts2。有另外一拨人觉得Struts根本不能支撑自己的新想法，那就出现Spring MVC了，现在又出现Spring WebFlux了。</p>
<p>如果有人觉得jQuery能够满足自己的需要，那就继续维护增加新功能进去。有人觉得满足不了需求，那就Angularjs、Backbone、Ember出来了，后来又有人觉得这些框架无法支撑自己的想法了，搞出第二代前端框架Angular、React、Vue。</p>
<p>所以，学习新技术，千万不要用自己以前建立起来的老经验往上生拉硬套！要分清楚哪部分是传承，哪部分是创新。套不上就骂这个框架难用，套上了就问和以前有什么区别。</p>
<p>以前用SSM，只知道框架。有了Spring Boot就认为它必然就是个新框架而已。然后得出结论：和SSM一样，就是配置简单点。SSM能写的它都能写。殊不知，Spring Boot可能是Java服务器端从来没有出现过的概念，它代表了新理念，不能用任何已经固化的概念去套。</p>
<p>宝宝长出牙，父母就无所适从了，这是又长出一层嘴唇？还是舌头变硬了？反正必须用以前见过的东西网上套。有这样的父母吗？如果没有，那就别用这样的方式去看待软件开发。</p>
<h3 id="为什么不去读文档"><a href="#为什么不去读文档" class="headerlink" title="为什么不去读文档"></a>为什么不去读文档</h3><p>这个问题的回答，我引用了多少Spring的文档？而且<a href="http://Spring.io" target="_blank" rel="noopener">Spring.io</a> 首页的三幅图就说明了很多问题。可惜的是，我见到的大多数开发人员没有阅读过官网文档。从来没有访问过<a href="http://spring.io" target="_blank" rel="noopener">Spring.io</a> 首页的都大有人在，更别提去认真读一遍Spring Boot/Sprint Framework/Spring Cloud/Spring Data这些具体项目的文档。</p>
<p>面试过太多人。</p>
<p>问他们：你们用到Spring了吗？<br>回答：用到了。<br>问：Spring什么版本？<br>回答：不知到。<br>问：看过Spring的文档吗?<br>回答：看过。<br>问：Spring官网地址是什么?<br>回答：不知道。<br>问：那你在哪里看的文档？<br>回答：CSDN、论坛、视频…</p>
<p>但是这个面试者的简历里很可能写着：精通Spring源代码…</p>
<p>曾经在知乎里回答过一个问题：<br><a href="https://www.zhihu.com/question/21346206/answer/349792663" target="_blank" rel="noopener">怎么阅读Spring源码？</a></p>
<p>我和其他所有该问题下的回答都不同，我不支持初学者一头扎入源代码，具体观点可以去这个回答里看。</p>
<p>就拿我们当前的这个问题来说。你要看多少Spring的源代码才能了解我在回答里里阐述的这些事实，才能对Spring Boot从宏观上有一个全面、清晰的理解？</p>
<p>知乎里有很多类似这样的问题：程序员如何避免走弯路？</p>
<p>我觉得对于国内很多程序员来说，最大的弯路、冤枉路就是迷信源代码，跳过熟读文档这一步而一头扎进源代码。</p>
<p>我个人认为的任何成熟软件技术的最佳入门路径都是：</p>
<ol>
<li>先看官方文档。好的技术和框架，官方文档一定全面丰富详实，<a href="http://Spring.io" target="_blank" rel="noopener">Spring.io</a> 就是好文档的典范。所以先把官方文档过一遍，理解的就理解，不理解的要记住在文档的哪一节。</li>
<li>开始实践。有些知识只有实践的过程中才能理解，并且加深认识。遇到问题，知道这个问题对应文档的哪一部分，然后去查文档。</li>
<li>做完一两个实际项目之后，返回去再读一遍文档，这时你会发现自己站在一个新高度上。</li>
<li>1/2/3部分循环…</li>
</ol>
<p>越成熟越优秀的开源框架，文档就越丰富越详实。Java这边的Spring 就是最典型的例子，前端的Angular、React都是例子。</p>
<p>如果一个框架文档不齐全，不丰富，说明这个框架本身也不成熟，这个框架的开发团队主要精力还放在功能上，而没有更多地投入到文档上。</p>
<h3 id="别丢掉英语"><a href="#别丢掉英语" class="headerlink" title="别丢掉英语"></a>别丢掉英语</h3><p>英语是工具，是你程序员职业生涯上的一对翅膀。大部分一手资料都是英文的。如何慢慢习惯英文阅读，看我曾经回答过一个问题：<br><a href="https://www.zhihu.com/question/288329542/answer/526126787" target="_blank" rel="noopener">软件开发圈的人，一开始是怎么学会使用纯英文描述的 API和各种软件（比如Tomcat）的使用方法的？</a></p>
<p>看到原来最高赞答案推荐了《Java EE开发的颠覆者：Spring Boot 实战》，我去京东上搜了一下，发现两个问题。</p>
<p>发现Spring Boot最早的中文(原创或翻译)书都是从16年开始陆续上市的。而我14年就开始用Spring Boot，15年初开始用JHipster 2.0了。</p>
<p>我没有看过那些书，所以对书的内容不做评价。但是发现另一个问题，就是这些书都叫Spring Boot实战、Spring Boot揭秘、深入浅出Spring Boot，中文编程的书好像就想不起什么好名字了。尤其是这个”揭秘“。我只在小时候看UFO、玛雅文明、亚特兰蒂斯、克格勃这些书才能看到这个词。Spring Boot有什么秘密可言吗？代码都是开源的！文档随便读！</p>
<p>Spring团队生怕大家不会用，生怕大家不理解，编写了完备的文档，给出了丰富的例子。结果两年后中文书好像还能挖出Spring官方自己都不知道的什么秘密，并且能写厚厚一本。</p>
<p>官方团队在这里给出了八十多个例子：<br><a href="https://link.zhihu.com/?target=https%3A//github.com/spring-projects/spring-boot/tree/master/spring-boot-samples">spring-projects/spring-boot</a></p>
<p>长图预警八十多个例子：</p>
<p><img src="0x8.jpg" alt="0x8"></p>
<p>这些例子涵盖了Spring Boot的方方面面，各种用法各种特性应有尽有。网上第三方的例子还有很多很多。</p>
<p>可悲的是，国内Java服务器端开发人员对如此丰富免费的文档和例子视而不见，却要多等两年，还要花几十几百块钱去买xxx揭秘xxx实战。</p>
<h3 id="更多内容推荐"><a href="#更多内容推荐" class="headerlink" title="更多内容推荐"></a>更多内容推荐</h3><p>最后推荐我专栏里的两篇文章：<br><a href="https://zhuanlan.zhihu.com/p/55173112" target="_blank" rel="noopener">陈龙：跟着官方文档学Spring Boot (0) Overview</a><br><a href="https://zhuanlan.zhihu.com/p/55249159" target="_blank" rel="noopener">陈龙：跟着官方文档学Spring Boot (2) Getting Started</a></p>
<p>这个系列文章的后续章节会持续更新。</p>
<p>哦，对了，学习Spring Boot并且想充分把握和发扬Spring Boot的优势，可以学一下JHipster。JHipster本身以及它包含的所有最佳实践(Best Practice)，都是我们使用Spring Boot时候应该学习和应用的。</p>
<p>如果说Spring Boot能够让你的快速搭建Java服务器端应用，那么JHipster则把这种理念发展到了全栈。服务器端继续使用Spring Boot，前端使用Angular/React/VUE，让你快速搭建一个全栈应用！</p>
<p>所以，又要介绍我的另一个专栏了：<br><a href="https://zhuanlan.zhihu.com/c_1008296180270391296" target="_blank" rel="noopener">JHipster</a></p>
<div class="note primary">
            <p><strong>转载链接：</strong> <a href="https://www.zhihu.com/question/284488830/answer/618290880" target="_blank" rel="noopener">spring boot和SSM开发中有什么区别？ - 陈龙的回答 - 知乎</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 153. 寻找旋转排序数组中的最小值</title>
    <url>/2021/02/26/LeetCode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>二分查找经典题，太tm经典了，对于理解二分查找真是好题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>请找出其中最小的元素。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong> nums = [3,4,5,1,2]<br><strong>输出：</strong> 1</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong> nums = [4,5,6,7,0,1,2]<br><strong>输出：</strong> 0</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p><strong>输入：</strong> nums = [1]<br><strong>输出：</strong> 1</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= nums.length &lt;= 5000$</li>
<li>$-5000 &lt;= nums[i] &lt;= 5000$</li>
<li><code>nums</code> 中的所有整数都是 唯一 的</li>
<li><code>nums</code> 原来是一个升序排序的数组，但在预先未知的某个点上进行了旋转</li>
</ul>
<hr>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>题目要求找到折叠后的递增数组的第二段递增序列的左端点。<br>可以利用二分的思想，如果 <code>mid</code> 落在左半边，那么左边界最低取到 <code>mid+1</code>；<br>如果 <code>mid</code> 落在右半边，那么右边界最高取到 <code>mid</code>。<br>问题是，如何判断 <code>mid</code> 落在哪一边。</p>
<p>因为折叠数组是从一个未知点折叠的，所以折叠数组左半边的所有数都大于等于第一个数，右半边都小于等于第一个数。依此可判断 <code>mid</code> 落在哪一边。</p>
<p>注意这一题有个很坑的地方，测试用例存在折叠数组完全递增的情况，也就是默认折叠点在数组下标范围之外。需要进行特判。</p>
<p>这一题的二分法找数字，利用目标值左半边和右半边的性质不同来缩小范围。<br>但是和该性质相关的点却是折叠数组的第一个数，而非目标值本身。<br>这一点尤为需要注意。一句话，想找目标值，在考虑性质的时候，不一定从目标值入手。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 8 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 9.7 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[lo];       <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">int</span> cmp = <span class="number">0</span>;                                    <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[cmp]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 38 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">LeetCode 153. 寻找旋转排序数组中的最小值</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 11. 旋转数组的最小数字</title>
    <url>/2021/02/26/%E5%89%91%E6%8C%87Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>二分查找经典应用。</p>
<a id="more"></a>


<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。  </p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong> [3,4,5,1,2]<br><strong>输出：</strong> 1</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong> [2,2,2,0,1]<br><strong>输出：</strong> 0</p>
</blockquote>
<hr>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>本题与 <a href="https://eetoa.github.io/2021/02/26/LeetCode-154-寻找旋转排序数组中的最小值-II/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值 II</a> 完全一致。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 4 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 11.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判非递减情况（折叠点不在原数组下标范围内）</span></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判折叠点在重复数字中的情况（折叠后数组首尾相同）</span></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi &amp;&amp; nums[hi] == nums[<span class="number">0</span>]; hi--); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时存在两种情况，一是右半边还有数字，二是右半边无数字</span></span><br><span class="line">        <span class="comment">// 如果是右半边有数字，那么右半边递增，全部数字小于num[0];</span></span><br><span class="line">        <span class="comment">// 如果右半边没有数字，也就是说hi到了左半边，直接返回nums[0];</span></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[<span class="number">0</span>]) <span class="keyword">return</span> nums[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常规情况，和153题解法一致</span></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 38.3 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = len - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi &amp;&amp; nums[lo] == nums[hi]; hi--);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] &gt; nums[lo]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; lo &lt; hi;) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="暴搜"><a href="#暴搜" class="headerlink" title="暴搜"></a>暴搜</h3><p>暴力Loop一把梭，复杂度为 $O(N)$.</p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">c++</a></li><li class="tab"><a href="#g_tab1-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 4 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 11.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        len = numbers.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &lt; numbers[i - <span class="number">1</span>]) <span class="keyword">return</span> numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 38.3 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        len = numbers.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &lt; numbers[i - <span class="number">1</span>]) <span class="keyword">return</span> numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">剑指Offer 11. 旋转数组的最小数字</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二分查找</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 10-II. 青蛙跳台阶问题</title>
    <url>/2021/02/26/%E5%89%91%E6%8C%87Offer-10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>动态规划入门题。</p>
<a id="more"></a>


<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br>__<br><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong> n = 2<br><strong>输出：</strong> 2</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong> n = 7<br><strong>输出：</strong> 21</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p><strong>输入：</strong> n = 0<br><strong>输出：</strong> 1</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$ 0 &lt;= n &lt;= 100 $</li>
</ul>
<hr>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>注意数值溢出，可以每一步计算取模。正确性证明参见：<br><a href="https://eetoa.github.io/2021/02/25/剑指Offer-10-I-斐波那契数列/" target="_blank" rel="noopener">剑指Offer 10-I. 斐波那契数列</a><br>还有一点就是注意特判 <code>n == 0</code> 的情况。<br>本题起始位置为0层。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.9 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> _mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int64_t</span> dp[n + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">            dp[i] %= _mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.2 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">110</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">            dp[i] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="空间复杂度优化的动态规划"><a href="#空间复杂度优化的动态规划" class="headerlink" title="空间复杂度优化的动态规划"></a>空间复杂度优化的动态规划</h3><p>可以用三个变量滚动更新，代替数组。<br>核心是一共计算$n - 1$次，每次计算 <code>c</code> 的值，动态更新 <code>a</code> , <code>b</code>。</p>
<div class="tabs" id="g_tab1-0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-0-1">C++</a></li><li class="tab"><a href="#g_tab1-0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int64_t</span> a, b, c;</span><br><span class="line">        c = b = a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            c %= mod;</span><br><span class="line">            a = b, b = c;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.2 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            c %= mod;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">剑指Offer 10- II. 青蛙跳台阶问题</a></p>
          </div>

]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 79. 单词搜索</title>
    <url>/2021/02/27/LeetCode-79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>回溯算法经典问题，暴力深搜。</p>
<a id="more"></a>


<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p>
<p>给定 word = “ABCCED”, 返回 true<br>给定 word = “SEE”, 返回 true<br>给定 word = “ABCB”, 返回 false</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>board</code> 和 <code>word</code> 中只包含大写和小写英文字母。</li>
<li>$1 &lt;= board.length &lt;= 200$</li>
<li>$1 &lt;= board[i].length &lt;= 200$</li>
<li>$1 &lt;= word.length &lt;= 10^3$</li>
</ul>
<hr>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>搜索方式有点类似 <strong>洪水灌溉算法</strong>。遍历数组找出起点，对于每一个起点启动深搜，每一个字符搜索三个方向，直到匹配或者字符不相同为止。<br>可以借助辅助数组标记正确的节点位置防止字符重复使用（路径重叠），也可以原地更改节点字符为一个非字母字符。<br>回溯的时候记得恢复现场，标记数组或者更改的字符要恢复成递归之前的值。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">C++</a></li><li class="tab"><a href="#g_tab0-3">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-23 17:18:25</span></span><br><span class="line"><span class="comment"> * @Author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;R = board.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;C = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;len = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!R || !len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="keyword">word</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">                    dfs(board, <span class="keyword">word</span>, i, j, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> &amp;<span class="keyword">word</span>, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[r][c] == <span class="keyword">word</span>[k]) &#123;</span><br><span class="line">                res = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else if k &lt; len - 1</span></span><br><span class="line">        <span class="keyword">if</span> (board[r][c] != <span class="keyword">word</span>[k]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// match for the current node</span></span><br><span class="line">            <span class="keyword">char</span> tmp = board[r][c];</span><br><span class="line">            board[r][c] = <span class="string">'*'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[i], nec = c + dc[i];</span><br><span class="line">                <span class="keyword">if</span> (ner &lt; <span class="number">0</span> || ner &gt; R - <span class="number">1</span> || nec &lt; <span class="number">0</span> || nec &gt; C - <span class="number">1</span> || board[ner][nec] == <span class="string">'*'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dfs(board, <span class="keyword">word</span>, ner, nec, k + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (res) <span class="keyword">return</span>;    <span class="comment">// if found, return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// not match for the next 4 directions </span></span><br><span class="line">            <span class="comment">// restore</span></span><br><span class="line">            board[r][c] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 44 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 11.1 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">string</span> w;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        b = board, w = <span class="keyword">word</span>;</span><br><span class="line">        m = b.<span class="built_in">size</span>(), n = b[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        len = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        st = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; (m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b[i][j] == w[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b[r][c] != w[u]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正确的节点</span></span><br><span class="line">        st[r][c] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; !st[ner][nec]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(ner, nec, u + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        st[r][c] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-3"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 7 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 40.1 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[][] b;</span><br><span class="line">    String w;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span>[] dr, dc;</span><br><span class="line">    <span class="keyword">boolean</span>[][] st;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        b = board;</span><br><span class="line">        w = word;</span><br><span class="line">        m = b.length;</span><br><span class="line">        n = b[<span class="number">0</span>].length;</span><br><span class="line">        len = w.length();</span><br><span class="line">        dr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        dc = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        st = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(st[i], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b[i][j] == w.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b[r][c] != w.charAt(u)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == len - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// else keep checking</span></span><br><span class="line">        st[r][c] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; !st[ner][nec]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(ner, nec, u + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st[r][c] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">LeetCode 79. 单词搜索</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>Flood Fill</tag>
        <tag>洪水灌溉算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 13. 机器人的运动范围</title>
    <url>/2021/02/27/%E5%89%91%E6%8C%87Offer-13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>DFS BFS模板题。</p>
<a id="more"></a>


<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong> m = 2, n = 3, k = 1<br><strong>输出：</strong> 3</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong> m = 3, n = 1, k = 0<br><strong>输出：</strong> 1</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= n,m &lt;= 100$</li>
<li>$0 &lt;= k &lt;= 20$</li>
</ul>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>本题是从左上向右下搜索，所以可以只用两个方向。以下代码可以进一步优化。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 6.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTwoSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(x) + getSum(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x /= <span class="number">10</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int64_t</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> g_m, g_n, g_k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        g_m = m, g_n = n, g_k = k;</span><br><span class="line">        st = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        res++;</span><br><span class="line">        st[r][c] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; g_m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; g_n &amp;&amp; getTwoSum(ner, nec) &lt;= g_k &amp;&amp; !st[ner][nec]) &#123;</span><br><span class="line">                dfs(ner, nec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 36 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x &gt; <span class="number">0</span>; x /= <span class="number">10</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getTwoSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(x) + getSum(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> g_m, g_n, g_k;</span><br><span class="line">    <span class="keyword">int</span>[] dr, dc;</span><br><span class="line">    <span class="keyword">boolean</span>[][] st;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        g_m = m;</span><br><span class="line">        g_n = n;</span><br><span class="line">        g_k = k;</span><br><span class="line">        dr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        dc = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        st = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ ) &#123;</span><br><span class="line">            Arrays.fill(st[i], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        res++;</span><br><span class="line">        st[r][c] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; g_m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; g_n &amp;&amp; !st[ner][nec] &amp;&amp; getTwoSum(ner, nec) &lt;= g_k) &#123;</span><br><span class="line">                dfs(ner, nec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>注意响铃节点的竞争问题，要在下一个节点入队时将节点更新成已占据，以避免此问题。</p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">c++</a></li><li class="tab"><a href="#g_tab1-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 4 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 6.4 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x /= <span class="number">10</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTwoSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(x) + getSum(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> g_m, g_n, g_k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        g_m = m, g_n = n, g_k = k;</span><br><span class="line">        st = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        bfs(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        st[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; q.<span class="built_in">size</span>();) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = q.front().first, c = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">2</span>; d++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">                <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; g_m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; g_n &amp;&amp; !st[ner][nec] &amp;&amp; getTwoSum(ner, nec) &lt;= g_k) &#123;</span><br><span class="line">                    q.push(&#123;ner, nec&#125;);</span><br><span class="line">                    st[ner][nec] = <span class="literal">true</span>;    <span class="comment">// 避免相邻节点竞争</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 5 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x &gt; <span class="number">0</span>; x /= <span class="number">10</span>) &#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTwoSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(x) + getSum(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n, k;</span><br><span class="line">    <span class="keyword">int</span>[] dr, dc;</span><br><span class="line">    <span class="keyword">boolean</span>[][] st;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        dr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        dc = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        st = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            Arrays.fill(st[i], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bfs(<span class="number">0</span> * n + <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.add(hash);</span><br><span class="line">        st[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; q.size() &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="keyword">int</span> _hash = q.remove();</span><br><span class="line">            <span class="keyword">int</span> r = _hash / n, c = _hash % n;</span><br><span class="line">            res++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[i], nec = c + dc[i];</span><br><span class="line">                <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; !st[ner][nec] &amp;&amp; getTwoSum(ner, nec) &lt;= k) &#123;</span><br><span class="line">                    q.add(ner * n + nec);</span><br><span class="line">                    st[ner][nec] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>



<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">剑指Offer 13. 机器人的运动范围</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>快速优雅裸连github</title>
    <url>/2021/02/28/%E5%BF%AB%E9%80%9F%E4%BC%98%E9%9B%85%E8%A3%B8%E8%BF%9Egithub/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>真的好丝滑。</p>
<a id="more"></a>


<h3 id="改Hosts大法"><a href="#改Hosts大法" class="headerlink" title="改Hosts大法"></a>改Hosts大法</h3><p>一共6个ip地址及网址，每行一个，中间注意空格。</p>
<ul>
<li>打开../Windows/System32/drivers/etc/hosts</li>
<li><ol>
<li>打开链接 <strong><a href="https://github.com.ipaddress.com/" target="_blank" rel="noopener">https://github.com.ipaddress.com/</a></strong><br>将 <strong>IP Address</strong> 拷贝到hosts文件新的一行，后面加上 <code>github.com</code></li>
</ol>
</li>
<li><ol start="2">
<li>打开链接 <strong><a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo" target="_blank" rel="noopener">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo</a></strong><br>将 <strong>IP Address</strong> 拷贝到hosts文件新的一行，后面加上 <code>github.global.ssl.fastly.net</code></li>
</ol>
</li>
<li><ol start="3">
<li>打开链接 <strong><a href="https://github.com.ipaddress.com/assets-cdn.github.com" target="_blank" rel="noopener">https://github.com.ipaddress.com/assets-cdn.github.com</a></strong> 将Frequently Asked Question (FAQ) 下的四行ip地址拷贝到hosts文件新的四行，后面分别加上 <code>assets-cdn.github.com</code></li>
</ol>
</li>
<li>管理员模式保存hosts文件</li>
<li>刷新DNS缓存 cmd: <code>ipconfig /flushdns</code></li>
</ul>
<h3 id="改好如下所示"><a href="#改好如下所示" class="headerlink" title="改好如下所示"></a>改好如下所示</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">140.82.114.3        github.com </span><br><span class="line">199.232.69.194      github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153     assets-cdn.github.com</span><br><span class="line">185.199.109.153     assets-cdn.github.com</span><br><span class="line">185.199.110.153     assets-cdn.github.com</span><br><span class="line">185.199.111.153     assets-cdn.github.com</span><br></pre></td></tr></table></figure>

<div class="note primary">
            <p><strong>转载链接：</strong> <a href="https://juejin.cn/post/6844904193170341896" target="_blank" rel="noopener">GitHub无法访问、443 Operation timed out的解决办法</a></p>
          </div>]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring注解 @Component @Repository @service @Controller之间的区别</title>
    <url>/2021/03/01/Spring%E6%B3%A8%E8%A7%A3-Component-Repository-service-Controller%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>[待完善] 这四个注解主要作用。</p>
<a id="more"></a>


<h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p><code>@Component</code> 、 <code>@Repository</code> 、 <code>@Service</code> 、 <code>@Controller</code> 都是用来自动注册bean的。<br>在 <code>SpringApplication.run()</code> 启动的时候，spring会自动创建一个IOC容器，并且为IOC容器自动扫描配置类所在包以及子包下的所有被以上四个注解标注的类。<br>区别在于：<br><code>@Service</code> 用于标注业务层组件<br><code>@Controller</code> 用于标注控制层组件（如struts中的action），处理请求。<br><code>@Repository</code> 用于标注数据访问组件，即DAO组件<br><code>@Component</code> 泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注，在以上三种任意地方使用。</p>
<div class="note primary">
            <p><strong>转载链接：</strong> <a href="https://zhuanlan.zhihu.com/p/28346387" target="_blank" rel="noopener">呵呵一笑很倾城 | 知乎</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 12. 矩阵中的路径</title>
    <url>/2021/02/27/%E5%89%91%E6%8C%87Offer-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>回溯算法经典题。</p>
<a id="more"></a>


<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,” <strong>b</strong> “,”c”,”e”],<br>[“s”,” <strong>f</strong> “,” <strong>c</strong> “,”s”],<br>[“a”,”d”,” <strong>e</strong> “,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong> board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br><strong>输出：</strong> true</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong> board = [[“a”,”b”],[“c”,”d”]], word = “abcd”<br><strong>输出：</strong> false</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= board.length &lt;= 200$</li>
<li>$1 &lt;= board[i].length &lt;= 200$</li>
</ul>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>本题与 <a href="https://eetoa.github.io/2021/02/27/LeetCode-79-单词搜索/" target="_blank" rel="noopener">单词搜索</a> 完全相同。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 44 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 11.1 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">string</span> w;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        b = board, w = <span class="keyword">word</span>;</span><br><span class="line">        m = b.<span class="built_in">size</span>(), n = b[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        len = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        st = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; (m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b[i][j] == w[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b[r][c] != w[u]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正确的节点</span></span><br><span class="line">        st[r][c] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; !st[ner][nec]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(ner, nec, u + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        st[r][c] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 7 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 40.1 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[][] b;</span><br><span class="line">    String w;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span>[] dr, dc;</span><br><span class="line">    <span class="keyword">boolean</span>[][] st;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        b = board;</span><br><span class="line">        w = word;</span><br><span class="line">        m = b.length;</span><br><span class="line">        n = b[<span class="number">0</span>].length;</span><br><span class="line">        len = w.length();</span><br><span class="line">        dr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        dc = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        st = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(st[i], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b[i][j] == w.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b[r][c] != w.charAt(u)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == len - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// else keep checking</span></span><br><span class="line">        st[r][c] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[d], nec = c + dc[d];</span><br><span class="line">            <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; m &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; n &amp;&amp; !st[ner][nec]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(ner, nec, u + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st[r][c] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>



<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指Offer 12. 矩阵中的路径</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>剑指Offer</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 10-I. 斐波那契数列</title>
    <url>/2021/02/25/%E5%89%91%E6%8C%87Offer-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>动态规划入门题。</p>
<a id="more"></a>


<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，输入 $n$ ，求斐波那契（Fibonacci）数列的第 $n$ 项（即 $F(N)$）。斐波那契数列的定义如下：</p>
<blockquote>
<p>$F(0) = 0,   F(1) = 1$</p>
<p>$F(N) = F(N - 1) + F(N - 2)$, 其中 $N &gt; 1.$</p>
</blockquote>
<p>斐波那契数列由 $0$ 和 $1$ 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 $10^9 + 7$（$1000000007$），如计算初始结果为：$1000000008$，请返回 $1$。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong> n = 2<br><strong>输出：</strong> 1</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong> n = 5<br><strong>输出：</strong> 5</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$ 0 &lt;= n &lt;= 100 $</li>
</ul>
<hr>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>考虑数字越界问题，需要在每一步求解时都进行求余运算。<br>循环求余证明：<br>设正整数 $ x, y, p$，求余符号为$⊙$，则有<br>$ (x + y) ⊙ p = (x ⊙ p + y ⊙ p) ⊙ p $<br>那么，在本题中：</p>
<p>$ f(n) ⊙ p = [f(n−1) ⊙ p + f(n−2) ⊙ p] ⊙ p $;</p>
<p>求 $f(n - 2)$ 时，将其更新为 $f(n - 2)$ 模以 $1000000007$;</p>
<p>求 $f(n - 1)$ 时，将其更新为 $f(n - 1)$ 模以 $1000000007$;</p>
<p>那么，根据上式，在求 $f(n)$ 时，将其更新为 $f(n - 2) + f(n - 1)$ 模以<br> $1000000007$ 显然正确。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.9 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int64_t</span> _mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int64_t</span> dp[<span class="number">110</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">            dp[i] %= _mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.2 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">110</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">            dp[i] %= _mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">剑指Offer 10- I. 斐波那契数列</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 191. 位1的个数</title>
    <url>/2021/03/03/LeetCode-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>位运算判断最低位1。</p>
<a id="more"></a>


<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <strong>汉明重量</strong>）。</p>
<p><strong>提示：</strong></p>
<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p>
<p><strong>进阶：</strong></p>
<p>如果多次调用这个函数，你将如何优化你的算法？</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong> 00000000000000000000000000001011<br><strong>输出：</strong> 3<br><strong>解释：</strong> 输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong> 00000000000000000000000010000000<br><strong>输出：</strong> 1<br><strong>解释：</strong> 输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p><strong>输入：</strong> 11111111111111111111111111111101<br><strong>输出：</strong> 31<br><strong>解释：</strong> 输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>输入必须是长度为 <code>32</code> 的 二进制串 。</li>
</ul>
<hr>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>使用lowbit找到 <code>x</code> 最低位1以及其更低位所有0所表示的数，更新 <code>x</code>.</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.9 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">uint32_t</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; n; n -= lowbit(n)) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.3 MB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; n != <span class="number">0</span>; n -= lowbit(n)) res++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>注意c++和java的传入参数 <code>n</code> 一个是无符号整型（unsigned int）一个是有符号整型（int），因为java中没有无符号整型，所以理解的时候需要注意区别。但是代码没有区别，因为不管有无符号，数字在计算机底层都是以补码形式表示的， <code>lowbit</code> 返回的值一定是补码最低位1以及其更低位所有0表示的数。</p>
<p>举个例子说明它们的区别，对于示例3：<br><code>11111111111111111111111111111101</code><br>这个二进制数字在这道题的c++中表示为一个补码正数 <code>4294967293</code>，<br>而在java中，因为是有符号的，表示一个补码负数 <code>-3</code>.<br>也就是说，这道题在LeetCode后端评测器参数设定中，是用的不同数字分别表示c++和java语言中的这个二进制数的。</p>
<p>c++中对这个数进行一次 <code>lowbit</code> 操作得到的数为：<br><code>1</code> ，对应二进制补码为 <code>00000000000000000000000000000001</code><br>java中对这个数进行一次 <code>lowbit</code> 操作得到的数为：<br><code>1</code> ，对应二进制补码为 <code>00000000000000000000000000000001</code><br>是完全相同的。<br><code>lowbit</code> 赛高~！</p>
<h3 id="位运算小技巧"><a href="#位运算小技巧" class="headerlink" title="位运算小技巧"></a>位运算小技巧</h3><p>在二进制表示中，数字 <code>n</code> 的 <strong>最低位</strong> 1总是对应 <code>n - 1</code> 中的0。<br>也就是说，<code>n - 1</code> 恰好等于，<code>n</code> 的最低位1开始到最低位全部取反（因为和 <code>n</code> 的最低位借了一位1），最低位1开始到最高位全部不变。<br>利用这一性质，利用 <code>n &amp; n - 1</code> 可以巧妙找到最低位1，即， <code>n &amp; n - 1</code> 为最低位1开始到最低位全部为0，到最高位全部相同.<br>在这里, <code>n &amp; n - 1</code> 等价于 <code>n - lowbit(n)</code>.</p>
<div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">c++</a></li><li class="tab"><a href="#g_tab1-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; n; n &amp;= n - <span class="number">1</span>) res++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab1-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.2 MB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; n != <span class="number">0</span>; n &amp;= n - <span class="number">1</span>) res++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="循环，用掩码判断"><a href="#循环，用掩码判断" class="headerlink" title="循环，用掩码判断"></a>循环，用掩码判断</h3><p>从最低位开始，设置一个掩码，初始化为 <code>00000000000000000000000000000001</code>.<br>让其对原数字进行 <code>&amp;</code> 运算，判断最低位是否为 <code>1</code>。<br>然后掩码左移一位，更新掩码，依次逐位判断当前位是否为 <code>1</code>.<br>注意在c++中，需要用无符号整型来表示掩码。</p>
<div class="tabs" id="g_tab2"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab2-1">c++</a></li><li class="tab"><a href="#g_tab2-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab2-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.7 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; mask) res++;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab2-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 36.2 MB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) res++;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="循环，用原数字判断"><a href="#循环，用原数字判断" class="headerlink" title="循环，用原数字判断"></a>循环，用原数字判断</h3><p>可以固定掩码 <code>1</code>， 不断右移原数字，始终判断最低位。<br>因为c++中，原数字为无符号整型，所以原数字可以直接右移；<br>而java中，原数字有符号，所以需要使用无符号右移运算符 <code>&gt;&gt;&gt;</code>.</p>
<div class="tabs" id="g_tab3"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab3-1">c++</a></li><li class="tab"><a href="#g_tab3-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab3-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.9 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; mask) res++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab3-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.4 MB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) res++;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="轮子"><a href="#轮子" class="headerlink" title="轮子"></a>轮子</h3><p>使用c++和java的内置轮子。</p>
<div class="tabs" id="g_tab4"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab4-1">c++</a></li><li class="tab"><a href="#g_tab4-2">java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab4-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 0 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 5.8 MB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __builtin_popcount(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab4-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行用时: 1 ms</span></span><br><span class="line"><span class="comment">// 内存消耗: 35.2 MB</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">LeetCode 191. 位1的个数</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
        <tag>lowbit</tag>
        <tag>汉明重量</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 15. 二进制中1的个数</title>
    <url>/2021/03/03/%E5%89%91%E6%8C%87Offer-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>位运算判断最低位1。</p>
<a id="more"></a>


<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong> 00000000000000000000000000001011<br><strong>输出：</strong> 3<br><strong>解释：</strong> 输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong> 00000000000000000000000010000000<br><strong>输出：</strong> 1<br><strong>解释：</strong> 输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p><strong>输入：</strong> 11111111111111111111111111111101<br><strong>输出：</strong> 31<br><strong>解释：</strong> 输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>输入必须是长度为 32 的 二进制串 。</li>
</ul>
<hr>
<p>与 <a href="https://eetoa.github.io/2021/03/03/LeetCode-191-位1的个数/" target="_blank" rel="noopener">位1的个数</a> 重复。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">剑指Offer 15. 二进制中1的个数</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
        <tag>lowbit</tag>
        <tag>剑指Offer</tag>
        <tag>汉明重量</tag>
      </tags>
  </entry>
  <entry>
    <title>关于人际关系的一点点思考</title>
    <url>/2021/03/10/%E5%85%B3%E4%BA%8E%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>生活感悟。</p>
<a id="more"></a>


<h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>通过很长时间的观察和实践，我总结出了一个道理，人与人之间关系要想处的好，无非三个词：</p>
<p><strong>真诚</strong>，<strong>亲切</strong>，<strong>友善</strong>。</p>
<p>看似是没啥营养的大道理，实则为人情练达。</p>
<p>想TA之所想，感TA之所受，对TA多加关怀，让TA觉得自己是被重视的。</p>
<p>记住，要用心经营。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人际关系</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10 MySQL服务端完全卸载+安装</title>
    <url>/2021/03/05/Win10-MySQL%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BD-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>记录一下步骤。</p>
<a id="more"></a>


<h3 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h3><ul>
<li><p>定位到MySQL安装目录下的bin目录</p>
</li>
<li><p>打开cmd，假设需要备份到T盘根目录，那么键入：（其中，<code>root</code> 为用户名）<br><code>mysqldump --all-database &gt; T:\all_database.sql -u root -p</code></p>
</li>
<li><p>输入用户密码</p>
</li>
</ul>
<h3 id="彻底卸载MySQL"><a href="#彻底卸载MySQL" class="headerlink" title="彻底卸载MySQL"></a>彻底卸载MySQL</h3><ul>
<li><p>停止mysql服务<br>win+R→输入services.msc→服务→找到mysql并停止。</p>
</li>
<li><p>卸载mysql程序，mysql免安装版的删除安装目录即可<br>win+R→输入control→控制面板→卸载程序→找到mysql并卸载。</p>
</li>
<li><p>删除MySQL环境变量</p>
</li>
<li><p>彻底删除mysql配置文件和数据目录<br>确保安装目录已删除干净，我的安装目录是C:\Program Files\MySQL\MySQL Server 5.5\；<br>找到隐藏的数据目录并删除，默认安装位置在C:\ProgramData\MySQL\目录下，删除其中对应旧版本的mysql的目录，我的数据目录是C:\ProgramData\MySQL\MySQL Server 5.5/。<br><strong>注意：数据目录是隐藏的。</strong> </p>
</li>
<li><p>清理注册表<br>win+R→输入regedit→注册表编辑器<br>删除如下内容：<br><img src="0.png" alt="0"></p>
</li>
<li><p>重启电脑</p>
</li>
</ul>
<h3 id="安装MySQL服务端"><a href="#安装MySQL服务端" class="headerlink" title="安装MySQL服务端"></a>安装MySQL服务端</h3><ul>
<li><p>打开链接：<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">MySQL Community</a></p>
</li>
<li><p>下载压缩包</p>
</li>
<li><p>解压后在根目录下添加配置文件 <strong>my.ini</strong> ，内容为：（其中 <strong>basedir</strong> 为根目录）</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="attr">basedir</span>=T:\\MySQL\\Server\\mysql-<span class="number">8.0</span>.<span class="number">23</span>-winx64</span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">20</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br></pre></td></tr></table></figure>
</li>
<li><p>将根目录下的 <strong>bin</strong> 目录添加到系统环境变量</p>
</li>
<li><p>cmd下打开 <strong>bin</strong> 目录，执行安装指令：</p>
<blockquote>
<ol>
<li><code>mysqld --initialize --console</code></li>
<li>将 <code>root@localhost:</code>后跟的密码记录保存下来。</li>
<li><code>mysqld install</code></li>
<li><code>net start mysql</code></li>
</ol>
</blockquote>
</li>
</ul>
<div class="note primary">
            <p><strong>参考链接：</strong> <a href="https://blog.csdn.net/hui1setouxiang/article/details/89816176" target="_blank" rel="noopener">level0_older25_cz@CSDN</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂专题</title>
    <url>/2021/03/05/%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>深入快速幂。</p>
<a id="more"></a>

<h3 id="朴素快速幂"><a href="#朴素快速幂" class="headerlink" title="朴素快速幂"></a>朴素快速幂</h3><p>快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在 $O(logn)$ 的时间内计算 $a^n$ 的小技巧，而暴力的计算需要 $O(n)$ 的时间。</p>
<p><strong>二进制取幂</strong> 的想法是，我们将取幂的任务按照指数的 <strong>二进制表示</strong> 来分割成更小的任务。</p>
<p>举例：计算 $3^{13}$.</p>
<p>将$3^{13}$拆成：<br>$3^{13} = 3^{(1101)_2} = 3^8 \cdot 3^4 \cdot 3^1$ </p>
<p>我们可以预处理出来$3^1, 3^4, 3^8$，一共只需计算3次得到答案。<br>3是怎么来的呢？<br>因为$3^{2^3} &lt; 3^{13} &lt; 3^{2^4}$，所以$3 = \lfloor \log_2(13) \rfloor$。</p>
<p>那么，对于$a^n$，因为$n$有$\lfloor \log_2(n) \rfloor + 1$个二进制位，那么当我们预处理出:<br>$a^1, a^2, a^4, a^8,…,a^{2^{\log_2(n)}}$ 后，就只需计算$O(logn)$次乘法即可计算出$a^n$。</p>
<p>而这个预处理的每一个项，都可以由前面的项计算得到。<br>从二进制最低位到最高位，假设全为1，那么每一项都等于前一项的平方；<br>假设从低到高位依次为$101$，那么第一项显然为底数本身，第二项为$1$，第三项并非由第二项得出，而是第一项的平方的平方。</p>
<p>根据这个思想，写代码的时候，我们动态地让指数右移，让$a$与最低位$1$相乘，然而每右移一次，相当于指数$b$除2，等价于$a$对应地更新成$a^2$。当最低位不为$1$时，则$a$继续更新，且不与最低位相乘。</p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res *= a;</span><br><span class="line">        a = a * a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>待更新。</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>位运算</tag>
        <tag>快速幂</tag>
        <tag>矩阵快速幂</tag>
        <tag>高精度快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏逆向】常见内存操作</title>
    <url>/2021/03/17/%E3%80%90%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E3%80%91%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>记录游戏逆向开发中的常见内存操作。</p>
<a id="more"></a>

<p><strong>本篇文章的方法皆经过验证，方法之间尽量保证低耦合，以方便单独使用。</strong></p>
<h3 id="内外部NOP"><a href="#内外部NOP" class="headerlink" title="内外部NOP"></a>内外部NOP</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: GuidedHacking.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">namespace</span> mem </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Internal Nop</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mem::Nop</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DWORD oldprotect;</span><br><span class="line">        VirtualProtect(dst, <span class="built_in">size</span>, PAGE_EXECUTE_READWRITE, &amp;oldprotect);</span><br><span class="line">        <span class="built_in">memset</span>(dst, <span class="number">0x90</span>, <span class="built_in">size</span>);</span><br><span class="line">        VirtualProtect(dst, <span class="built_in">size</span>, oldprotect, &amp;oldprotect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//External</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mem::NopEx</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>, HANDLE hProcess)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>* nopArray = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">size</span>];</span><br><span class="line">        <span class="built_in">memset</span>(nopArray, <span class="number">0x90</span>, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">        DWORD oldprotect;</span><br><span class="line">        VirtualProtectEx(hProcess, dst, <span class="built_in">size</span>, PAGE_EXECUTE_READWRITE, &amp;oldprotect);</span><br><span class="line">        WriteProcessMemory(hProcess, dst, nopArray, <span class="built_in">size</span>, <span class="literal">NULL</span>);</span><br><span class="line">        VirtualProtectEx(hProcess, dst, <span class="built_in">size</span>, oldprotect, &amp;oldprotect);</span><br><span class="line">        <span class="keyword">delete</span>[] nopArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内外部Patch"><a href="#内外部Patch" class="headerlink" title="内外部Patch"></a>内外部Patch</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: GuidedHacking.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">namespace</span> mem </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// internal patch</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mem::Patch</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">char</span>* src, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DWORD oldprotect;</span><br><span class="line">        VirtualProtect(dst, <span class="built_in">size</span>, PAGE_EXECUTE_READWRITE, &amp;oldprotect);</span><br><span class="line">        <span class="built_in">memcpy</span>(dst, src, <span class="built_in">size</span>);</span><br><span class="line">        VirtualProtect(dst, <span class="built_in">size</span>, oldprotect, &amp;oldprotect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//external patch</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mem::PatchEx</span><span class="params">(HANDLE hProcess, <span class="keyword">char</span>* dst, <span class="keyword">char</span>* src, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DWORD oldprotect;</span><br><span class="line">        VirtualProtectEx(hProcess, dst, <span class="built_in">size</span>, PAGE_EXECUTE_READWRITE, &amp;oldprotect);</span><br><span class="line">        WriteProcessMemory(hProcess, dst, src, <span class="built_in">size</span>, <span class="literal">NULL</span>);</span><br><span class="line">        VirtualProtectEx(hProcess, dst, <span class="built_in">size</span>, oldprotect, &amp;oldprotect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内外部读多级指针指向的动态地址"><a href="#内外部读多级指针指向的动态地址" class="headerlink" title="内外部读多级指针指向的动态地址"></a>内外部读多级指针指向的动态地址</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: GuidedHacking.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// externally read address multi-level ptr points to</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">FindDMAAddy</span><span class="params">(HANDLE hProc, <span class="keyword">uintptr_t</span> ptr, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; offsets)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> addr = ptr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; offsets.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ReadProcessMemory(hProc, (BYTE*)addr, &amp;addr, <span class="keyword">sizeof</span>(addr), <span class="number">0</span>);</span><br><span class="line">        addr += offsets[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// internally read address multi-level ptr points to</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">FindDMAAddy</span><span class="params">(<span class="keyword">uintptr_t</span> ptr, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; offsets)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> addr = ptr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; offsets.<span class="built_in">size</span>() ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        addr = *(<span class="keyword">uintptr_t</span>*)addr;</span><br><span class="line">        addr += offsets[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内外部读地址的值"><a href="#内外部读地址的值" class="headerlink" title="内外部读地址的值"></a>内外部读地址的值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: accepted.org.cn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// reads memory externally and return a value as result</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ReadEx</span><span class="params">(<span class="keyword">uintptr_t</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T VALUE;</span><br><span class="line">    ReadProcessMemory(Game::procHandle, (LPCVOID)(address), &amp;VALUE, <span class="keyword">sizeof</span>(VALUE), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reads memory internally and return a value as result</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">Read</span><span class="params">(<span class="keyword">uintptr_t</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T VALUE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> preProtection;</span><br><span class="line">    VirtualProtect(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(address), <span class="keyword">sizeof</span>(address), PAGE_EXECUTE_READWRITE, &amp;preProtection);</span><br><span class="line"></span><br><span class="line">    VALUE = *(T*)address;</span><br><span class="line"></span><br><span class="line">    VirtualProtect(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(address), <span class="keyword">sizeof</span>(address), preProtection, &amp;preProtection);</span><br><span class="line">    <span class="keyword">return</span> VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="内外部读多级指针对应的值"><a href="#内外部读多级指针对应的值" class="headerlink" title="内外部读多级指针对应的值"></a>内外部读多级指针对应的值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: accepted.org.cn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// externally read value multi-level ptr points to</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ReadPtrChainEx</span><span class="params">(<span class="keyword">uintptr_t</span> basePtr, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uintptr_t</span>&gt; offsetList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T VALUE;</span><br><span class="line">    <span class="comment">// don't reads last offset</span></span><br><span class="line">    <span class="keyword">int</span> len = offsetList.<span class="built_in">size</span>() - <span class="number">1</span>;	</span><br><span class="line">    <span class="comment">// updates base pointer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ReadProcessMemory(Game::procHandle, (LPCVOID)(basePtr + offsetList[i]), &amp;basePtr, <span class="keyword">sizeof</span>(basePtr), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// read value with last offset</span></span><br><span class="line">    ReadProcessMemory(Game::procHandle, (LPCVOID)(basePtr + offsetList[len]), &amp;VALUE, <span class="keyword">sizeof</span>(VALUE), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// internally read value multi-level ptr points to</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ReadPtrChain</span><span class="params">(<span class="keyword">uintptr_t</span> basePtr, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uintptr_t</span>&gt; offsetList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T VALUE;</span><br><span class="line">    <span class="comment">// don't reads last offset</span></span><br><span class="line">    <span class="keyword">int</span> len = offsetList.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// updates base pointer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> address = basePtr + offsetList[i];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> preProtection;</span><br><span class="line">        VirtualProtect(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(address), <span class="keyword">sizeof</span>(address), PAGE_EXECUTE_READWRITE, &amp;preProtection);</span><br><span class="line"></span><br><span class="line">        basePtr = *(<span class="keyword">uintptr_t</span>*)address;</span><br><span class="line"></span><br><span class="line">        VirtualProtect(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(address), <span class="keyword">sizeof</span>(address), preProtection, &amp;preProtection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uintptr_t</span> address = basePtr + offsetList[len];</span><br><span class="line">    <span class="comment">// read value with last offset</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> preProtection;</span><br><span class="line">    VirtualProtect(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(address), <span class="keyword">sizeof</span>(address), PAGE_EXECUTE_READWRITE, &amp;preProtection);</span><br><span class="line"></span><br><span class="line">    VALUE = *(T*)address;</span><br><span class="line"></span><br><span class="line">    VirtualProtect(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(address), <span class="keyword">sizeof</span>(address), preProtection, &amp;preProtection);</span><br><span class="line">    <span class="keyword">return</span> VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>游戏逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏逆向】判断内存Page是否可读</title>
    <url>/2021/04/17/%E3%80%90%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E3%80%91%E5%88%A4%E6%96%AD%E5%86%85%E5%AD%98Page%E6%98%AF%E5%90%A6%E5%8F%AF%E8%AF%BB/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>这个方法可以判断指定内存地址是否可读。</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Memory access check</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsMemoryReadable</span><span class="params">(<span class="keyword">uintptr_t</span> base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> length = <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>);</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">size_t</span> read_access</span><br><span class="line">	=	(PAGE_READONLY</span><br><span class="line">		| PAGE_READWRITE </span><br><span class="line">		| PAGE_WRITECOPY </span><br><span class="line">		| PAGE_EXECUTE_READ </span><br><span class="line">		| PAGE_EXECUTE_READWRITE </span><br><span class="line">		| PAGE_EXECUTE_WRITECOPY);</span><br><span class="line">	<span class="comment">//structure to pass to virtual query which will be populated with the page's information</span></span><br><span class="line">	MEMORY_BASIC_INFORMATION mbi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//virtual query returns information on a page</span></span><br><span class="line">	<span class="comment">//if you don't know what a page is , it's basically a contiguous block of memory</span></span><br><span class="line">	<span class="comment">//query for information starting at base</span></span><br><span class="line">	<span class="keyword">if</span> (VirtualQuery(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(base), &amp;mbi, <span class="keyword">sizeof</span>(mbi)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//check read protections. if the page has one of the listed access protections, we can successfully read from it</span></span><br><span class="line">		<span class="keyword">if</span> (!(mbi.Protect &amp; read_access))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//When a process COMMITS a region of virtual memory, the operating system guarantees that it can maintain all the data </span></span><br><span class="line">		<span class="comment">//the process stores in the memory either in physical memory or on disk.</span></span><br><span class="line">		<span class="comment">//so check for MEM_COMMIT because this means the page is able to store data</span></span><br><span class="line">		<span class="comment">//if this is MEM_RESERVE OR MEM_FREE we don't want to attempt a read</span></span><br><span class="line">		<span class="keyword">if</span> (!(mbi.State &amp; MEM_COMMIT))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//make sure the page is not guarded and has access. attempts to read or access these kinds of pages will result in an access violation</span></span><br><span class="line">		<span class="keyword">if</span> (mbi.Protect &amp; (PAGE_GUARD | PAGE_NOACCESS))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//get the start and end of the page</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">auto</span> start = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(mbi.BaseAddress);</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">end</span> = <span class="keyword">static_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(start + mbi.RegionSize);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//check if our memory is within the readable region.</span></span><br><span class="line">		<span class="keyword">return</span> (base &gt;= start) &amp;&amp; ((base + length) &lt;= <span class="built_in">end</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note primary">
            <p><strong>转载链接：</strong> <a href="https://guidedhacking.com/threads/checking-for-readable-memory-c.9822/" target="_blank" rel="noopener">Checking For Readable Memory C++</a></p>
          </div>]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>游戏逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏逆向】LEA指令</title>
    <url>/2021/04/19/%E3%80%90%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E3%80%91LEA%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>举例解释Lea汇编指令的用法和含义。</p>
<a id="more"></a>

<p>As others have pointed out, LEA (load effective address) is often used as a “trick” to do certain computations, but that’s not its primary purpose. The x86 instruction set was designed to support high-level languages like Pascal and C, where arrays—especially arrays of ints or small structs—are common. Consider, for example, a struct representing (x, y) coordinates:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> xcoord;</span><br><span class="line">     <span class="keyword">int</span> ycoord;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Now imagine a statement like:</p>
<p><code>int y = points[i].ycoord;</code></p>
<p>where <code>points[]</code> is an array of Point. Assuming the base of the array is already in <code>EBX</code> , and variable <code>i</code> is in <code>EAX</code> , and <code>xcoord</code> and <code>ycoord</code> are each 32 bits (so <code>ycoord</code> is at offset 4 bytes in the struct), this statement can be compiled to:</p>
<p><code>MOV EDX, [EBX + 8*EAX + 4]    ; right side is &quot;effective address&quot;</code></p>
<p>which will land <code>y</code> in <code>EDX</code>. The scale factor of 8 is because each <code>Point</code> is 8 bytes in size. Now consider the same expression used with the “address of” operator &amp;:</p>
<p><code>int *p = &amp;points[i].ycoord;</code></p>
<p>In this case, you don’t want the value of <code>ycoord</code>, but its address. That’s where LEA (load effective address) comes in. Instead of a <code>MOV</code>, the compiler can generate</p>
<p><code>LEA ESI, [EBX + 8*EAX + 4]</code></p>
<p>which will load the address in <code>ESI</code>.</p>
<div class="note primary">
            <p><strong>转载链接：</strong> <a href="https://stackoverflow.com/a/1665570/15451978" target="_blank" rel="noopener">I. J. Kennedy’s@stackoverflow.com</a></p>
          </div>]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>游戏逆向</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏逆向】How to find entityList in Call of Duty games with IDA tutorial</title>
    <url>/2021/03/31/%E3%80%90%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E3%80%91How-to-find-entityList-in-Call-of-Duty-games-with-IDA-tutorial/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>The title says it all.</p>
<a id="more"></a>

<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><p>The traditional method for all CoD games is to load the binary up in IDA and find the <strong>CG_Init</strong> function. Usually you can search for the string “white”, cross reference it, and one of the cross references will be that <strong>CG_Init</strong> function.</p>
<p>At the tippity-top of this function, you will see some calls to memset</p>
<p><img src="0.png" alt="0x0"></p>
<p>Here you can find a bunch of different structs, including the <strong>cg_entities</strong> struct. This struct contains an array of <strong>centity_t</strong>. Not pointers to <strong>centity_t</strong>.<br><strong>centity_t</strong> contains various information about the player including their position. <strong>cg_entities</strong> is used for both players and bots.</p>
<p>Keep in mind that there are two entity lists. <strong>cgentity_t</strong> and <strong>ClientInfo_t</strong>. <strong>ClientInfo_t</strong> is used to get the player name while <strong>cgentity_t</strong> is used for their position and other data.</p>
<p>Here are some addresses for the latest Steam Version of CoD 5. Try use them as a reference/guide so you can learn how to find them yourself.</p>
<p>CG_Init: 0x457B20</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CGS                   0x98B700</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CGS_Size              0x45C0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CG                    0x98FCE0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CG_Size               0xFDDC0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CG_Entities           0xA90930</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CG_EntitySize         0x2BC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CG_EntitiesSize       0xAF000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CG_ClientInfo         0xA76790</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CG_ClientInfoSize     0x55C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RefDef                CG + 0x56A8C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CL_ViewAngles          0xF6B314 <span class="comment">// ClientActive-&gt;ViewAngles</span></span></span><br></pre></td></tr></table></figure>


<div class="note primary">
            <p><strong>转载链接：</strong> <a href="https://guidedhacking.com/threads/call-of-duty-world-at-war-multiplayer-find-entity-list.17108/post-107520" target="_blank" rel="noopener">SystemX32@Guidedhacking.com</a></p>
          </div>]]></content>
      <categories>
        <category>不亦乐乎</category>
      </categories>
      <tags>
        <tag>游戏逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>C++算法题输入输出小技巧总结</title>
    <url>/2021/05/29/C-%E7%AE%97%E6%B3%95%E9%A2%98%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>OJ输入输出小技巧总结。</p>
<a id="more"></a>

<h3 id="输入一行没有空格的字符串"><a href="#输入一行没有空格的字符串" class="headerlink" title="输入一行没有空格的字符串"></a>输入一行没有空格的字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br></pre></td></tr></table></figure>

<h3 id="输入一行带有空格的字符串"><a href="#输入一行带有空格的字符串" class="headerlink" title="输入一行带有空格的字符串"></a>输入一行带有空格的字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::getline(<span class="built_in">cin</span>, s);</span><br></pre></td></tr></table></figure>

<h3 id="循环输入直到无数据源"><a href="#循环输入直到无数据源" class="headerlink" title="循环输入直到无数据源"></a>循环输入直到无数据源</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">cin</span> &gt;&gt; a; )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="stringstream-流式输入"><a href="#stringstream-流式输入" class="headerlink" title="stringstream 流式输入"></a>stringstream 流式输入</h3><p>很方便地进行字符串分割和字符串到其他类型的转换。</p>
<ul>
<li>输入：<br>1 2 3 4 5 6 7 8 9<br>34 56 85 19 0 88<br>995 668<br>10086</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> ar[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; getline(<span class="built_in">cin</span>, s);) &#123;</span><br><span class="line">        ss &lt;&lt; s;    <span class="comment">// 将s放入ss中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; ss &gt;&gt; t; i++) &#123;</span><br><span class="line">            ar[i] = t; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提高输入输出效率"><a href="#提高输入输出效率" class="headerlink" title="提高输入输出效率"></a>提高输入输出效率</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// start cin or cout</span></span><br></pre></td></tr></table></figure>
<p>对于大量数据输入，少量输出的情况，可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Class模式的OJ（如LeetCode）提高输入输出"><a href="#Class模式的OJ（如LeetCode）提高输入输出" class="headerlink" title="Class模式的OJ（如LeetCode）提高输入输出"></a>Class模式的OJ（如LeetCode）提高输入输出</h3><p>很简单，直接在class外写上如下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> io_sync_off=[]()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey" target="_blank" rel="noopener">牛客剑指Offer JZ35. 数组中的逆序对</a></p>
          </div>



<p>使用前：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">1000010</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int _mod = 1000000007;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line">        helper(<span class="number">0</span>, n - <span class="number">1</span>, data);</span><br><span class="line">        <span class="keyword">return</span> cnt % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        helper(lo, mid, data), helper(mid + <span class="number">1</span>, hi, data);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// backtrack       </span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// merge sort and compare</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= hi; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] &lt;= data[j]) tmp[idx] = data[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[idx] = data[j++];</span><br><span class="line">                cnt += mid - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid;) tmp[idx++] = data[i++];</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= hi;) tmp[idx++] = data[j++];</span><br><span class="line">        <span class="comment">// override</span></span><br><span class="line">        <span class="keyword">for</span> (idx = <span class="number">0</span>, i = lo; i &lt;= hi;) data[i++] = tmp[idx++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行时间： 113 ms</p>
</blockquote>
<p>使用后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> io_sync_off=[]()&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">1000010</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int _mod = 1000000007;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line">        helper(<span class="number">0</span>, n - <span class="number">1</span>, data);</span><br><span class="line">        <span class="keyword">return</span> cnt % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> mid = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        helper(lo, mid, data), helper(mid + <span class="number">1</span>, hi, data);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// backtrack       </span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// merge sort and compare</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= hi; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] &lt;= data[j]) tmp[idx] = data[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[idx] = data[j++];</span><br><span class="line">                cnt += mid - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= mid;) tmp[idx++] = data[i++];</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= hi;) tmp[idx++] = data[j++];</span><br><span class="line">        <span class="comment">// override</span></span><br><span class="line">        <span class="keyword">for</span> (idx = <span class="number">0</span>, i = lo; i &lt;= hi;) data[i++] = tmp[idx++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行时间： 79 ms</p>
</blockquote>
<p>舒服了。</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小公倍数lcm算法</title>
    <url>/2021/05/30/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0lcm%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>最小公倍数 = 两数乘积 / 最大公约数</p>
<a id="more"></a>

<p>因为 <strong>最小公倍数 = 两数乘积 / 最大公约数</strong>，<br>所以:</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>相关链接：</strong> <a href="https://eetoa.github.io/2020/03/27/求最大公约数（gcd）的一点心得" target="_blank" rel="noopener">求最大公约数（gcd）的一点心得</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
        <tag>最大公约数</tag>
        <tag>gcd</tag>
        <tag>最小公倍数</tag>
        <tag>lcm</tag>
      </tags>
  </entry>
  <entry>
    <title>在LeetCode刷题应尽量避免使用全局变量</title>
    <url>/2021/06/06/%E5%9C%A8LeetCode%E5%88%B7%E9%A2%98%E5%BA%94%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>会导致奇怪问题。</p>
<a id="more"></a>

<p>力扣的判题机在读取您的代码后，对每个测试用例，都会初始化一次类，但全局变量和类内静态变量需要您手动初始化。<br>但有时候即便手动初始化依然出错，所以应当尽量将变量初始化在类中。<br>但是，有时候初始化超大数组又不得不在堆上创建，所以这种事情还得根据实际情况自己权衡一下。</p>
<div class="note primary">
            <p><strong>相关链接：</strong> <a href="https://support.leetcode-cn.com/hc/kb/article/1194344/" target="_blank" rel="noopener">某些测试用例下，执行代码返回结果正确，但提交解答却出错了</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1091. 二进制矩阵中的最短路径</title>
    <url>/2021/06/06/LeetCode-1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>BFS模板题</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>n x n</code> 的二进制矩阵 <code>grid</code> 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 <code>-1</code> 。</p>
<p>二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，<code>(0, 0)</code>）到 右下角 单元格（即，<code>(n - 1, n - 1)</code>）的路径，该路径同时满足下述要求：</p>
<ul>
<li>路径途经的所有单元格都的值都是 0 。</li>
<li>路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。</li>
</ul>
<p><strong>畅通路径的长度</strong> 是该路径途经的单元格总数。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><img src="example1_1.png" alt="0x0"><br>输入：grid = [[0,1],[1,0]]<br>输出：2</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><img src="example2_1.png" alt="0x1"><br>输入：grid = [[0,0,0],[1,1,0],[1,1,0]]<br>输出：4</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：grid = [[1,0,0],[1,1,0],[1,1,0]]<br>输出：-1</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$n == grid.length$</li>
<li>$n == grid[i].length$</li>
<li>$1 &lt;= n &lt;= 100$</li>
<li>$grid[i][j]$ 为 $0$ 或 $1$</li>
</ul>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> dc[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">        pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; q[N];</span><br><span class="line">        <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> R = grid.<span class="built_in">size</span>(), C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] || !R) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        q[++tt] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, <span class="number">1</span>&#125;;</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh;)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; node = q[hh++];</span><br><span class="line">            <span class="comment">// determin if current node is end of grids</span></span><br><span class="line">            <span class="keyword">int</span> r = node.first.first, c = node.first.second, len = node.second;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; r &lt;&lt; "-" &lt;&lt; c &lt;&lt; "-" &lt;&lt; len &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (r == R - <span class="number">1</span> &amp;&amp; c == C - <span class="number">1</span>) <span class="keyword">return</span> len;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[i];</span><br><span class="line">                <span class="keyword">int</span> nec = c + dc[i];</span><br><span class="line">                <span class="keyword">int</span> nel = len + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// determin if in range</span></span><br><span class="line">                <span class="keyword">if</span> (ner &gt;= <span class="number">0</span> &amp;&amp; ner &lt; R &amp;&amp; nec &gt;= <span class="number">0</span> &amp;&amp; nec &lt; C &amp;&amp; !grid[ner][nec])    <span class="comment">// valid node</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; ner &lt;&lt; "-" &lt;&lt; nec &lt;&lt; "-" &lt;&lt; nel &lt;&lt; endl;</span></span><br><span class="line">                    q[++tt] = &#123;&#123;ner, nec&#125;, nel&#125;;</span><br><span class="line">                    grid[ner][nec] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<p>咱们来思考一个问题：<br>Q: 为什么首先到达终点的路径一定是最短的？<br>A: 对于基于某个点的下一层，路径长度相等。因为BFS借助队列实现，如果存在两条不同长度的路径，那么可以认为他们之间是「平行」的，可以在某点处分道扬镳，最短路径一定最先抵达终点。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">LeetCode 1091. 二进制矩阵中的最短路径</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
        <tag>Flood Fill</tag>
        <tag>洪水灌溉算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛常用STL和其他c++知识点总结</title>
    <url>/2021/06/11/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8STL%E5%92%8C%E5%85%B6%E4%BB%96c-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>都是常用的。</p>
<a id="more"></a>

<h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p>对数组<code>vector&lt;int&gt; a</code>排序：<br><code>#include &lt;algorithm&gt;</code></p>
<ul>
<li><p>升序<br><code>sort(a.begin(), a.end());</code><br><code>sort(a.begin(), a.end(), less&lt;int&gt;());</code></p>
</li>
<li><p>降序<br><code>sort(a.begin(), a.end(), greater&lt;int&gt;());</code><br><code>sort(a.rbegin(), a.rend());</code></p>
</li>
</ul>
<h4 id="字符串转数值类型"><a href="#字符串转数值类型" class="headerlink" title="字符串转数值类型"></a>字符串转数值类型</h4><p><code>#include &lt;string&gt;</code><br><strong>std::atoi</strong><br>转换 const char* 为一个 int 类型整数，超出 int 类型范围时，返回边界值。</p>
<p><strong>std::atol</strong><br>转换 const char* 为一个 long 类型整数，超出 long 类型范围时，返回边界值。</p>
<p><strong>std::atoll</strong><br>转换 const char* 为一个 long long 类型整数，超出 long long 类型范围时，返回边界值。</p>
<p><strong>std::stoi</strong><br>转换 std::string 为一个 int 类型整数，超出 int 类型范围时报错。</p>
<p><strong>std::stol</strong><br>转换 std::string 为一个 long 类型整数，超出 long 类型范围时报错。</p>
<p><strong>std::stoll</strong><br>转换 std::string 为一个 long long 类型整数，超出 long long 类型范围时报错。</p>
<h3 id="其他C-知识点"><a href="#其他C-知识点" class="headerlink" title="其他C++知识点"></a>其他C++知识点</h3><h4 id="0x0-输出指定位的小数点或有效数字"><a href="#0x0-输出指定位的小数点或有效数字" class="headerlink" title="0x0 输出指定位的小数点或有效数字"></a>0x0 输出指定位的小数点或有效数字</h4><p><strong>举例：</strong><br><code>float a = 233.233;</code></p>
<ul>
<li><p>输出保留2位小数:<br><code>inlcude &lt;iomanip&gt;</code><br><code>cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; a;</code><br>四舍五入输出<code>233.23</code><br>其中，<code>setiosflags(ios::fixed)</code> 为设置浮点数以固定的小数位数显示。<br><code>setprecision(2)</code> 为设置精度为2.</p>
</li>
<li><p>输出保留5位有效数字<br><code>cout &lt;&lt; setprecision(5) &lt;&lt; a;</code><br>四舍五入输出<code>233.23</code></p>
</li>
</ul>
<div class="note primary">
            <p><strong>参考链接：</strong> <a href="https://www.cnblogs.com/ysx1997/p/7753579.html" target="_blank" rel="noopener">C++ 如何保留两位小数和有效位数</a></p>
          </div>

<div class="note primary">
            <p><strong>参考链接：</strong> <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/10705252.html" target="_blank" rel="noopener">C++ 标准库之 iomanip 、操作符 ios::fixed 以及 setprecision 使用的惨痛教训经验总结</a></p>
          </div>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>算法相关</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>【AcWing算法基础】第五讲-动态规划-背包问题 AcWing 2. 01背包问题</title>
    <url>/2021/06/18/%E3%80%90AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%91%E7%AC%AC%E4%BA%94%E8%AE%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-AcWing-2-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>01背包模板题，非常纯粹。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p>
<p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p>
<p><strong>输入格式</strong><br>第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示最大价值。</p>
<p><strong>数据范围</strong><br>$0 &lt; N,V ≤ 1000$<br>$0 &lt; v_i,w_i ≤ 1000$</p>
<p><strong>输入样例</strong></p>
<blockquote>
<p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>8</p>
</blockquote>
<hr>
<p>设 <code>i</code> 为前 <code>i</code> 件物品，<code>j</code> 为背包的最大容量。<br>设 <code>v[i]</code> 为第 <code>i</code> 件物品的体积，<code>w[i]</code> 为第 <code>i</code> 件物品的价值。</p>
<h3 id="二维dp数组"><a href="#二维dp数组" class="headerlink" title="二维dp数组"></a>二维dp数组</h3><p>题目要求前 $N$ 个物品，放入容量为 $V$ 的背包中，所得到的最大价值。<br>由此可以定义一个二维dp数组 <code>f[i][j]</code> 用以表示状态。</p>
<p><strong>状态集合：</strong> 前 <code>i</code> 个物品放入容量为 <code>j</code> 的背包中的所有情况所构成的集合。<br>其中 $1 &lt;= i &lt;= N, 1 &lt;= j &lt;= V$，即：<br>对于前 $1$ 件到前 $N$ 件中的每种情况，都分别对应背包容量从 $1$ 到 $V$ 的每种情况。所有情况构成了状态集合。</p>
<p><strong>状态集合元素属性：</strong> 对于集合中的每个元素，将产生的最大价值定义为它的属性放在二维dp数组中。即：<br><code>f[i][j]</code> 表示前 <code>i</code> 个物品放入容量为 <code>j</code> 的背包中，所对应的最大价值。</p>
<p><strong>状态计算：</strong> 现在思考如何计算 <code>f[i][j]</code> 的值。<br>对于前 <code>i</code> 件物品的第 <code>i</code> 件物品，只会有 「可放入」背包和「不可放入」背包两种情况。现在考虑哪些情况可放入哪些不可放入。</p>
<ul>
<li>不可放入第 <code>i</code> 件物品：很容易想到，当尝试放入第 <code>i</code> 件物品时，遇到背包容量限制的时候，必然不可放入。即：<br>当第 <code>i</code> 件的体积超出背包总体积时，必然不可放入（<code>j &lt; v[i]</code>）。<br>那么， <code>f[i][j]</code> 表示前 <code>i - 1</code> 件物品放入容量为 <code>j</code> 的背包中的最大价值。</li>
<li>可放入第 <code>i</code> 件物品：反之， <code>j &gt;= v[i]</code> ，即 <code>j - v[i] &gt;= 0</code> ，供前 <code>i - 1</code> 件物品放入的背包容量是大于零的。同时，注意，第 <code>i</code> 件可放可不放，没有条件限制。<br>那么， <code>f[i][j]</code> 表示前 <code>i - 1</code> 件物品放入容量为 <code>j - v[i]</code> 的背包中的最大价值和<br>第 <code>i</code> 件物品放入容量为 <code>j</code> 的背包中的最大价值，二者取较大者。</li>
</ul>
<p><strong>状态转移方程：</strong> 根据上述状态计算方式，可以得出状态转移方程分别为：</p>
<ul>
<li><code>f[i][j] = f[i - 1][j]</code></li>
<li><code>f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])</code></li>
</ul>
<p>其中 <code>v[i]</code> 和 <code>w[i]</code> 分别为第 <code>i</code>件物品的体积和价值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mxv;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mxv;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// f[i][j]: 前 i 件放在最大容量为j的包里，最大价值</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(mxv + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造二维dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 对于前 1 ~ n 件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= mxv; j++) &#123;    <span class="comment">// 从前 i 件放在最大容量为1的包里，到前 i 件放在最大容量为 mxv 的包里</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) &#123;   <span class="comment">// j - v[i] &gt;= 0，前 i - 1件物品放入容量为 j - v[i]的背包中，同时第i件可放可不放。</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">// j &lt; v[i]背包全部容量都不够第i件物品的体积，必然不可放入</span></span><br><span class="line">                f[i][j] = f[i  - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二维数组的构造过程也是逐步求解过程，数组最后一个值f[n][mxv]即为所求：对于前 n 件物品，放在容量为mxv的背包中的最大价值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][mxv] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一维dp数组的空间优化"><a href="#一维dp数组的空间优化" class="headerlink" title="一维dp数组的空间优化"></a>一维dp数组的空间优化</h3><p>注意到二维dp的状态转移方程：</p>
<ul>
<li><code>f[i][j] = f[i - 1][j]</code></li>
<li><code>f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])</code></li>
</ul>
<p>不难发现，前 <code>i</code> 件物品的最大价值只与前 <code>i - 1</code> 件物品有关。对应在二维数组中，第 <code>i</code> 行的计算只与第 <code>i - 1</code> 行有关。<br>不妨维护一个一维数组放入前 <code>i - 1</code> 件物品在不同容量背包下的最大价值。计算前 <code>i</code> 件物品的时候，可以直接使用，并完成更新为前 <code>i + 1</code> 件物品的计算做准备。</p>
<p>在一维dp中，考虑前 <code>i</code> 个物品在不同体积背包下的最大价值。<br>可定义一维数组：<code>f[j]</code> $(1 &lt;= j &lt;= V)$</p>
<p><strong>状态转移方程：</strong><br>下面我们尝试将二维状态转移方程压缩至一维：<br><code>f[i][j] = f[i - 1][j]</code> 可以直接等价于 <code>f[j] = f[j]</code><br><code>f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])</code> 则可以等价于：<br><code>f[j] = max(f[j], f[j - v[i]] + w[i])</code></p>
<p>对于前 <code>i</code> 件物品，在计算 <code>f[j]</code> 的时候，注意 <code>f[j - v[i]]</code> 的来源：<br>首先应该明确 <code>f[j - v[i]]</code> 来自于前 <code>i - 1</code> 件物品的计算，即上一层循环得到的一位dp数组;<br>其次，<code>j</code> 大于 <code>j - v[i]</code> ，因为 <code>j - (j - v[i]) &gt; 0</code> ;<br>那么，为了计算前 <code>i</code> 件物品的最大价值，我们在更新当前的一维dp数组的时候需要使用到上一次计算前 <code>i - 1</code> 件物品的dp数组。<strong>其中，使用到的 <code>f[j - v[i]]</code> 在 <code>f[j]</code> 前面。</strong><br>那么，如果我们计算了 <code>f[j]</code> 的值，并且更新了 <code>f[j]</code> ，那么 <strong>随着 <code>j</code> 的增大，需要使用到 <code>f[j]</code> 的时候，上一层的信息已经被本层之前的计算覆盖了。</strong><br>为了解决更新第 <code>i</code> 次dp数组而不影响使用第 <code>i - 1</code> 次数组信息的问题，我们可以从大到小遍历体积：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mxv;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mxv;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(mxv + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 对于前 1 ~ n 件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = mxv; j &gt;= <span class="number">1</span>; j--) &#123;    <span class="comment">// 从前 i 件放在最大容量为mxv的包里，到前 i 件放在最大容量为 1 的包里</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i])</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                f[j] = f[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[mxv] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，不难看出只有当 <code>j &gt;= v[i]</code> 时dp数组会更新，所以：<br><code>for (int j = mxv; j &gt;= 1; j--)</code> 可以进一步优化成<br><code>for (int j = mxv; j &gt;= v[i]; j--)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mxv;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mxv;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(mxv + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 对于前 1 ~ n 件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = mxv; j &gt;= v[i]; j--) &#123;     <span class="comment">// 从前 i 件放在最大容量为mxv的包里，到前 i 件放在最大容量为 1 的包里</span></span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[mxv] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://www.acwing.com/activity/content/problem/content/997/1/" target="_blank" rel="noopener">AcWing 2. 01背包问题</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>AcWing</category>
        <category>算法基础课</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>AcWing</tag>
        <tag>背包</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode周赛246】B LeetCode 5789. 你完成的完整对局数</title>
    <url>/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91B-LeetCode-5789-%E4%BD%A0%E5%AE%8C%E6%88%90%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AF%B9%E5%B1%80%E6%95%B0/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道关于时间的题目。</p>
<a id="more"></a>


<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一款新的在线电子游戏在近期发布，在该电子游戏中，以 <strong>刻钟</strong> 为周期规划若干时长为 <strong>15 分钟</strong> 的游戏对局。这意味着，在 <code>HH:00</code>、<code>HH:15</code>、<code>HH:30</code> 和 <code>HH:45</code> ，将会开始一个新的对局，其中 <code>HH</code> 用一个从 <code>00</code> 到 <code>23</code> 的整数表示。游戏中使用 <code>24</code> 小时制的时钟 ，所以一天中最早的时间是 <code>00:00</code> ，最晚的时间是 <code>23:59</code> 。</p>
<p>给你两个字符串 <code>startTime</code> 和 <code>finishTime</code> ，均符合 <code>&quot;HH:MM&quot;</code> 格式，分别表示你 <strong>进入</strong> 和 <strong>退出</strong> 游戏的确切时间，请计算在整个游戏会话期间，你完成的 <strong>完整对局的对局数</strong> 。</p>
<ul>
<li>例如，如果 <code>startTime = &quot;05:20&quot;</code> 且 <code>finishTime = &quot;05:59&quot;</code> ，这意味着你仅仅完成从 <code>05:30</code> 到 <code>05:45</code> 这一个完整对局。而你没有完成从 <code>05:15</code> 到 <code>05:30</code> 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 <code>05:45</code> 到 <code>06:00</code> 的完整对局，因为你是在对局结束前退出的游戏。</li>
</ul>
<p>如果 <code>finishTime</code> <strong>早于</strong> <code>startTime</code> ，这表示你玩了个通宵（也就是从 <code>startTime</code> 到午夜，再从午夜到 <code>finishTime</code> ）。</p>
<p>假设你是从 <code>startTime</code> 进入游戏，并在 <code>finishTime</code> 退出游戏，请计算并返回你完成的 <strong>完整对局的对局数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：startTime = “12:01”, finishTime = “12:44”<br>输出：1<br>解释：你完成了从 12:15 到 12:30 的一个完整对局。<br>你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。<br>你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<p>输入：startTime = “20:00”, finishTime = “06:00”<br>输出：40<br>解释：你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。<br>16 + 24 = 40</p>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：startTime = “00:00”, finishTime = “23:59”<br>输出：95<br>解释：除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>startTime</code> 和 <code>finishTime</code> 的格式为 <code>HH:MM</code></li>
<li>$00 &lt;= HH &lt;= 23$</li>
<li>$00 &lt;= MM &lt;= 59$</li>
<li><code>startTime</code> 和 <code>finishTime</code> 不相等</li>
</ul>
<hr>
<h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>将时间转换为分钟数表示，如果结束时间小于开始时间，则将结束时间加上24小时。<br>问题就变成了求开始分钟数后的第一个15的倍数，以及结束时间分钟数前一个15的倍数。再求二者之间的长度共是15的倍数。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ctoi</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfRounds</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = (ctoi(s[<span class="number">0</span>]) * <span class="number">10</span> + ctoi(s[<span class="number">1</span>])) * <span class="number">60</span> + ctoi(s[<span class="number">3</span>]) * <span class="number">10</span> + ctoi(s[<span class="number">4</span>]);</span><br><span class="line">        <span class="keyword">int</span> b = (ctoi(f[<span class="number">0</span>]) * <span class="number">10</span> + ctoi(f[<span class="number">1</span>])) * <span class="number">60</span> + ctoi(f[<span class="number">3</span>]) * <span class="number">10</span> + ctoi(f[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) b += <span class="number">24</span> * <span class="number">60</span>;</span><br><span class="line">        <span class="comment">// 找到a右边第一个15的倍数和b左边第一个15的倍数</span></span><br><span class="line">        <span class="keyword">int</span> l = (<span class="keyword">int</span>)((a + <span class="number">14</span>) / <span class="number">15</span>) * <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">int</span> r = (<span class="keyword">int</span>)(b / <span class="number">15</span>) * <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; l)                  <span class="comment">// 当r 和 l之间至少有一个完整对局时或者二者不构成一个完整对局且分别某个对局时间点左右</span></span><br><span class="line">            <span class="keyword">return</span> (r - l) / <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">else</span>                       <span class="comment">// 当r和l同在一个完整对局区间内，会出现r &lt; l的情况</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<p>注意到c++是向零取整，<code>int c = b / a</code>;<br>如果想计算 <code>b / a</code> 向上取整，可以 <code>int c = (b + a - 1) / a</code>.<br>因为 <code>c = (b + a) / a</code> 刚好等于 <code>b / a向下取整 + 1</code>.</p>
<h3 id="优化：用sscanf将字符串分割为两个数字"><a href="#优化：用sscanf将字符串分割为两个数字" class="headerlink" title="优化：用sscanf将字符串分割为两个数字"></a>优化：用sscanf将字符串分割为两个数字</h3><div class="tabs" id="g_tab1"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab1-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab1-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Author: yxc@acwing.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h, m;</span><br><span class="line">        <span class="built_in">sscanf</span>(s.c_str(), <span class="string">"%d:%d"</span>, &amp;h, &amp;m);</span><br><span class="line">        <span class="keyword">return</span> h * <span class="number">60</span> + m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfRounds</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">get</span>(s), y = <span class="built_in">get</span>(f);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) y += <span class="number">24</span> * <span class="number">60</span>;</span><br><span class="line">        x = (x + <span class="number">14</span>) / <span class="number">15</span>, y /= <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; x)</span><br><span class="line">            <span class="keyword">return</span> y - x;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/contest/weekly-contest-246/problems/the-number-of-full-rounds-you-have-played/" target="_blank" rel="noopener">LeetCode 5789. 你完成的完整对局数</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数学</tag>
        <tag>字符串</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode周赛246】A LeetCode 5788. 字符串中的最大奇数</title>
    <url>/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91A-LeetCode-5788-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%A5%87%E6%95%B0/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>寻找字符串中的最大奇数。</p>
<a id="more"></a>


<p>给你一个字符串 <code>num</code> ，表示一个大整数。请你在字符串 <code>num</code> 的所有 <strong>非空子字符串</strong> 中找出 <strong>值最大的奇数</strong> ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>子字符串</strong> 是字符串中的一个连续的字符序列。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：num = “52”<br>输出：”5”<br>解释：非空子字符串仅有 “5”、”2” 和 “52” 。”5” 是其中唯一的奇数。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：num = “4206”<br>输出：””<br>解释：在 “4206” 中不存在奇数。</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：num = “35427”<br>输出：”35427”<br>解释：”35427” 本身就是一个奇数。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= num.length &lt;= 10^5$</li>
<li>$num$ 仅由数字组成且不含前导零</li>
</ul>
<hr>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>奇数最后一个数字一定是奇数，那么就从右向左找到第一个奇数数字，那么以该字符结尾的原字符串前缀就是最大奇数子串。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestOddNumber</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((num.<span class="built_in">end</span>()[<span class="number">-1</span>]) &amp; <span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> len = num.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num[i]) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> num.substr(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<p>注意在判断数字字符的奇偶性时，可以直接判断。因为数字字符和对应的数字具有相同奇偶性。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/largest-odd-number-in-string/" target="_blank" rel="noopener">LeetCode 5788. 字符串中的最大奇数</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题由给定数据范围反推算法复杂度及算法内容</title>
    <url>/2021/06/18/%E7%AE%97%E6%B3%95%E9%A2%98%E7%94%B1%E7%BB%99%E5%AE%9A%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>可以从数据范围分析出大致的最高限度的复杂度要求</p>
<a id="more"></a>

<p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 $10^7∼10^8$ 为最佳。</p>
<p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p>
<ul>
<li>$n≤30$, 指数级别, dfs+剪枝，状态压缩dp</li>
<li>$n≤100 =&gt; O(n3)$，floyd，dp，高斯消元</li>
<li>$n≤1000 =&gt; O(n2)，O(n^2logn)$，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</li>
<li>$n≤10000 =&gt; O(n \sqrt n)$，块状链表、分块、莫队</li>
<li>$n≤100000 =&gt; O(nlogn)$ =&gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分</li>
<li>$n≤1000000 =&gt; O(n)$, 以及常数较小的 $O(nlogn)$ 算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 $O(nlogn)$ 的做法：sort、树状数组、heap、dijkstra、spfa</li>
<li>$n≤10000000 =&gt; O(n)$，双指针扫描、kmp、AC自动机、线性筛素数</li>
<li>$n≤10^9 =&gt; O(\sqrt n)$，判断质数</li>
<li>$n≤10^{18} =&gt; O(logn)$，最大公约数，快速幂</li>
<li>$n≤10^{1000} =&gt; O((logn)^2)$，高精度加减乘除</li>
<li>$n≤10^{100000} =&gt; O(logk×loglogk)$，k表示位数$O(logk×loglogk)$，k表示位数，高精度加减、FFT/NTT</li>
</ul>
<div class="note primary">
            <p><strong>转载链接：</strong> <a href="https://www.acwing.com/blog/content/32/" target="_blank" rel="noopener">由数据范围反推算法复杂度以及算法内容</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>HeXo文章分类管理</title>
    <url>/2021/06/21/HeXo%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>简单记录下HeXo博客的文章分类管理。</p>
<a id="more"></a>


<h3 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h3><h4 id="单级分类"><a href="#单级分类" class="headerlink" title="单级分类"></a>单级分类</h4><p>对于一篇文章，在顶部的位置加上：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">    - </span>A</span><br></pre></td></tr></table></figure>
<p>那么这篇文章就属于分类 <code>A</code>.</p>
<h4 id="多级分类"><a href="#多级分类" class="headerlink" title="多级分类"></a>多级分类</h4><p>如果再加上 <code>- B</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">    - </span>A</span><br><span class="line"><span class="bullet">    - </span>B</span><br></pre></td></tr></table></figure>
<p>那么 <code>B</code> 是 <code>A</code> 的子类，文章属于 <code>A</code> 分类下的 <code>B</code> 分类。以此类推。</p>
<p>同样的，我们可以以一个列表形式展现文章的多级分类：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">    - </span>[A, B]</span><br></pre></td></tr></table></figure>

<h4 id="共存的多级分类"><a href="#共存的多级分类" class="headerlink" title="共存的多级分类"></a>共存的多级分类</h4><p>那么，如果一篇文章既属于A又属于D，我们可以以多个列表同时分类：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">    - </span>[A, B, C]</span><br><span class="line"><span class="bullet">    - </span>[D, E, F]</span><br></pre></td></tr></table></figure>
<p>文章既属于A类下的B类下的C类，又属于D分类下的E分类下的F分类。</p>
<div class="note primary">
            <p><strong>相关链接：</strong> <a href="https://hexo.io/docs/front-matter.html" target="_blank" rel="noopener">HeXo Doc</a></p>
          </div>
]]></content>
      <categories>
        <category>不亦乐乎</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>HeXo</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1249. 移除无效的括号</title>
    <url>/2021/06/22/LeetCode-1249-%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>华为面试题，时间不够没写出来，面试结束补上了，还是我太菜了。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由 <code>&#39;(&#39;</code> 、<code>&#39;)&#39;</code> 和小写字母组成的字符串 s。</p>
<p>你需要从字符串中删除最少数目的 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code> （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p>
<p>请返回任意一个合法字符串。</p>
<p>有效「括号字符串」应当符合以下 任意一条 要求：</p>
<ul>
<li>空字符串或只包含小写字母的字符串</li>
<li>可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」</li>
<li>可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：s = “lee(t(c)o)de)”<br>输出：”lee(t(c)o)de”<br>解释：”lee(t(co)de)” , “lee(t(c)ode)” 也是一个可行答案。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：s = “a)b(c)d”<br>输出：”ab(c)d”</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：s = “))((“<br>输出：””<br>解释：空字符串也是有效的</p>
</blockquote>
<p><strong>示例 4：</strong></p>
<p>输入：s = “(a(b(c)d)”<br>输出：”a(b(c)d)”</p>
<p><strong>提示：</strong></p>
<ul>
<li>$ 1 &lt;= s.length &lt;= 10^5$</li>
<li><code>s[i]</code> 可能是 <code>&#39;(&#39;</code> 、<code>&#39;)&#39;</code> 或英文小写字母</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>维护一个栈，将所有有效括号对去除，剩下的就是字符串中多余的目标括号。为了将字符串中多余的括号去除，需要在栈中记录括号对应原字符串下标。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; stk[N];</span><br><span class="line">    <span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minRemoveToMakeValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'('</span>) stk[++tt] = &#123;c, i&#125;;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!tt || stk[tt].first != <span class="string">'('</span>) stk[++tt] = &#123;c, i&#125;;</span><br><span class="line">                    <span class="keyword">else</span> --tt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!tt) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">if</span> (tt) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tt &amp;&amp; i == stk[tt].second) &#123;</span><br><span class="line">                    --tt;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> res += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/" target="_blank" rel="noopener">LeetCode 1249. 移除无效的括号</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>栈</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode周赛246】C LeetCode 5791. 统计子岛屿</title>
    <url>/2021/06/20/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91C-LeetCode-5791-%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>洪水灌溉算法经典题型。</p>
<a id="more"></a>


<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个 <code>m x n</code> 的二进制矩阵 <code>grid1</code> 和 <code>grid2</code> ，它们只包含 <code>0</code> （表示水域）和 <code>1</code> （表示陆地）。一个 <strong>岛屿</strong> 是由 <strong>四个方向</strong> （水平或者竖直）上相邻的 <code>1</code> 组成的区域。任何矩阵以外的区域都视为水域。</p>
<p>如果 <code>grid2</code> 的一个岛屿，被 <code>grid1</code> 的一个岛屿 <strong>完全</strong> 包含，也就是说 <code>grid2</code> 中该岛屿的每一个格子都被 <code>grid1</code> 中同一个岛屿完全包含，那么我们称 <code>grid2</code> 中的这个岛屿为 <strong>子岛屿</strong> 。</p>
<p>请你返回 <code>grid2</code> 中 <strong>子岛屿</strong> 的 <strong>数目</strong> 。</p>
<p><strong>示例 1：</strong><br><img src="test1.png" alt="0x0"></p>
<blockquote>
<p>输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]<br>输出：3<br>解释：如上图所示，左边为 grid1 ，右边为 grid2 。<br>grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。</p>
</blockquote>
<p><strong>示例 2：</strong><br><img src="testcasex2.png" alt="0x1"></p>
<blockquote>
<p>输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]<br>输出：2<br>解释：如上图所示，左边为 grid1 ，右边为 grid2 。<br>grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid1.length == grid2.length</code></li>
<li><code>n == grid1[i].length == grid2[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 500</code></li>
<li><code>grid1[i][j]</code> 和 <code>grid2[i][j]</code> 都要么是 <code>0</code> 要么是 <code>1</code> 。</li>
</ul>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>在 <code>grid2</code> 中找到所有岛屿，并且在寻找的过程中判断每一个块是否和 <code>grid1</code> 中对应块相等，不等必然不是子岛屿。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid2, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">bool</span> &amp;issub)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid2[r][c] != grid1[r][c]) issub = <span class="literal">false</span>;</span><br><span class="line">        grid2[r][c] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ner = r + dr[i], nec = c + dc[i];</span><br><span class="line">            <span class="keyword">if</span> (ner &lt; <span class="number">0</span> || ner &gt; R - <span class="number">1</span> || nec &lt; <span class="number">0</span> || nec &gt; C - <span class="number">1</span> || !grid2[ner][nec] || grid2[ner][nec] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(grid1, grid2, ner, nec, issub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;R = grid2.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;C = grid2[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid2[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> issub = <span class="literal">true</span>;</span><br><span class="line">                    dfs(grid1, grid2, i, j, issub);</span><br><span class="line">                    <span class="keyword">if</span> (issub) res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<p>本题是 <a href="https://eetoa.github.io/2020/04/21/LeetCode-200-岛屿数量" target="_blank" rel="noopener">岛屿数量</a> 的升级版。</p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/count-sub-islands/" target="_blank" rel="noopener">5791. 统计子岛屿</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>Flood Fill</tag>
        <tag>洪水灌溉算法</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1162. 地图分析</title>
    <url>/2021/06/23/LeetCode-1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>一道经典的多源BFS题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你现在手里有一份大小为 $N*N$ 的 网格 $grid$，上面的每个 单元格 都用 $0$ 和 $1$ 标记好了。其中 $0$ 代表海洋，$1$ 代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。</p>
<p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：$(x0, y0)$ 和 $(x1, y1)$ 这两个单元格之间的距离是 $|x0 - x1| + |y0 - y1|$ 。</p>
<p>如果网格上只有陆地或者海洋，请返回 $-1$。</p>
<p><strong>示例 1：</strong></p>
<p><img src="1.jpeg" alt="0x0"></p>
<blockquote>
<p>输入：[[1,0,1],[0,0,0],[1,0,1]]<br>输出：2<br>解释：<br>海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<p><img src="2.jpeg" alt="0x1"></p>
<blockquote>
<p>输入：[[1,0,0],[0,0,0],[0,0,0]]<br>输出：4<br>解释：<br>海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ol>
<li>$1 &lt;= grid.length == grid[0].length &lt;= 100$</li>
<li>$grid[i][j]$ 不是 $0$ 就是 $1$</li>
</ol>
<hr>
<h3 id="多源BFS"><a href="#多源BFS" class="headerlink" title="多源BFS"></a>多源BFS</h3><p>遍历数组，将所有岛屿入队，每次根据当前结点计算出下一个海洋结点，就将海洋结点值设为父结点的值加一。<br>于是，就像水中的多点扰动水面一样，最终涟漪交汇的地方就是最远海洋结点。</p>
<div class="tabs" id="g_tab"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-23 18:47:28</span></span><br><span class="line"><span class="comment"> * @Author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []() &#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; q[N];</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;R = grid.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) q[++tt] = &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// determine special situation</span></span><br><span class="line">        <span class="keyword">int</span> qsize = tt - hh + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (qsize == R * C || !qsize) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh; ++hh) &#123;                         <span class="comment">// pop head</span></span><br><span class="line">            <span class="keyword">int</span> r = q[hh].first, c = q[hh].second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ner = r + dr[i], nec = c + dc[i];</span><br><span class="line">                <span class="keyword">if</span> (ner &lt; <span class="number">0</span> || ner &gt; R - <span class="number">1</span> || nec &lt; <span class="number">0</span> || nec &gt; C - <span class="number">1</span> || grid[ner][nec]) <span class="keyword">continue</span>;</span><br><span class="line">                grid[ner][nec] = grid[r][c] + <span class="number">1</span>;</span><br><span class="line">                q[++tt] = &#123;ner, nec&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, grid[i][j]);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; grid[i][j] &lt;&lt; ' ';</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>



<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">LeetCode 1162. 地图分析</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 149. 直线上最多的点数</title>
    <url>/2021/06/24/LeetCode-149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>主要是考虑从哪个角度入手暴搜。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。</p>
<p><strong>示例1:</strong></p>
<p><img src="0.jpg" alt="0x0"></p>
<blockquote>
<p>输入：points = [[1,1],[2,2],[3,3]]<br>输出：3</p>
</blockquote>
<p><strong>示例2:</strong></p>
<p><img src="1.jpg" alt="0x1"></p>
<blockquote>
<p>输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<br>输出：4</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= points.length &lt;= 300$</li>
<li>$points[i].length == 2$</li>
<li>$-10^4 &lt;= xi, yi &lt;= 10^4$</li>
<li>$points$ 中的所有点 <strong>互不相同</strong></li>
</ul>
<hr>
<h3 id="暴搜"><a href="#暴搜" class="headerlink" title="暴搜"></a>暴搜</h3><p>对于某一个点，把它看成中心点，平面上会有无穷多条直线经过它。对于一个中心点，剩余点的每个点都和它构成一条直线。我们统计剩余点和中心点构成直线的数量。</p>
<p>注意剩余点和中心点垂直的情况，此时可以用一个额外的变量来统计和中心点垂直的点的数量。<br>注意相同点的情况，即剩余点和中心点重合，虽然题目条件说明所有点互不相同，但是这里依旧考虑这一情况。<br>注意本题精度要求较高，计算斜率使用 long double 变量。<br>如果精度要求更高，可以考虑用分数来存放斜率，这时候需要求分子分母最大公约数。</p>
<div class="tabs" id="g_tab"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-24 17:54:50</span></span><br><span class="line"><span class="comment"> * @Author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []()&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> center = <span class="number">0</span>, vertical = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">double</span> ratio = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (points[j] == points[i]) center++;   <span class="comment">// 至少包含一个中心点 points[i]</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (points[j][<span class="number">0</span>] == points[i][<span class="number">0</span>]) vertical++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ratio = (<span class="keyword">long</span> <span class="keyword">double</span>)(points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>]) / (points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]);</span><br><span class="line">                    cnt[ratio]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 垂线和斜线数量取较大者</span></span><br><span class="line">            <span class="keyword">int</span> mxratio = vertical;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [key, value] : cnt) &#123;</span><br><span class="line">                mxratio = <span class="built_in">max</span>(mxratio, value);</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, mxratio + center);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">LeetCode 149. 直线上最多的点数</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 909. 蛇梯棋</title>
    <url>/2021/06/27/LeetCode-909-%E8%9B%87%E6%A2%AF%E6%A3%8B/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>BFS魔改题。</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>$N \times N$ 的棋盘 $board$ 上，按从 $1$ 到 $N \times N$ 的数字给方格编号，编号 <strong>从左下角开始</strong>，每一行交替方向。</p>
<p>例如，一块 $6 \times 6$ 大小的棋盘，编号如下：</p>
<p><img src="0.png" alt="0x0"></p>
<p>$r$ 行 $c$ 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 $board[r][c] != -1$，那个蛇或梯子的目的地将会是 $board[r][c]$。</p>
<p>玩家从棋盘上的方格 $1$ （总是在最后一行、第一列）开始出发。</p>
<p>每一回合，玩家需要从当前方格 $x$ 开始出发，按下述要求前进：</p>
<ul>
<li><p>选定目标方格：选择从编号 $x+1$，$x+2$，$x+3$，$x+4$，$x+5$，或者 $x+6$ 的方格中选出一个目标方格 $s$ ，目标方格的编号 $&lt;= N \times N$。</p>
<ul>
<li>该选择模拟了掷骰子的情景，无论棋盘大小如何，你的目的地范围也只能处于区间 $[x+1, x+6]$ 之间。</li>
</ul>
</li>
<li><p>传送玩家：如果目标方格 $S$ 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 $S$。<br>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。</p>
</li>
</ul>
<p>返回达到方格 $N \times N$ 所需的最少移动次数，如果不可能，则返回 $-1$。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>[[-1,-1,-1,-1,-1,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,35,-1,-1,13,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,15,-1,-1,-1,-1]]<br><strong>输出：</strong> 4<br><strong>解释：</strong><br>首先，从方格 1 [第 5 行，第 0 列] 开始。<br>你决定移动到方格 2，并必须爬过梯子移动到到方格 15。<br>然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过蛇到方格 13。<br>然后你决定移动到方格 14，且必须通过梯子移动到方格 35。<br>然后你决定移动到方格 36, 游戏结束。<br>可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$2 &lt;= board.length = board[0].length &lt;= 20$</li>
<li>$board[i][j]$ 介于 $1$ 和 $N \times N$ 之间或者等于 $-1$。</li>
<li>编号为 $1$ 的方格上没有蛇或梯子。</li>
<li>编号为 $N \times N$ 的方格上没有蛇或梯子。</li>
</ul>
<hr>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>这道题很容易看出来是一道利用BFS找到最短路径步数的题目。和一般的BFS题不同之处在于引入了「传送门」的概念，以及搜索方向是蛇形的。<br>引入「传送门」的概念并不妨碍最先BFS到终点的路径一定最短这一BFS特性。<br>重要的是，我们还是要标记出已经到达的位置，以避免重复入队。<br>把棋盘上非 $-1$ 的数字看成一个位置指针，也不必考虑到循环指针的问题。因为只要做好重复标记，可以避免所有循环指针入队。</p>
<p>我和yxc解法的区别主要在于路径长度记录和重复标记方法。<br>对于路径长度记录，我是将路径长度和路径点坐标放在一起入队，每次搜索下一个点，将路径 $+1$；而yxc是维护一个和原棋盘大小相同的每个值初始化为无穷大的 <code>dist</code> 二维数组，将起点设为 $0$，每搜索到一个点，如果是新的点，就在当前点的距离上 $+1$。</p>
<p>对于重复标记，我是将已入队的位置在原棋盘上更改为一个特定值 <code>0x3f3f3f3f</code>；而yxc的解法利用记录路径长度的二维数组，如果搜索到的新点对应值是无穷大，说明确实是一个新的点，如果不是，则之前已被搜过。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li><li class="tab"><a href="#g_tab0-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2021-6-27 18:12:16</span></span><br><span class="line"><span class="comment"> * author: etoa</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">shutdown</span> = []() &#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)-&gt;sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">404</span>;</span><br><span class="line">    pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; q[N];</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;R = board.<span class="built_in">size</span>(), <span class="keyword">this</span>-&gt;C = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">grid</span><span class="params">(R, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(C, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = R - <span class="number">1</span>; r &gt;= <span class="number">0</span>; r--) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ((-r + R) &amp; <span class="number">1</span>) ? <span class="number">0</span> : C - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; C; last++) &#123;</span><br><span class="line">                grid[r][c] = last + <span class="number">1</span>;</span><br><span class="line">                heap[last + <span class="number">1</span>] = &#123;r, c&#125;;</span><br><span class="line">                <span class="keyword">if</span> ((-r + R) &amp; <span class="number">1</span>) c++;</span><br><span class="line">                <span class="keyword">else</span> c--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = R * C;</span><br><span class="line">        q[++tt] = &#123;&#123;R - <span class="number">1</span>, <span class="number">0</span>&#125;, <span class="number">0</span>&#125;;</span><br><span class="line">        board[R - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (; tt &gt;= hh; hh++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = q[hh].first.first, c = q[hh].first.second;</span><br><span class="line">            <span class="keyword">int</span> x = grid[r][c];</span><br><span class="line">            <span class="keyword">int</span> cnt = q[hh].second;</span><br><span class="line">            </span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nex = x + i;</span><br><span class="line">                <span class="keyword">int</span> ner = heap[nex].first, nec = heap[nex].second;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "ner: " &lt;&lt; ner &lt;&lt; " nec: " &lt;&lt; nec &lt;&lt; " nex: " &lt;&lt; nex &lt;&lt; " cnt: " &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (nex == target || board[ner][nec] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nex &gt; target || board[ner][nec] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// determine teleport beacon</span></span><br><span class="line">                <span class="keyword">if</span> (board[ner][nec] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q[++tt] = &#123;heap[board[ner][nec]], cnt&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    q[++tt] = &#123;&#123;ner, nec&#125;, cnt&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                board[ner][nec] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="g_tab0-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * author: yxc@acwing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; id;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; cor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        id = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">        cor = <span class="built_in">vector</span>&lt;PII&gt;(n * m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, k = <span class="number">1</span>, s = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i --, s ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++, k ++ ) &#123;</span><br><span class="line">                    id[i][j] = k;</span><br><span class="line">                    cor[k] = &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --, k ++ ) &#123;</span><br><span class="line">                    id[i][j] = k;</span><br><span class="line">                    cor[k] = &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;PII&gt; q;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dist</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">1e9</span>))</span></span>;</span><br><span class="line">        q.push(&#123;n - <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        dist[n - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> k = id[t.x][t.y];</span><br><span class="line">            <span class="keyword">if</span> (k == n * m) <span class="keyword">return</span> dist[t.x][t.y];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= k + <span class="number">6</span> &amp;&amp; i &lt;= n * m; i ++ ) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = cor[i].x, y = cor[i].y;</span><br><span class="line">                <span class="keyword">if</span> (board[x][y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[x][y] &gt; dist[t.x][t.y] + <span class="number">1</span>) &#123;</span><br><span class="line">                        dist[x][y] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">                        q.push(&#123;x, y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = board[x][y];</span><br><span class="line">                    x = cor[r].x, y = cor[r].y;</span><br><span class="line">                    <span class="keyword">if</span> (dist[x][y] &gt; dist[t.x][t.y] + <span class="number">1</span>) &#123;</span><br><span class="line">                        dist[x][y] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">                        q.push(&#123;x, y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>



<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/snakes-and-ladders/" target="_blank" rel="noopener">LeetCode 909. 蛇梯棋</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode周赛246】D LeetCode 1906. 查询差绝对值的最小值</title>
    <url>/2021/06/23/%E3%80%90LeetCode%E5%91%A8%E8%B5%9B246%E3%80%91D-LeetCode-1906-%E6%9F%A5%E8%AF%A2%E5%B7%AE%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>前缀和配合计数排序，妙哉~！</p>
<a id="more"></a>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个数组 <code>a</code> 的 <strong>差绝对值的最小值</strong> 定义为：<code>0 &lt;= i &lt; j &lt; a.length</code> 且 <code>a[i] != a[j]</code> 的 <code>|a[i] - a[j]|</code> 的 <strong>最小值</strong>。如果 <code>a</code> 中所有元素都 相同 ，那么差绝对值的最小值为 <code>-1</code> 。</p>
<ul>
<li>比方说，数组 <code>[5,2,3,7,2]</code> 差绝对值的最小值是 <code>|2 - 3| = 1</code> 。注意答案不为 <code>0</code> ，因为 <code>a[i]</code> 和 <code>a[j]</code> 必须不相等。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> 和查询数组 <code>queries</code> ，其中 <code>queries[i] = [li, ri]</code> 。对于每个查询 <code>i</code> ，计算 <strong>子数组</strong> <code>nums[li...ri]</code> 中 <strong>差绝对值的最小值</strong> ，子数组 <code>nums[li...ri]</code> 包含 <code>nums</code> 数组（下标从 <strong>0</strong> 开始）中下标在 <code>li</code> 和 <code>ri</code> 之间的所有元素（包含 <code>li</code> 和 <code>ri</code> 在内）。</p>
<p>请你返回 <code>ans</code> <strong>数组</strong>，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p>
<p><strong>子数组</strong> 是一个数组中连续的一段元素。</p>
<p><code>|x|</code> 的值定义为：</p>
<p>如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。<br>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]<br>输出：[2,1,4,1]<br>解释：查询结果如下：<br>– queries[0] = [0,1]：子数组是 [1,3] ，差绝对值的最小值为 |1-3| = 2 。<br>– queries[1] = [1,2]：子数组是 [3,4] ，差绝对值的最小值为 |3-4| = 1 。<br>– queries[2] = [2,3]：子数组是 [4,8] ，差绝对值的最小值为 |4-8| = 4 。<br>– queries[3] = [0,3]：子数组是 [1,3,4,8] ，差的绝对值的最小值为 |3-4| = 1 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]<br>输出：[-1,1,1,3]<br>解释：查询结果如下：<br>– queries[0] = [2,3]：子数组是 [2,2] ，差绝对值的最小值为 -1 ，因为所有元素相等。<br>– queries[1] = [0,2]：子数组是 [4,5,2] ，差绝对值的最小值为 |4-5| = 1 。<br>– queries[2] = [0,5]：子数组是 [4,5,2,2,7,10] ，差绝对值的最小值为 |4-5| = 1 。<br>– queries[3] = [3,5]：子数组是 [2,7,10] ，差绝对值的最小值为 |7-10| = 3 。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>$2 &lt;= nums.length &lt;= 10^5$</li>
<li>$1 &lt;= nums[i] &lt;= 100$</li>
<li>$1 &lt;= queries.length &lt;= 2 * 10^4$</li>
<li>$0 &lt;= li &lt; ri &lt; nums.length$</li>
</ul>
<hr>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>先想想朴素做法，我们可以对于每一段查询获取一个子数组，对子数组排序，找到相邻数字差绝对值最小的数。</p>
<p>注意到数组元素的取值范围是 $1 &lt;= nums[i] &lt;= 100$, 因为范围很小所以很容易联想到计数排序。既然需要对子数组元素计数，自然联想到前缀和。</p>
<p>可以开一个二维数组，行表示为数组下标$+1$(因为前缀和需要考虑0的情况，避免出现值-1的下标)；列表示数组元素值在 $[1,100]$ 中的某个数。</p>
<p>遍历数组中的每个元素，再以当前元素为结束的前缀数组中，遍历 $[1,100]$ 中的每个数，对前缀数组进行计数。<br>注意当前行需要继承前一行的非零值。</p>
<p>举例：<br>对于数组 <code>nums = [1,3,4,8]</code> ,预处理出的前缀和数组为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br><span class="line">0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br><span class="line">0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br><span class="line">0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </span><br><span class="line">0 1 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure>
<p>那么可以在 $O(1)$ 的时间复杂度下得到某一段子数组如第2到3的所有元素计数情况。接着，可以在 $O(N)$ 的复杂度下得到这段子数组的 最小差绝对值。</p>
<div class="tabs" id="g_tab0"><ul class="nav-tabs"><li class="tab active"><a href="#g_tab0-1">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="g_tab0-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">presum</span><span class="params">(len + <span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">110</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// presum </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;                    <span class="comment">// 第i行放入数组前0 ~ i - 1项的和，即从1开始数组第某项放在第某行中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (presum[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    presum[i][j] = presum[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            presum[i][nums[i - <span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt;= len; i++) &#123;</span></span><br><span class="line"><span class="comment">            for (int j = 0; j &lt;= 100; j++) &#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; presum[i][j] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.<span class="built_in">size</span>(); i++) &#123;          <span class="comment">// 对于每组查询，依次找到子数组中的数，找到最小差绝对值</span></span><br><span class="line">            <span class="keyword">int</span> l = queries[i][<span class="number">0</span>] + <span class="number">1</span>, r = queries[i][<span class="number">1</span>] + <span class="number">1</span>;   <span class="comment">// 加1是因为l r是数组下标从0记起，而我们的前缀和是从1记起</span></span><br><span class="line">            <span class="keyword">int</span> tres = <span class="number">110</span>, last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++) &#123;                <span class="comment">// 从小到大遍历子数组中的数</span></span><br><span class="line">                <span class="keyword">if</span> (presum[r][j] - presum[l - <span class="number">1</span>][j] &gt; <span class="number">0</span>) &#123;  <span class="comment">// 找到一个子数组中的数</span></span><br><span class="line">                    <span class="keyword">if</span> (last) &#123;                             <span class="comment">// 如果当前子数组的数不是第一个（可以产生一个差绝对值）</span></span><br><span class="line">                        tres = <span class="built_in">min</span>(tres, j - last);         <span class="comment">// 当前子数组的数和上一个子数组的数绝对值差为 j - last</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    last = j;                               <span class="comment">// 不管当前数字是不是第一个子数组的数，last 都要更新为当前子数组的数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果某段子数组中只包含一种元素，那么31行只会进入一次，且因为是第一个元素第一次进入，那么32行不会进入，那么tres不会得到更新</span></span><br><span class="line">            <span class="keyword">if</span> (tres != <span class="number">110</span>)</span><br><span class="line">                res.push_back(tres);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                res.push_back(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<p>下面来思考一下预处理前缀和数组的时候，为什么 <code>i</code> 从 <code>1</code> 开始，前缀和数组第 <code>0</code> 位留空。</p>
<p>首先我们假设前缀和数组就是从第 <code>0</code> 位开始，即 <code>presum[i]</code> 对应原数组 $[0,i]$ 位元素的和。会发生什么呢？<br>假设求从 <code>0</code> 开始计算的第 <code>4</code> 位到第 <code>5</code> 位子数组和，那么使用这样一个前缀和数组可得：<br><code>int res = presum[5] - presum[4 - 1];</code><br>似乎没有问题，好，那我现在求第 <code>0</code> 位到第 <code>3</code> 位子数组的和：<br><code>int res = presum[3] - presum[0 - 1];</code><br>数组下标出现负数，为了避免这种情况，只能多一次判断，不方便。</p>
<p>另外，在生成前缀和数组时，递推公式为：<code>presum[i] = presum[i - 1] + nums[i]</code>.<br>问题是，这个递推公式无法适配所有情况。即，当 <code>i</code> 取 <code>0</code> 时，出现异常。<br>为了避免这个情况，只能把 <code>presum[0]</code> 拿出来预设为 <code>nums[0]</code> ，从数组第 <code>1</code> 项接着按照递推公式计算。不方便。</p>
<p>那么，为了方便地避免以上情况，我们决定将前缀和数组相对原数组向右偏移一位，用 <code>presum[1]</code> 表示原数组第 <code>0</code> 项， <code>presum[2]</code> 表示原数组第 <code>[0,1]</code> 项之和，将 <code>presum[i]</code> 表示为数组中 $[0,i-1]$ 所有数之和。</p>
<p>那么，如果求原数组从零计第 <code>l</code> 项到 <code>r</code> 项子数组之和，那么<br><code>int res = presum[r + 1] - presum[l + 1 - 1];</code><br>因为 <code>presum[r]</code> 表示的是 $[0, r-1]$ 项之和， <code>presum[l]</code> 表示 $[0,l-1]$ 项之和。<br>另外，如果求原数组从1计算第 <code>l</code> 项到 <code>r</code> 项子数组之和，可以直接：<br><code>int res = presum[r] - presum[l - 1];</code></p>
<div class="note primary">
            <p><strong>原题链接：</strong> <a href="https://leetcode-cn.com/problems/minimum-absolute-difference-queries/" target="_blank" rel="noopener">LeetCode 1906. 查询差绝对值的最小值</a></p>
          </div>]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>LeetCode</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>前缀和</tag>
        <tag>竞赛</tag>
        <tag>计数排序</tag>
      </tags>
  </entry>
  <entry>
    <title>给您拜个晚年，祝您新的一年心明眼亮，百毒不侵</title>
    <url>/2020/03/07/%E7%BB%99%E6%82%A8%E6%8B%9C%E4%B8%AA%E6%99%9A%E5%B9%B4%EF%BC%8C%E7%A5%9D%E6%82%A8%E6%96%B0%E7%9A%84%E4%B8%80%E5%B9%B4%E5%BF%83%E6%98%8E%E7%9C%BC%E4%BA%AE%EF%BC%8C%E7%99%BE%E6%AF%92%E4%B8%8D%E4%BE%B5/</url>
    <content><![CDATA[<h1 id="给您拜个晚年，祝您新的一年心明眼亮，百毒不侵"><a href="#给您拜个晚年，祝您新的一年心明眼亮，百毒不侵" class="headerlink" title="给您拜个晚年，祝您新的一年心明眼亮，百毒不侵"></a>给您拜个晚年，祝您新的一年心明眼亮，百毒不侵</h1><h2 id="一点感悟"><a href="#一点感悟" class="headerlink" title="一点感悟"></a>一点感悟</h2><h3 id="知乎有提问，新冠蔓延能带来哪些正面意义。"><a href="#知乎有提问，新冠蔓延能带来哪些正面意义。" class="headerlink" title="知乎有提问，新冠蔓延能带来哪些正面意义。"></a>知乎有提问，新冠蔓延能带来哪些正面意义。</h3><h3 id="当时就震惊了。题主是在开玩笑吗，还是对灾难没什么认识，亦或是在绝望的暗夜中寻找光明？试问，文化大革命给我们带来了哪些正面的意义？98洪水呢？汶川地震呢？"><a href="#当时就震惊了。题主是在开玩笑吗，还是对灾难没什么认识，亦或是在绝望的暗夜中寻找光明？试问，文化大革命给我们带来了哪些正面的意义？98洪水呢？汶川地震呢？" class="headerlink" title="当时就震惊了。题主是在开玩笑吗，还是对灾难没什么认识，亦或是在绝望的暗夜中寻找光明？试问，文化大革命给我们带来了哪些正面的意义？98洪水呢？汶川地震呢？"></a>当时就震惊了。题主是在开玩笑吗，还是对灾难没什么认识，亦或是在绝望的暗夜中寻找光明？试问，文化大革命给我们带来了哪些正面的意义？98洪水呢？汶川地震呢？</h3><h3 id="这他妈是灾难-ok？我建议题主问问在疫情中被感染的人，放心，你会被打死。问这种问题的时候，考虑一下在受灾者的感受，考虑一下奔赴在一线的医护人员的感受。"><a href="#这他妈是灾难-ok？我建议题主问问在疫情中被感染的人，放心，你会被打死。问这种问题的时候，考虑一下在受灾者的感受，考虑一下奔赴在一线的医护人员的感受。" class="headerlink" title="这他妈是灾难,ok？我建议题主问问在疫情中被感染的人，放心，你会被打死。问这种问题的时候，考虑一下在受灾者的感受，考虑一下奔赴在一线的医护人员的感受。"></a>这他妈是灾难,ok？我建议题主问问在疫情中被感染的人，放心，你会被打死。问这种问题的时候，考虑一下在受灾者的感受，考虑一下奔赴在一线的医护人员的感受。</h3><h3 id="惊蛰刚过，我仿佛已经看见万物复苏。祝好！"><a href="#惊蛰刚过，我仿佛已经看见万物复苏。祝好！" class="headerlink" title="惊蛰刚过，我仿佛已经看见万物复苏。祝好！"></a>惊蛰刚过，我仿佛已经看见万物复苏。祝好！</h3>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>新冠</tag>
      </tags>
  </entry>
  <entry>
    <title>b-1面试题总结-Java基础</title>
    <url>/2021/04/21/b-1%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<hr>
<p><strong>摘要：</strong><br>在原作基础上添加学习笔记。</p>
<a id="more"></a>

<h1 id="二-Java-基础-集合-多线程-JVM"><a href="#二-Java-基础-集合-多线程-JVM" class="headerlink" title="二 Java 基础+集合+多线程+JVM"></a>二 Java 基础+集合+多线程+JVM</h1><blockquote>
<p>作者：Guide 哥。</p>
<p><strong>介绍:</strong> Github 90k Star 项目 <strong><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a></strong>（公众号同名） 作者。每周都会在公众号更新一些自己原创干货。公众号后台回复“1”领取 Java 工程师必备学习资料+面试突击 pdf。</p>
</blockquote>
<h2 id="2-1-Java-基础"><a href="#2-1-Java-基础" class="headerlink" title="2.1. Java 基础"></a>2.1. Java 基础</h2><h3 id="2-1-1-面向对象和面向过程的区别"><a href="#2-1-1-面向对象和面向过程的区别" class="headerlink" title="2.1.1. 面向对象和面向过程的区别"></a>2.1.1. 面向对象和面向过程的区别</h3><ul>
<li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>
</ul>
<p>参见 issue : <a href="https://github.com/Snailclimb/JavaGuide/issues/431" target="_blank" rel="noopener">面向过程 ：面向过程性能比面向对象高？？</a></p>
<blockquote>
<p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</p>
<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p>
</blockquote>
<h3 id="2-1-2-Java-语言有哪些特点"><a href="#2-1-2-Java-语言有哪些特点" class="headerlink" title="2.1.2. Java 语言有哪些特点?"></a>2.1.2. Java 语言有哪些特点?</h3><ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ol>
<blockquote>
<p>修正（参见： <a href="https://github.com/Snailclimb/JavaGuide/issues/544" target="_blank" rel="noopener">issue#544</a>）：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。参考链接：<a href="http://www.cplusplus.com/reference/thread/thread/?kw=thread" target="_blank" rel="noopener">http://www.cplusplus.com/reference/thread/thread/?kw=thread</a></p>
</blockquote>
<h3 id="2-1-3-关于-JVM-JDK-和-JRE-最详细通俗的解答"><a href="#2-1-3-关于-JVM-JDK-和-JRE-最详细通俗的解答" class="headerlink" title="2.1.3. 关于 JVM JDK 和 JRE 最详细通俗的解答"></a>2.1.3. 关于 JVM JDK 和 JRE 最详细通俗的解答</h3><h4 id="2-1-3-1-JVM"><a href="#2-1-3-1-JVM" class="headerlink" title="2.1.3.1. JVM"></a>2.1.3.1. JVM</h4><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
<p><strong>什么是字节码?采用字节码的好处是什么?</strong></p>
<blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Java程序运行过程"></p>
<p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。<u>当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是 <strong>编译与解释共存</strong> 的语言。</u></p>
<blockquote>
<p>Q: 编译什么？解释什么？</p>
</blockquote>
<blockquote>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>
</blockquote>
<p><strong>总结：</strong></p>
<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<h4 id="2-1-3-2-JDK-和-JRE"><a href="#2-1-3-2-JDK-和-JRE" class="headerlink" title="2.1.3.2. JDK 和 JRE"></a>2.1.3.2. JDK 和 JRE</h4><p>JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h3 id="2-1-4-Oracle-JDK-和-OpenJDK-的对比"><a href="#2-1-4-Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="2.1.4. Oracle JDK 和 OpenJDK 的对比"></a>2.1.4. Oracle JDK 和 OpenJDK 的对比</h3><p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</p>
<p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p>
<p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>
</blockquote>
<p><strong>总结：</strong></p>
<ol>
<li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：<a href="https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence。" target="_blank" rel="noopener">https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence。</a></li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li>
<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li>
<li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li>
</ol>
<h3 id="2-1-5-Java-和-C-的区别"><a href="#2-1-5-Java-和-C-的区别" class="headerlink" title="2.1.5. Java 和 C++的区别?"></a>2.1.5. Java 和 C++的区别?</h3><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！</p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li>
<li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</strong> 这是一个值得深度思考的问题，具体原因推荐看这篇文章： <a href="https://blog.csdn.net/sszgg2006/article/details/49148189" target="_blank" rel="noopener">https://blog.csdn.net/sszgg2006/article/details/49148189</a><blockquote>
<p>Q: 为什么Java语言中字符串末尾不需要结束符？</p>
</blockquote>
</li>
</ul>
<h3 id="2-1-6-字符型常量和字符串常量的区别"><a href="#2-1-6-字符型常量和字符串常量的区别" class="headerlink" title="2.1.6. 字符型常量和字符串常量的区别?"></a>2.1.6. 字符型常量和字符串常量的区别?</h3><ol>
<li>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符</li>
<li>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li>
</ol>
<blockquote>
<p>java 编程思想第四版：2.2.2 节<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg" alt=""></p>
</blockquote>
<h3 id="2-1-7-构造器-Constructor-是否可被-override"><a href="#2-1-7-构造器-Constructor-是否可被-override" class="headerlink" title="2.1.7. 构造器 Constructor 是否可被 override?"></a>2.1.7. 构造器 Constructor 是否可被 override?</h3><p>Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="2-1-8-重载和重写的区别"><a href="#2-1-8-重载和重写的区别" class="headerlink" title="2.1.8. 重载和重写的区别"></a>2.1.8. 重载和重写的区别</h3><blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</blockquote>
<p><strong>重载：</strong></p>
<p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p>下面是《Java 核心技术》对重载这个概念的介绍：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktopjava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E9%87%8D%E8%BD%BD.jpg" alt=""></p>
<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<p><strong>重写：</strong></p>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p>
<p>暖心的 Guide 哥最后再来个图表总结一下！</p>
<table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">发生范围</td>
<td align="left">同一个类</td>
<td align="left">子类</td>
</tr>
<tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可修改</td>
<td align="left">子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可修改</td>
<td align="left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td align="left">访问修饰符</td>
<td align="left">可修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td align="left">发生阶段</td>
<td align="left">编译期</td>
<td align="left">运行期</td>
</tr>
</tbody></table>
<p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》,<a href="https://github.com/Snailclimb/JavaGuide/issues/892" target="_blank" rel="noopener">issue#892</a> ）：</p>
<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<p>⭐️ 关于 <strong>重写的返回值类</strong>型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"超级英雄"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"超人"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hero <span class="title">hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hero();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperSuperMan</span> <span class="keyword">extends</span> <span class="title">SuperMan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"超级超级英雄"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SuperMan <span class="title">hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuperMan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-9-Java-面向对象编程三大特性-封装-继承-多态"><a href="#2-1-9-Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="2.1.9. Java 面向对象编程三大特性: 封装 继承 多态"></a>2.1.9. Java 面向对象编程三大特性: 封装 继承 多态</h3><h4 id="2-1-9-1-封装"><a href="#2-1-9-1-封装" class="headerlink" title="2.1.9.1. 封装"></a>2.1.9.1. 封装</h4><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<h4 id="2-1-9-2-继承"><a href="#2-1-9-2-继承" class="headerlink" title="2.1.9.2. 继承"></a>2.1.9.2. 继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="2-1-9-3-多态"><a href="#2-1-9-3-多态" class="headerlink" title="2.1.9.3. 多态"></a>2.1.9.3. 多态</h4><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<h3 id="2-1-10-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#2-1-10-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="2.1.10. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>2.1.10. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h3><p><strong>可变性</strong></p>
<p>简单的来说：<code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p>
<blockquote>
<p>补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675" target="_blank" rel="noopener">issue 675</a>）：在 Java 9 之后，String 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 byte 数组存储字符串 <code>private final byte[] value</code></p>
</blockquote>
<p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 的构造方法都是调用父类构造方法也就是 <code>AbstractStringBuilder</code> 实现的，大家可以自行查阅源码。</p>
<p><code>AbstractStringBuilder.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Q: 为什么String类型是不可变的？<br>Q: 为什么 <code>StringBuffer</code> 是线程安全的？</p>
</blockquote>
<p><strong>线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h3 id="2-1-11-自动装箱与拆箱"><a href="#2-1-11-自动装箱与拆箱" class="headerlink" title="2.1.11. 自动装箱与拆箱"></a>2.1.11. 自动装箱与拆箱</h3><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>更多内容见：<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">深入剖析 Java 中的装箱和拆箱</a></p>
<blockquote>
<p>Q: 装箱和拆箱底层是怎么实现的？<br>A: 装箱过程是通过调用包装器的 <code>ValueOf</code> 方法实现的；拆箱过程是通过调用包装器的 <code>&lt;int/double/float...&gt;Value</code>实现的。</p>
</blockquote>
<h3 id="2-1-12-在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#2-1-12-在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="2.1.12. 在一个静态方法内调用一个非静态成员为什么是非法的?"></a>2.1.12. 在一个静态方法内调用一个非静态成员为什么是非法的?</h3><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<h3 id="2-1-13-在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#2-1-13-在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="2.1.13. 在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>2.1.13. 在 Java 中定义一个不做事且没有参数的构造方法的作用</h3><p>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<blockquote>
<p>Q: 我们知道，如果一个类没有声明构造方法，却可以拥有一个默认的构造方法。那么，为什么还需要定义不带参没有内容的构造方法，以供子类加载呢？<br>A: <del>因为如果类没有定义构造方法，是编译器在将java文件 <strong>编译</strong> 成.class文件的的时候自动为类添加无参构造方法。而子类需要在 <strong>类加载</strong> 的验证阶段检查父类的数据，初始化父类。</del></p>
</blockquote>
<h3 id="2-1-14-接口和抽象类的区别是什么？"><a href="#2-1-14-接口和抽象类的区别是什么？" class="headerlink" title="2.1.14. 接口和抽象类的区别是什么？"></a>2.1.14. 接口和抽象类的区别是什么？</h3><ol>
<li>接口的方法默认是 <code>public</code>，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>
<li>接口中除了 <code>static</code>、<code>final</code> 变量，不能有其他变量，而抽象类中则不一定。</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 <code>extends</code> 关键字扩展多个接口。</li>
<li>接口方法默认修饰符是 <code>public</code>，抽象方法可以有 <code>public</code>、<code>protected</code> 和 <code>default</code> 这些修饰符（抽象方法就是为了被重写所以不能使用 <code>private</code> 关键字修饰！）。</li>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
</ol>
<blockquote>
<p>备注：</p>
<ol>
<li>在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。(详见 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/146" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/146</a>。</li>
<li>jdk9 的接口被允许定义私有方法 。</li>
</ol>
</blockquote>
<p>总结一下 jdk7~jdk9 Java 中接口概念的变化（<a href="https://www.geeksforgeeks.org/private-methods-java-9-interfaces/" target="_blank" rel="noopener">相关阅读</a>）：</p>
<ol>
<li>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。</li>
<li>jdk 8 的时候接口可以有默认方法和静态方法功能。</li>
<li>Jdk 9 在接口中引入了私有方法和私有静态方法。</li>
</ol>
<h3 id="2-1-15-成员变量与局部变量的区别有哪些？"><a href="#2-1-15-成员变量与局部变量的区别有哪些？" class="headerlink" title="2.1.15. 成员变量与局部变量的区别有哪些？"></a>2.1.15. 成员变量与局部变量的区别有哪些？</h3><ol>
<li>从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li>
<li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引用数据类型，那存放的是指向堆内存对象的引用或者是指向常量池中的地址。</li>
<li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ol>
<h3 id="2-1-16-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#2-1-16-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="2.1.16. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>2.1.16. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h3 id="2-1-17-什么是方法的返回值-返回值在类的方法里的作用是什么"><a href="#2-1-17-什么是方法的返回值-返回值在类的方法里的作用是什么" class="headerlink" title="2.1.17. 什么是方法的返回值?返回值在类的方法里的作用是什么?"></a>2.1.17. 什么是方法的返回值?返回值在类的方法里的作用是什么?</h3><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p>
<h3 id="2-1-18-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#2-1-18-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="2.1.18. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>2.1.18. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h3><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h3 id="2-1-19-构造方法有哪些特性？"><a href="#2-1-19-构造方法有哪些特性？" class="headerlink" title="2.1.19. 构造方法有哪些特性？"></a>2.1.19. 构造方法有哪些特性？</h3><ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<h3 id="2-1-20-静态方法和实例方法有何不同"><a href="#2-1-20-静态方法和实例方法有何不同" class="headerlink" title="2.1.20. 静态方法和实例方法有何不同"></a>2.1.20. 静态方法和实例方法有何不同</h3><ol>
<li><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p>
</li>
<li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p>
</li>
</ol>
<h3 id="2-1-21-对象的相等与指向他们的引用相等-两者有什么不同"><a href="#2-1-21-对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="2.1.21. 对象的相等与指向他们的引用相等,两者有什么不同?"></a>2.1.21. 对象的相等与指向他们的引用相等,两者有什么不同?</h3><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h3 id="2-1-22-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#2-1-22-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="2.1.22. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>2.1.22. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h3><p>帮助子类做初始化工作。</p>
<h3 id="2-1-23-与-equals-重要"><a href="#2-1-23-与-equals-重要" class="headerlink" title="2.1.23. == 与 equals(重要)"></a>2.1.23. == 与 equals(重要)</h3><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
</ul>
<p><strong>举个例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li>
<li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li>
</ul>
<h3 id="2-1-24-hashCode-与-equals-重要"><a href="#2-1-24-hashCode-与-equals-重要" class="headerlink" title="2.1.24. hashCode 与 equals (重要)"></a>2.1.24. hashCode 与 equals (重要)</h3><p>面试官可能会问你：“你重写过 <code>hashcode</code> 和 <code>equals</code>么，为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？”</p>
<p><strong>1)hashCode()介绍:</strong></p>
<p><code>hashCode()</code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<p><strong>2)为什么要有 hashCode？</strong></p>
<p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 hashCode？</p>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code> 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p><strong>3)为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p>
<p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p>
<blockquote>
<p><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</blockquote>
<p><strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></p>
<p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p>
<p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p>
<p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p>
<p>更多关于 <code>hashcode()</code> 和 <code>equals()</code> 的内容可以查看：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">Java hashCode() 和 equals()的若干问题解答</a></p>
<h3 id="2-1-25-为什么-Java-中只有值传递？"><a href="#2-1-25-为什么-Java-中只有值传递？" class="headerlink" title="2.1.25. 为什么 Java 中只有值传递？"></a>2.1.25. 为什么 Java 中只有值传递？</h3><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。</p>
<p><strong>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p>
<p><strong>下面通过 3 个例子来给大家说明</strong></p>
<blockquote>
<p><strong>example 1</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">    System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 20</span><br><span class="line">b &#x3D; 10</span><br><span class="line">num1 &#x3D; 10</span><br><span class="line">num2 &#x3D; 20</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg" alt="example 1 "></p>
<p>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>
<blockquote>
<p><strong>example 2</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">	change(arr);</span><br><span class="line">	System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">	array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg" alt="example 2"></p>
<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>
<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>
<p><strong>很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p>
<blockquote>
<p><strong>example 3</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Student s1 = <span class="keyword">new</span> Student(<span class="string">"小张"</span>);</span><br><span class="line">		Student s2 = <span class="keyword">new</span> Student(<span class="string">"小李"</span>);</span><br><span class="line">		Test.swap(s1, s2);</span><br><span class="line">		System.out.println(<span class="string">"s1:"</span> + s1.getName());</span><br><span class="line">		System.out.println(<span class="string">"s2:"</span> + s2.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">		Student temp = x;</span><br><span class="line">		x = y;</span><br><span class="line">		y = temp;</span><br><span class="line">		System.out.println(<span class="string">"x:"</span> + x.getName());</span><br><span class="line">		System.out.println(<span class="string">"y:"</span> + y.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p>交换之前：</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg" alt=""></p>
<p>交换之后：</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg" alt=""></p>
<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>
<blockquote>
<p><strong>总结</strong></p>
</blockquote>
<p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按<br>值传递的。</p>
<p>下面再总结一下 Java 中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<p><strong>参考：</strong></p>
<p>《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节</p>
<h3 id="2-1-26-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#2-1-26-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="2.1.26. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>2.1.26. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h3><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。<br>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<h3 id="2-1-27-线程有哪些基本状态"><a href="#2-1-27-线程有哪些基本状态" class="headerlink" title="2.1.27. 线程有哪些基本状态?"></a>2.1.27. 线程有哪些基本状态?</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java线程的状态"></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java线程状态变迁"></p>
<p>由上图可以看出：</p>
<p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png" alt="RUNNABLE-VS-RUNNING"></p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<h3 id="2-1-28-关于-final-关键字的一些总结"><a href="#2-1-28-关于-final-关键字的一些总结" class="headerlink" title="2.1.28. 关于 final 关键字的一些总结"></a>2.1.28. 关于 final 关键字的一些总结</h3><p>final 关键字主要用在三个地方：变量、方法、类。</p>
<ol>
<li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li>
<li>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</li>
<li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</li>
</ol>
<h3 id="2-1-29-Java-中的异常处理"><a href="#2-1-29-Java-中的异常处理" class="headerlink" title="2.1.29. Java 中的异常处理"></a>2.1.29. Java 中的异常处理</h3><h4 id="2-1-29-1-Java-异常类层次结构图"><a href="#2-1-29-1-Java-异常类层次结构图" class="headerlink" title="2.1.29.1. Java 异常类层次结构图"></a>2.1.29.1. Java 异常类层次结构图</h4><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt=""></p>
<p style="font-size:13px;text-align:right">图片来自：https://simplesnippets.tech/exception-handling-in-java-part-1/</p>

<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.png" alt=""></p>
<p style="font-size:13px;text-align:right">图片来自：https://chercher.tech/java-programming/exceptions-java</p>

<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p>
<p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<p><strong>受检查异常</strong></p>
<p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/check-exception.png" alt="check-exception"></p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p>
<p><strong>不受检查异常</strong></p>
<p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPoin​terException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p>
<h4 id="2-1-29-2-Throwable-类常用方法"><a href="#2-1-29-2-Throwable-类常用方法" class="headerlink" title="2.1.29.2. Throwable 类常用方法"></a>2.1.29.2. Throwable 类常用方法</h4><ul>
<li><strong><code>public string getMessage()</code></strong>:返回异常发生时的简要描述</li>
<li><strong><code>public string toString()</code></strong>:返回异常发生时的详细信息</li>
<li><strong><code>public string getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage（）</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h4 id="2-1-29-3-异常处理总结"><a href="#2-1-29-3-异常处理总结" class="headerlink" title="2.1.29.3. 异常处理总结"></a>2.1.29.3. 异常处理总结</h4><ul>
<li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>
</ul>
<p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>
<ol>
<li>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/190</a>。</p>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<h3 id="2-1-30-Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#2-1-30-Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="2.1.30. Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>2.1.30. Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p>
<h3 id="2-1-31-获取用键盘输入常用的两种方法"><a href="#2-1-31-获取用键盘输入常用的两种方法" class="headerlink" title="2.1.31. 获取用键盘输入常用的两种方法"></a>2.1.31. 获取用键盘输入常用的两种方法</h3><p>方法 1：通过 Scanner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<p>方法 2：通过 BufferedReader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>

<h3 id="2-1-32-Java-中-IO-流"><a href="#2-1-32-Java-中-IO-流" class="headerlink" title="2.1.32. Java 中 IO 流"></a>2.1.32. Java 中 IO 流</h3><h4 id="2-1-32-1-Java-中-IO-流分为几种"><a href="#2-1-32-1-Java-中-IO-流分为几种" class="headerlink" title="2.1.32.1. Java 中 IO 流分为几种?"></a>2.1.32.1. Java 中 IO 流分为几种?</h4><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>按操作方式分类结构图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt="IO-操作方式分类"></p>
<p>按操作对象分类结构图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.png" alt="IO-操作对象分类"></p>
<h4 id="2-1-32-2-既然有了字节流-为什么还要有字符流"><a href="#2-1-32-2-既然有了字节流-为什么还要有字符流" class="headerlink" title="2.1.32.2. 既然有了字节流,为什么还要有字符流?"></a>2.1.32.2. 既然有了字节流,为什么还要有字符流?</h4><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h4 id="2-1-32-3-BIO-NIO-AIO-有什么区别"><a href="#2-1-32-3-BIO-NIO-AIO-有什么区别" class="headerlink" title="2.1.32.3. BIO,NIO,AIO 有什么区别?"></a>2.1.32.3. BIO,NIO,AIO 有什么区别?</h4><ul>
<li><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
<li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<h3 id="2-1-33-深拷贝-vs-浅拷贝"><a href="#2-1-33-深拷贝-vs-浅拷贝" class="headerlink" title="2.1.33. 深拷贝 vs 浅拷贝"></a>2.1.33. 深拷贝 vs 浅拷贝</h3><ol>
<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ol>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p>
<h3 id="2-1-34-参考"><a href="#2-1-34-参考" class="headerlink" title="2.1.34. 参考"></a>2.1.34. 参考</h3><ul>
<li><a href="https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre" target="_blank" rel="noopener">https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre</a></li>
<li><a href="https://www.educba.com/oracle-vs-openjdk/" target="_blank" rel="noopener">https://www.educba.com/oracle-vs-openjdk/</a></li>
<li><a href="https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top" target="_blank" rel="noopener">https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top</a></li>
</ul>
<h3 id="2-1-35-公众号"><a href="#2-1-35-公众号" class="headerlink" title="2.1.35. 公众号"></a>2.1.35. 公众号</h3><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p>
<p><strong>《JavaGuide 面试突击版》 :</strong> 由本文档衍生的专为面试而生的《JavaGuide 面试突击版》 版本<a href="#公众号">公众号</a>后台回复 <strong>“Java 面试突击”</strong> 即可免费领取！</p>
<p><strong>Java 工程师必备学习资源:</strong> 一些 Java 工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/167598cd2e17b8ec.png" alt="我的公众号"></p>
]]></content>
  </entry>
  <entry>
    <title>聊一聊递归</title>
    <url>/2021/06/25/%E8%81%8A%E4%B8%80%E8%81%8A%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>递归、回溯、DFS，都聊一聊。</p>
<a id="more"></a>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>很简单，就是指一段函数内部调用自己。细一点，它分为「递」和「归」两个过程。<br>这些都是大家都知道的东西，今天我想聊一聊如何构建一段标准的递归代码。</p>
<p>首先是递归进入条件。<br>首次在递归函数外部调用递归函数的条件，需要和递归函数内部调用自身的条件一致。</p>
<p>未完待续。</p>
]]></content>
      <categories>
        <category>指尖飞舞</category>
        <category>算法</category>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>驾驶技术学习心得</title>
    <url>/2020/08/17/%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/repo/2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h2><blockquote>
<p>项目开始前准备：<br>系好安全带，放下手刹，踩下刹车，启动引擎，踩下离合器。</p>
</blockquote>
<hr>
<h3 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h3><p><img src="2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/%E5%80%92%E8%BD%A6%E5%85%A5%E5%BA%93.png" alt="pic0x0"><br><strong>左倒库：</strong> </p>
<ul>
<li>step 1: 挂1挡，轻踩离合至左后视镜看到L1角，方向盘向左打满。</li>
<li>step 2: 车身垂直于A线方向盘回正。</li>
<li>step 3: 行驶至胳膊超过A线离合刹车踩满停下，准备左倒车入库。</li>
<li>step 4: 挂倒挡，轻踩离合当车辆倒至左后视镜下边缘与A线重合，方向盘向左打满。</li>
<li>step 5: 此时注意左后视镜L1角，当L1角出现时，注意它和车身距离。大于30cm则车辆位置正确；小于则转角过大，方向盘向右回一圈减小转角。</li>
<li>step 6: 此时注意观察右后视镜，观察当R2角出现时，方向盘迅速回正，此时注意到车身和R线平行。</li>
<li>step 7: 继续倒车直至左后视镜下边缘与L1角重合。</li>
</ul>
<p><strong>右倒库：</strong></p>
<ul>
<li>step 1: 挂1挡，轻踩离合至左后视镜看到L1角，方向盘向右打满。</li>
<li>step 2: 车身垂直于B线方向盘回正。</li>
<li>step 3: 行驶至胳膊超过B线离合刹车踩满停下，准备右倒车入库。</li>
<li>step 4: 挂倒挡，轻踩离合当车辆倒至左后视镜下边缘与B线重合，方向盘向右打满。</li>
<li>step 5: 此时注意观察右后视镜R1角，当R1角出现时，注意它和车身距离。大于30cm则车辆位置正确；小于则转角过大，方向盘向左回一圈减小转角。</li>
<li>step 6: 此时注意左后视镜，观察当L2角出现时，方向盘迅速回正，此时注意到车身和L线平行。</li>
<li>step 7: 继续倒车直至左后视镜下边缘与L1角重合。</li>
</ul>
<h3 id="侧方位停车"><a href="#侧方位停车" class="headerlink" title="侧方位停车"></a>侧方位停车</h3><p><img src="2020-08-17-%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/%E4%BE%A7%E6%96%B9%E5%81%9C%E8%BD%A6.png" alt="pic0x1"><br><strong>将车开出车库至准备区域：</strong></p>
<ul>
<li>step 1: 挂1挡，踩离合，打左转向灯，方向盘向左打满。</li>
<li>step 2：注意观察左后视镜，当B角出现时，回正方向盘。</li>
<li>step 3：让车辆继续缓缓行驶，注意观察左后视镜，当左前门门把手与车库虚线重合时，方向盘向右打满。</li>
<li>step 4：观察右后视镜，当车右侧与虚线平行时，车身已正，方向盘回正。</li>
<li>step 5：观察右后视镜，当A角出现时，停车。</li>
</ul>
<p><strong>右侧方停车：</strong></p>
<ul>
<li>step 1：挂倒挡，观察右后视镜，当A直角消失，方向盘又打满。</li>
<li>step 2：注意观察左后视镜，当B直角出现，方向盘回正。</li>
<li>step 3：注意观察左后视镜，当左后轮即将碰到车库虚线时，方向盘左打满。</li>
<li>step 4：注意观察右后视镜，当车右侧与车库边线平行时，车身已正。停车。</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>驾驶技术</tag>
      </tags>
  </entry>
</search>
